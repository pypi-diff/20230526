# Comparing `tmp/snoopy_bv-2.0.1-cp39-cp39-win_amd64.whl.zip` & `tmp/snoopy_bv-2.0.2-cp311-cp311-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,152 +1,166 @@
-Zip file size: 4432321 bytes, number of entries: 150
--rw-rw-rw-  2.0 fat     2816 b- defN 23-Mar-28 11:22 Snoopy/__init__.py
--rw-rw-rw-  2.0 fat      131 b- defN 23-Apr-17 08:51 Snoopy/version.py
--rw-rw-rw-  2.0 fat  3260928 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Geometry.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  2544128 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Math.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1123328 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Mechanics.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1093120 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Meshing.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  2224128 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Spectral.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   599040 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_Statistics.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1214976 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_TimeDomain.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   740864 b- defN 23-Apr-17 10:45 Snoopy/DLLs/_WaveKinematic.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     6915 b- defN 23-Mar-28 11:22 Snoopy/Dataset/__init__.py
--rw-rw-rw-  2.0 fat      197 b- defN 23-Mar-28 11:22 Snoopy/Fatigue/__init__.py
--rw-rw-rw-  2.0 fat     4922 b- defN 23-Mar-28 11:22 Snoopy/Fatigue/rainflow.py
--rw-rw-rw-  2.0 fat    15472 b- defN 23-Mar-28 11:22 Snoopy/Fatigue/sn_curve.py
--rw-rw-rw-  2.0 fat    11379 b- defN 23-Mar-31 15:05 Snoopy/Geometry/__init__.py
--rw-rw-rw-  2.0 fat     1835 b- defN 23-Mar-28 11:22 Snoopy/Geometry/sx3Manipulation.py
--rw-rw-rw-  2.0 fat     8977 b- defN 23-Mar-28 11:22 Snoopy/Math/Functions.py
--rw-rw-rw-  2.0 fat     2777 b- defN 23-Mar-28 11:22 Snoopy/Math/_HLCL.py
--rw-rw-rw-  2.0 fat     4795 b- defN 23-Mar-28 11:22 Snoopy/Math/_MHLGA.py
--rw-rw-rw-  2.0 fat      469 b- defN 23-Mar-28 11:22 Snoopy/Math/__init__.py
--rw-rw-rw-  2.0 fat     3694 b- defN 23-Mar-28 11:22 Snoopy/Math/cmplxInterp.py
--rw-rw-rw-  2.0 fat     4436 b- defN 23-Mar-28 11:22 Snoopy/Math/interpolate.py
--rw-rw-rw-  2.0 fat     2244 b- defN 23-Mar-28 11:22 Snoopy/Math/iso_contour.py
--rw-rw-rw-  2.0 fat     1737 b- defN 23-Mar-28 11:22 Snoopy/Math/numerical_jacobian.py
--rw-rw-rw-  2.0 fat     2353 b- defN 23-Mar-28 11:22 Snoopy/Math/numpy_related.py
--rw-rw-rw-  2.0 fat     2450 b- defN 23-Mar-28 11:22 Snoopy/Mechanics/ReferenceFrameTools.py
--rw-rw-rw-  2.0 fat     5497 b- defN 23-Apr-11 07:11 Snoopy/Mechanics/__init__.py
--rw-rw-rw-  2.0 fat    19575 b- defN 23-Apr-11 07:11 Snoopy/Mechanics/hydro_coef.py
--rw-rw-rw-  2.0 fat     3936 b- defN 23-Mar-28 11:22 Snoopy/Mechanics/hydro_coef_io.py
--rw-rw-rw-  2.0 fat    16603 b- defN 23-Apr-11 07:11 Snoopy/Mechanics/internal_load.py
--rw-rw-rw-  2.0 fat    52041 b- defN 23-Mar-28 11:22 Snoopy/Mechanics/mass_distribution.py
--rw-rw-rw-  2.0 fat    20043 b- defN 23-Apr-11 07:11 Snoopy/Mechanics/mass_section.py
--rw-rw-rw-  2.0 fat     3920 b- defN 23-Mar-28 11:22 Snoopy/Mechanics/matrans.py
--rw-rw-rw-  2.0 fat    15841 b- defN 23-Apr-11 07:11 Snoopy/Mechanics/mechanicalsolver.py
--rw-rw-rw-  2.0 fat     3928 b- defN 23-Mar-28 11:22 Snoopy/Meshing/FreeSurfaceMesher.py
--rw-rw-rw-  2.0 fat      266 b- defN 23-Mar-28 11:22 Snoopy/Meshing/__init__.py
--rw-rw-rw-  2.0 fat    11918 b- defN 23-Mar-28 11:22 Snoopy/Meshing/balance.py
--rw-rw-rw-  2.0 fat      425 b- defN 23-Mar-28 11:22 Snoopy/Meshing/hsbln.py
--rw-rw-rw-  2.0 fat     8516 b- defN 23-Mar-28 11:22 Snoopy/Meshing/hydroStarMesh.py
--rw-rw-rw-  2.0 fat     1590 b- defN 23-Mar-28 11:22 Snoopy/Meshing/hydro_names.py
--rw-rw-rw-  2.0 fat    42068 b- defN 23-Mar-28 11:22 Snoopy/Meshing/mesh.py
--rw-rw-rw-  2.0 fat     5016 b- defN 23-Mar-28 11:22 Snoopy/Meshing/mesh_io.py
--rw-rw-rw-  2.0 fat     1006 b- defN 23-Mar-28 11:22 Snoopy/Meshing/structuredGrid.py
--rw-rw-rw-  2.0 fat     9171 b- defN 23-Mar-28 11:22 Snoopy/Meshing/vtkTools.py
--rw-rw-rw-  2.0 fat     3488 b- defN 23-Mar-28 11:22 Snoopy/Meshing/vtkView.py
--rw-rw-rw-  2.0 fat     7714 b- defN 23-Mar-28 11:22 Snoopy/Meshing/waterline.py
--rw-rw-rw-  2.0 fat     1192 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/__init__.py
--rw-rw-rw-  2.0 fat     5845 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/_scatterPlot.py
--rw-rw-rw-  2.0 fat     1808 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/addScale.py
--rw-rw-rw-  2.0 fat     2199 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/addcopyfighandler.py
--rw-rw-rw-  2.0 fat     5464 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/customScale.py
--rw-rw-rw-  2.0 fat    14973 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/dfPlot.py
--rw-rw-rw-  2.0 fat    19002 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/geoMap.py
--rw-rw-rw-  2.0 fat     1485 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/gnuplot_compat.py
--rw-rw-rw-  2.0 fat      573 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/meshPlot.py
--rw-rw-rw-  2.0 fat     8396 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/misc.py
--rw-rw-rw-  2.0 fat     2669 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/mplZoom.py
--rw-rw-rw-  2.0 fat      202 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/snoopy.mplstyle
--rw-rw-rw-  2.0 fat    12986 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/statPlots.py
--rw-rw-rw-  2.0 fat     2475 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/surfacePlot.py
--rw-rw-rw-  2.0 fat      621 b- defN 23-Mar-28 11:22 Snoopy/PyplotTools/vtkLUT.py
--rw-rw-rw-  2.0 fat     2599 b- defN 23-Mar-28 11:22 Snoopy/Reader/OperaH5Reader.py
--rw-rw-rw-  2.0 fat     2905 b- defN 23-Mar-28 11:22 Snoopy/Reader/__init__.py
--rw-rw-rw-  2.0 fat     1964 b- defN 23-Mar-28 11:22 Snoopy/Reader/arianeReader.py
--rw-rw-rw-  2.0 fat     2484 b- defN 23-Mar-28 11:22 Snoopy/Reader/bvFormat.py
--rw-rw-rw-  2.0 fat     2772 b- defN 23-Mar-28 11:22 Snoopy/Reader/bvHdf5.py
--rw-rw-rw-  2.0 fat     6238 b- defN 23-Mar-28 11:22 Snoopy/Reader/donFormat.py
--rw-rw-rw-  2.0 fat    12509 b- defN 23-Mar-28 11:22 Snoopy/Reader/dynProbeReader.py
--rw-rw-rw-  2.0 fat     6613 b- defN 23-Mar-28 11:22 Snoopy/Reader/hydrostar.py
--rw-rw-rw-  2.0 fat    10243 b- defN 23-Mar-28 11:22 Snoopy/Reader/hydrostar_v.py
--rw-rw-rw-  2.0 fat     8985 b- defN 23-Mar-28 11:22 Snoopy/Reader/input_mcn_parser.py
--rw-rw-rw-  2.0 fat      809 b- defN 23-Mar-28 11:22 Snoopy/Reader/json_tools.py
--rw-rw-rw-  2.0 fat    16360 b- defN 23-Mar-28 11:22 Snoopy/Reader/openFoam.py
--rw-rw-rw-  2.0 fat     3061 b- defN 23-Mar-28 11:22 Snoopy/Reader/readInput.py
--rw-rw-rw-  2.0 fat      651 b- defN 23-Mar-28 11:22 Snoopy/Reader/read_csv_block.py
--rw-rw-rw-  2.0 fat     1057 b- defN 23-Mar-28 11:22 Snoopy/Reader/simpleReader.py
--rw-rw-rw-  2.0 fat     7632 b- defN 23-Mar-28 11:22 Snoopy/Reader/starspec.py
--rw-rw-rw-  2.0 fat     2571 b- defN 23-Mar-28 11:22 Snoopy/Reader/tecplot.py
--rw-rw-rw-  2.0 fat     6586 b- defN 23-Mar-28 11:22 Snoopy/Spectral/Qtf_class.py
--rw-rw-rw-  2.0 fat     1566 b- defN 23-Mar-28 11:22 Snoopy/Spectral/__init__.py
--rw-rw-rw-  2.0 fat     8228 b- defN 23-Mar-28 11:22 Snoopy/Spectral/dampingLinearization.py
--rw-rw-rw-  2.0 fat     7098 b- defN 23-Mar-28 11:22 Snoopy/Spectral/dispersion.py
--rw-rw-rw-  2.0 fat    12107 b- defN 23-Mar-28 11:22 Snoopy/Spectral/edw.py
--rw-rw-rw-  2.0 fat     2036 b- defN 23-Mar-28 11:22 Snoopy/Spectral/enc_freq.py
--rw-rw-rw-  2.0 fat     9159 b- defN 23-Mar-28 11:22 Snoopy/Spectral/headingConvention.py
--rw-rw-rw-  2.0 fat    11375 b- defN 23-Mar-28 11:22 Snoopy/Spectral/linearize_and_match.py
--rw-rw-rw-  2.0 fat     6522 b- defN 23-Mar-28 11:22 Snoopy/Spectral/misc.py
--rw-rw-rw-  2.0 fat    23093 b- defN 23-Mar-28 11:22 Snoopy/Spectral/mqtf.py
--rw-rw-rw-  2.0 fat    23922 b- defN 23-Mar-28 11:22 Snoopy/Spectral/qtf.py
--rw-rw-rw-  2.0 fat    55462 b- defN 23-Apr-11 07:11 Snoopy/Spectral/rao.py
--rw-rw-rw-  2.0 fat     4748 b- defN 23-Mar-28 11:22 Snoopy/Spectral/responseSpectrum.py
--rw-rw-rw-  2.0 fat    15185 b- defN 23-Mar-28 11:22 Snoopy/Spectral/seaStateList.py
--rw-rw-rw-  2.0 fat    51177 b- defN 23-Mar-28 11:22 Snoopy/Spectral/seastate.py
--rw-rw-rw-  2.0 fat      417 b- defN 23-Mar-28 11:22 Snoopy/Spectral/spectralMoments.py
--rw-rw-rw-  2.0 fat    17181 b- defN 23-Mar-28 11:22 Snoopy/Spectral/spectralStats.py
--rw-rw-rw-  2.0 fat    19732 b- defN 23-Mar-28 11:22 Snoopy/Spectral/spectrum.py
--rw-rw-rw-  2.0 fat     1255 b- defN 23-Mar-28 11:22 Snoopy/Spectral/spreading.py
--rw-rw-rw-  2.0 fat     4922 b- defN 23-Mar-28 11:22 Snoopy/Spectral/waveMaker.py
--rw-rw-rw-  2.0 fat     5798 b- defN 23-Mar-28 11:22 Snoopy/Spectral/wib.py
--rw-rw-rw-  2.0 fat    25853 b- defN 23-Apr-06 08:09 Snoopy/Spectral/wif.py
--rw-rw-rw-  2.0 fat     4535 b- defN 23-Mar-28 11:22 Snoopy/Spectral/wifm.py
--rw-rw-rw-  2.0 fat     1084 b- defN 23-Mar-30 13:21 Snoopy/Statistics/__init__.py
--rw-rw-rw-  2.0 fat    22279 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_blockMaxima.py
--rw-rw-rw-  2.0 fat    24386 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_diform.py
--rw-rw-rw-  2.0 fat     3259 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_impact_velocity.py
--rw-rw-rw-  2.0 fat    21015 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_longTerm.py
--rw-rw-rw-  2.0 fat    10049 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_longTermSD.py
--rw-rw-rw-  2.0 fat    26149 b- defN 23-Mar-28 11:22 Snoopy/Statistics/_pot.py
--rw-rw-rw-  2.0 fat    16281 b- defN 23-Mar-28 11:22 Snoopy/Statistics/discreteSD.py
--rw-rw-rw-  2.0 fat     7951 b- defN 23-Mar-28 11:22 Snoopy/Statistics/dist.py
--rw-rw-rw-  2.0 fat     2671 b- defN 23-Mar-28 11:22 Snoopy/Statistics/distribution_cpp.py
--rw-rw-rw-  2.0 fat      905 b- defN 23-Mar-28 11:22 Snoopy/Statistics/distribution_jitted.py
--rw-rw-rw-  2.0 fat     3394 b- defN 23-Mar-28 11:22 Snoopy/Statistics/empirical_quantiles.py
--rw-rw-rw-  2.0 fat      989 b- defN 23-Mar-28 11:22 Snoopy/Statistics/f_maxEntropy.py
--rw-rw-rw-  2.0 fat     3637 b- defN 23-Mar-28 11:22 Snoopy/Statistics/longterm_rba.py
--rw-rw-rw-  2.0 fat     5080 b- defN 23-Mar-28 11:22 Snoopy/Statistics/maxEntropySolver.py
--rw-rw-rw-  2.0 fat     1371 b- defN 23-Mar-28 11:22 Snoopy/Statistics/powern.py
--rw-rw-rw-  2.0 fat    21646 b- defN 23-Mar-28 11:22 Snoopy/Statistics/returnLevel.py
--rw-rw-rw-  2.0 fat     3109 b- defN 23-Mar-28 11:22 Snoopy/Statistics/statErrors.py
--rw-rw-rw-  2.0 fat    23835 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/TimeSignals.py
--rw-rw-rw-  2.0 fat     1000 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/__init__.py
--rw-rw-rw-  2.0 fat     4711 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/concat_time_series.py
--rw-rw-rw-  2.0 fat    11955 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/decayTest.py
--rw-rw-rw-  2.0 fat     9906 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/decluster.py
--rw-rw-rw-  2.0 fat     2025 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/forcedOscillation.py
--rw-rw-rw-  2.0 fat     4316 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/oneDof.py
--rw-rw-rw-  2.0 fat     2312 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/radiation.py
--rw-rw-rw-  2.0 fat     2629 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/reconstruction1st.py
--rw-rw-rw-  2.0 fat     2691 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/reconstructionMulti.py
--rw-rw-rw-  2.0 fat     1013 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/reconstructionQtf.py
--rw-rw-rw-  2.0 fat     3447 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/reconstructionRaoFFT.py
--rw-rw-rw-  2.0 fat     1754 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/slammingVelocity.py
--rw-rw-rw-  2.0 fat     7877 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/srs.py
--rw-rw-rw-  2.0 fat    13164 b- defN 23-Mar-28 11:22 Snoopy/TimeDomain/upCross.py
--rw-rw-rw-  2.0 fat      216 b- defN 23-Mar-28 11:22 Snoopy/Tools/__init__.py
--rw-rw-rw-  2.0 fat     5510 b- defN 23-Mar-28 11:22 Snoopy/Tools/_deprecated.py
--rw-rw-rw-  2.0 fat      453 b- defN 23-Mar-28 11:22 Snoopy/Tools/callCounter.py
--rw-rw-rw-  2.0 fat     1729 b- defN 23-Mar-28 11:22 Snoopy/Tools/logTimerFormatter.py
--rw-rw-rw-  2.0 fat     1465 b- defN 23-Mar-28 11:22 Snoopy/Tools/print_format.py
--rw-rw-rw-  2.0 fat      546 b- defN 23-Mar-28 11:22 Snoopy/Tools/string_tools.py
--rw-rw-rw-  2.0 fat     1313 b- defN 23-Mar-28 11:22 Snoopy/Tools/timeout.py
--rw-rw-rw-  2.0 fat      354 b- defN 23-Mar-28 11:22 Snoopy/WaveKinematic/__init__.py
--rw-rw-rw-  2.0 fat     2862 b- defN 23-Mar-28 11:22 Snoopy/WaveKinematic/bathymetry_utils.py
--rw-rw-rw-  2.0 fat    34878 b- defN 23-Mar-28 11:22 Snoopy/WaveKinematic/variableBathymetry.py
--rw-rw-rw-  2.0 fat     9008 b- defN 23-Mar-28 11:22 Snoopy/WaveKinematic/waveKinematic.py
--rw-rw-rw-  2.0 fat    33803 b- defN 23-Apr-17 10:45 snoopy_bv-2.0.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     2797 b- defN 23-Apr-17 10:45 snoopy_bv-2.0.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-17 10:45 snoopy_bv-2.0.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-17 10:45 snoopy_bv-2.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    13075 b- defN 23-Apr-17 10:45 snoopy_bv-2.0.1.dist-info/RECORD
-150 files, 13973979 bytes uncompressed, 4411817 bytes compressed:  68.4%
+Zip file size: 4646077 bytes, number of entries: 164
+-rw-rw-rw-  2.0 fat     2816 b- defN 23-May-05 16:07 Snoopy/__init__.py
+-rw-rw-rw-  2.0 fat      119 b- defN 23-May-26 11:10 Snoopy/version.py
+-rw-rw-rw-  2.0 fat   157696 b- defN 23-May-26 11:19 Snoopy/DLLs/DspFilters.dll
+-rw-rw-rw-  2.0 fat    45568 b- defN 23-May-26 11:19 Snoopy/DLLs/FiniteDifference.dll
+-rw-rw-rw-  2.0 fat   841216 b- defN 23-May-26 11:19 Snoopy/DLLs/Geometry.dll
+-rw-rw-rw-  2.0 fat   221184 b- defN 23-May-26 11:19 Snoopy/DLLs/Integration.dll
+-rw-rw-rw-  2.0 fat    73728 b- defN 23-May-26 11:19 Snoopy/DLLs/MathTools.dll
+-rw-rw-rw-  2.0 fat    59904 b- defN 23-May-26 11:19 Snoopy/DLLs/Mechanics.dll
+-rw-rw-rw-  2.0 fat   705536 b- defN 23-May-26 11:19 Snoopy/DLLs/Meshing.dll
+-rw-rw-rw-  2.0 fat    38400 b- defN 23-May-26 11:19 Snoopy/DLLs/Solvers.dll
+-rw-rw-rw-  2.0 fat  1307136 b- defN 23-May-26 11:19 Snoopy/DLLs/Spectral.dll
+-rw-rw-rw-  2.0 fat   121344 b- defN 23-May-26 11:19 Snoopy/DLLs/Statistics.dll
+-rw-rw-rw-  2.0 fat   356864 b- defN 23-May-26 11:19 Snoopy/DLLs/TimeDomain.dll
+-rw-rw-rw-  2.0 fat   127488 b- defN 23-May-26 11:19 Snoopy/DLLs/WaveKinematic.dll
+-rw-rw-rw-  2.0 fat  2786304 b- defN 23-May-26 11:19 Snoopy/DLLs/_Geometry.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  2176512 b- defN 23-May-26 11:19 Snoopy/DLLs/_Math.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   925696 b- defN 23-May-26 11:19 Snoopy/DLLs/_Mechanics.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   636928 b- defN 23-May-26 11:19 Snoopy/DLLs/_Meshing.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  1524736 b- defN 23-May-26 11:19 Snoopy/DLLs/_Spectral.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   518144 b- defN 23-May-26 11:19 Snoopy/DLLs/_Statistics.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   668672 b- defN 23-May-26 11:19 Snoopy/DLLs/_TimeDomain.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   587776 b- defN 23-May-26 11:19 Snoopy/DLLs/_WaveKinematic.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     6915 b- defN 23-May-05 16:07 Snoopy/Dataset/__init__.py
+-rw-rw-rw-  2.0 fat     1419 b- defN 23-May-05 16:07 Snoopy/Dataset/rec34_rev2.csv
+-rw-rw-rw-  2.0 fat      197 b- defN 23-May-05 16:07 Snoopy/Fatigue/__init__.py
+-rw-rw-rw-  2.0 fat     4922 b- defN 23-May-05 16:07 Snoopy/Fatigue/rainflow.py
+-rw-rw-rw-  2.0 fat    15472 b- defN 23-May-05 16:07 Snoopy/Fatigue/sn_curve.py
+-rw-rw-rw-  2.0 fat    11379 b- defN 23-May-05 16:07 Snoopy/Geometry/__init__.py
+-rw-rw-rw-  2.0 fat     1835 b- defN 23-May-05 16:07 Snoopy/Geometry/sx3Manipulation.py
+-rw-rw-rw-  2.0 fat     9248 b- defN 23-May-05 16:07 Snoopy/Math/Functions.py
+-rw-rw-rw-  2.0 fat     2777 b- defN 23-May-05 16:07 Snoopy/Math/_HLCL.py
+-rw-rw-rw-  2.0 fat     4795 b- defN 23-May-05 16:07 Snoopy/Math/_MHLGA.py
+-rw-rw-rw-  2.0 fat      469 b- defN 23-May-05 16:07 Snoopy/Math/__init__.py
+-rw-rw-rw-  2.0 fat     3694 b- defN 23-May-05 16:07 Snoopy/Math/cmplxInterp.py
+-rw-rw-rw-  2.0 fat     4436 b- defN 23-May-05 16:07 Snoopy/Math/interpolate.py
+-rw-rw-rw-  2.0 fat     2244 b- defN 23-May-05 16:07 Snoopy/Math/iso_contour.py
+-rw-rw-rw-  2.0 fat     1737 b- defN 23-May-05 16:07 Snoopy/Math/numerical_jacobian.py
+-rw-rw-rw-  2.0 fat     2353 b- defN 23-May-05 16:07 Snoopy/Math/numpy_related.py
+-rw-rw-rw-  2.0 fat     2450 b- defN 23-May-05 16:07 Snoopy/Mechanics/ReferenceFrameTools.py
+-rw-rw-rw-  2.0 fat     5520 b- defN 23-May-25 14:05 Snoopy/Mechanics/__init__.py
+-rw-rw-rw-  2.0 fat    19984 b- defN 23-May-11 18:18 Snoopy/Mechanics/hydro_coef.py
+-rw-rw-rw-  2.0 fat     3936 b- defN 23-May-05 16:07 Snoopy/Mechanics/hydro_coef_io.py
+-rw-rw-rw-  2.0 fat     2775 b- defN 23-May-05 16:07 Snoopy/Mechanics/hydro_data.csv
+-rw-rw-rw-  2.0 fat    16783 b- defN 23-May-25 14:05 Snoopy/Mechanics/internal_load.py
+-rw-rw-rw-  2.0 fat    52041 b- defN 23-May-05 16:07 Snoopy/Mechanics/mass_distribution.py
+-rw-rw-rw-  2.0 fat    20043 b- defN 23-May-05 16:07 Snoopy/Mechanics/mass_section.py
+-rw-rw-rw-  2.0 fat     3920 b- defN 23-May-05 16:07 Snoopy/Mechanics/matrans.py
+-rw-rw-rw-  2.0 fat    16016 b- defN 23-May-25 14:05 Snoopy/Mechanics/mechanicalsolver.py
+-rw-rw-rw-  2.0 fat     3928 b- defN 23-May-05 16:07 Snoopy/Meshing/FreeSurfaceMesher.py
+-rw-rw-rw-  2.0 fat      266 b- defN 23-May-05 16:07 Snoopy/Meshing/__init__.py
+-rw-rw-rw-  2.0 fat    11918 b- defN 23-May-05 16:07 Snoopy/Meshing/balance.py
+-rw-rw-rw-  2.0 fat      425 b- defN 23-May-05 16:07 Snoopy/Meshing/hsbln.py
+-rw-rw-rw-  2.0 fat     8516 b- defN 23-May-05 16:07 Snoopy/Meshing/hydroStarMesh.py
+-rw-rw-rw-  2.0 fat     1590 b- defN 23-May-05 16:07 Snoopy/Meshing/hydro_names.py
+-rw-rw-rw-  2.0 fat    46330 b- defN 23-May-25 14:05 Snoopy/Meshing/mesh.py
+-rw-rw-rw-  2.0 fat     5724 b- defN 23-May-16 17:17 Snoopy/Meshing/mesh_io.py
+-rw-rw-rw-  2.0 fat     1006 b- defN 23-May-05 16:07 Snoopy/Meshing/structuredGrid.py
+-rw-rw-rw-  2.0 fat     9171 b- defN 23-May-05 16:07 Snoopy/Meshing/vtkTools.py
+-rw-rw-rw-  2.0 fat     3488 b- defN 23-May-05 16:07 Snoopy/Meshing/vtkView.py
+-rw-rw-rw-  2.0 fat     7714 b- defN 23-May-05 16:07 Snoopy/Meshing/waterline.py
+-rw-rw-rw-  2.0 fat     1192 b- defN 23-May-05 16:07 Snoopy/PyplotTools/__init__.py
+-rw-rw-rw-  2.0 fat     5845 b- defN 23-May-05 16:07 Snoopy/PyplotTools/_scatterPlot.py
+-rw-rw-rw-  2.0 fat     1808 b- defN 23-May-05 16:07 Snoopy/PyplotTools/addScale.py
+-rw-rw-rw-  2.0 fat     2199 b- defN 23-May-05 16:07 Snoopy/PyplotTools/addcopyfighandler.py
+-rw-rw-rw-  2.0 fat     5464 b- defN 23-May-05 16:07 Snoopy/PyplotTools/customScale.py
+-rw-rw-rw-  2.0 fat    14973 b- defN 23-May-05 16:07 Snoopy/PyplotTools/dfPlot.py
+-rw-rw-rw-  2.0 fat    19002 b- defN 23-May-05 16:07 Snoopy/PyplotTools/geoMap.py
+-rw-rw-rw-  2.0 fat     1485 b- defN 23-May-05 16:07 Snoopy/PyplotTools/gnuplot_compat.py
+-rw-rw-rw-  2.0 fat      573 b- defN 23-May-05 16:07 Snoopy/PyplotTools/meshPlot.py
+-rw-rw-rw-  2.0 fat     8396 b- defN 23-May-05 16:07 Snoopy/PyplotTools/misc.py
+-rw-rw-rw-  2.0 fat     2669 b- defN 23-May-05 16:07 Snoopy/PyplotTools/mplZoom.py
+-rw-rw-rw-  2.0 fat      202 b- defN 23-May-05 16:07 Snoopy/PyplotTools/snoopy.mplstyle
+-rw-rw-rw-  2.0 fat    12986 b- defN 23-May-05 16:07 Snoopy/PyplotTools/statPlots.py
+-rw-rw-rw-  2.0 fat     2475 b- defN 23-May-05 16:07 Snoopy/PyplotTools/surfacePlot.py
+-rw-rw-rw-  2.0 fat      621 b- defN 23-May-05 16:07 Snoopy/PyplotTools/vtkLUT.py
+-rw-rw-rw-  2.0 fat     2599 b- defN 23-May-05 16:07 Snoopy/Reader/OperaH5Reader.py
+-rw-rw-rw-  2.0 fat     2946 b- defN 23-May-05 16:07 Snoopy/Reader/__init__.py
+-rw-rw-rw-  2.0 fat     1964 b- defN 23-May-05 16:07 Snoopy/Reader/arianeReader.py
+-rw-rw-rw-  2.0 fat     2484 b- defN 23-May-05 16:07 Snoopy/Reader/bvFormat.py
+-rw-rw-rw-  2.0 fat     2772 b- defN 23-May-05 16:07 Snoopy/Reader/bvHdf5.py
+-rw-rw-rw-  2.0 fat     6238 b- defN 23-May-05 16:07 Snoopy/Reader/donFormat.py
+-rw-rw-rw-  2.0 fat    12509 b- defN 23-May-05 16:07 Snoopy/Reader/dynProbeReader.py
+-rw-rw-rw-  2.0 fat     6613 b- defN 23-May-05 16:07 Snoopy/Reader/hydrostar.py
+-rw-rw-rw-  2.0 fat    10243 b- defN 23-May-05 16:07 Snoopy/Reader/hydrostar_v.py
+-rw-rw-rw-  2.0 fat     8985 b- defN 23-May-05 16:07 Snoopy/Reader/input_mcn_parser.py
+-rw-rw-rw-  2.0 fat      809 b- defN 23-May-05 16:07 Snoopy/Reader/json_tools.py
+-rw-rw-rw-  2.0 fat    16360 b- defN 23-May-05 16:07 Snoopy/Reader/openFoam.py
+-rw-rw-rw-  2.0 fat     3061 b- defN 23-May-05 16:07 Snoopy/Reader/readInput.py
+-rw-rw-rw-  2.0 fat      651 b- defN 23-May-05 16:07 Snoopy/Reader/read_csv_block.py
+-rw-rw-rw-  2.0 fat     1057 b- defN 23-May-05 16:07 Snoopy/Reader/simpleReader.py
+-rw-rw-rw-  2.0 fat     7632 b- defN 23-May-05 16:07 Snoopy/Reader/starspec.py
+-rw-rw-rw-  2.0 fat     2571 b- defN 23-May-05 16:07 Snoopy/Reader/tecplot.py
+-rw-rw-rw-  2.0 fat     6586 b- defN 23-May-05 16:07 Snoopy/Spectral/Qtf_class.py
+-rw-rw-rw-  2.0 fat     1566 b- defN 23-May-05 16:07 Snoopy/Spectral/__init__.py
+-rw-rw-rw-  2.0 fat     8228 b- defN 23-May-05 16:07 Snoopy/Spectral/dampingLinearization.py
+-rw-rw-rw-  2.0 fat     7098 b- defN 23-May-05 16:07 Snoopy/Spectral/dispersion.py
+-rw-rw-rw-  2.0 fat    12731 b- defN 23-May-26 11:10 Snoopy/Spectral/edw.py
+-rw-rw-rw-  2.0 fat     2036 b- defN 23-May-05 16:07 Snoopy/Spectral/enc_freq.py
+-rw-rw-rw-  2.0 fat     9159 b- defN 23-May-05 16:07 Snoopy/Spectral/headingConvention.py
+-rw-rw-rw-  2.0 fat    11375 b- defN 23-May-05 16:07 Snoopy/Spectral/linearize_and_match.py
+-rw-rw-rw-  2.0 fat     6522 b- defN 23-May-05 16:07 Snoopy/Spectral/misc.py
+-rw-rw-rw-  2.0 fat    23093 b- defN 23-May-05 16:07 Snoopy/Spectral/mqtf.py
+-rw-rw-rw-  2.0 fat    26483 b- defN 23-May-16 09:10 Snoopy/Spectral/qtf.py
+-rw-rw-rw-  2.0 fat    56570 b- defN 23-May-15 11:09 Snoopy/Spectral/rao.py
+-rw-rw-rw-  2.0 fat     4748 b- defN 23-May-05 16:07 Snoopy/Spectral/responseSpectrum.py
+-rw-rw-rw-  2.0 fat    15185 b- defN 23-May-05 16:07 Snoopy/Spectral/seaStateList.py
+-rw-rw-rw-  2.0 fat    51177 b- defN 23-May-05 16:07 Snoopy/Spectral/seastate.py
+-rw-rw-rw-  2.0 fat      417 b- defN 23-May-05 16:07 Snoopy/Spectral/spectralMoments.py
+-rw-rw-rw-  2.0 fat    17912 b- defN 23-May-25 14:05 Snoopy/Spectral/spectralStats.py
+-rw-rw-rw-  2.0 fat    19732 b- defN 23-May-05 16:07 Snoopy/Spectral/spectrum.py
+-rw-rw-rw-  2.0 fat     1255 b- defN 23-May-05 16:07 Snoopy/Spectral/spreading.py
+-rw-rw-rw-  2.0 fat     4922 b- defN 23-May-05 16:07 Snoopy/Spectral/waveMaker.py
+-rw-rw-rw-  2.0 fat     5798 b- defN 23-May-05 16:07 Snoopy/Spectral/wib.py
+-rw-rw-rw-  2.0 fat    26046 b- defN 23-May-15 11:09 Snoopy/Spectral/wif.py
+-rw-rw-rw-  2.0 fat     4535 b- defN 23-May-05 16:07 Snoopy/Spectral/wifm.py
+-rw-rw-rw-  2.0 fat     1084 b- defN 23-May-05 16:07 Snoopy/Statistics/__init__.py
+-rw-rw-rw-  2.0 fat    22279 b- defN 23-May-05 16:07 Snoopy/Statistics/_blockMaxima.py
+-rw-rw-rw-  2.0 fat    24386 b- defN 23-May-05 16:07 Snoopy/Statistics/_diform.py
+-rw-rw-rw-  2.0 fat     3259 b- defN 23-May-05 16:07 Snoopy/Statistics/_impact_velocity.py
+-rw-rw-rw-  2.0 fat    21298 b- defN 23-May-25 14:05 Snoopy/Statistics/_longTerm.py
+-rw-rw-rw-  2.0 fat    10049 b- defN 23-May-05 16:07 Snoopy/Statistics/_longTermSD.py
+-rw-rw-rw-  2.0 fat    26149 b- defN 23-May-05 16:07 Snoopy/Statistics/_pot.py
+-rw-rw-rw-  2.0 fat    16281 b- defN 23-May-05 16:07 Snoopy/Statistics/discreteSD.py
+-rw-rw-rw-  2.0 fat     7951 b- defN 23-May-05 16:07 Snoopy/Statistics/dist.py
+-rw-rw-rw-  2.0 fat     2671 b- defN 23-May-05 16:07 Snoopy/Statistics/distribution_cpp.py
+-rw-rw-rw-  2.0 fat      905 b- defN 23-May-05 16:07 Snoopy/Statistics/distribution_jitted.py
+-rw-rw-rw-  2.0 fat     3394 b- defN 23-May-05 16:07 Snoopy/Statistics/empirical_quantiles.py
+-rw-rw-rw-  2.0 fat      989 b- defN 23-May-05 16:07 Snoopy/Statistics/f_maxEntropy.py
+-rw-rw-rw-  2.0 fat     3637 b- defN 23-May-05 16:07 Snoopy/Statistics/longterm_rba.py
+-rw-rw-rw-  2.0 fat     5080 b- defN 23-May-05 16:07 Snoopy/Statistics/maxEntropySolver.py
+-rw-rw-rw-  2.0 fat     1371 b- defN 23-May-05 16:07 Snoopy/Statistics/powern.py
+-rw-rw-rw-  2.0 fat    21646 b- defN 23-May-05 16:07 Snoopy/Statistics/returnLevel.py
+-rw-rw-rw-  2.0 fat     3109 b- defN 23-May-05 16:07 Snoopy/Statistics/statErrors.py
+-rw-rw-rw-  2.0 fat    23835 b- defN 23-May-05 16:07 Snoopy/TimeDomain/TimeSignals.py
+-rw-rw-rw-  2.0 fat     1000 b- defN 23-May-05 16:07 Snoopy/TimeDomain/__init__.py
+-rw-rw-rw-  2.0 fat     4711 b- defN 23-May-05 16:07 Snoopy/TimeDomain/concat_time_series.py
+-rw-rw-rw-  2.0 fat    11955 b- defN 23-May-05 16:07 Snoopy/TimeDomain/decayTest.py
+-rw-rw-rw-  2.0 fat     9906 b- defN 23-May-05 16:07 Snoopy/TimeDomain/decluster.py
+-rw-rw-rw-  2.0 fat     2025 b- defN 23-May-05 16:07 Snoopy/TimeDomain/forcedOscillation.py
+-rw-rw-rw-  2.0 fat     4316 b- defN 23-May-05 16:07 Snoopy/TimeDomain/oneDof.py
+-rw-rw-rw-  2.0 fat     2312 b- defN 23-May-05 16:07 Snoopy/TimeDomain/radiation.py
+-rw-rw-rw-  2.0 fat     2629 b- defN 23-May-05 16:07 Snoopy/TimeDomain/reconstruction1st.py
+-rw-rw-rw-  2.0 fat     2691 b- defN 23-May-05 16:07 Snoopy/TimeDomain/reconstructionMulti.py
+-rw-rw-rw-  2.0 fat     1013 b- defN 23-May-05 16:07 Snoopy/TimeDomain/reconstructionQtf.py
+-rw-rw-rw-  2.0 fat     3447 b- defN 23-May-05 16:07 Snoopy/TimeDomain/reconstructionRaoFFT.py
+-rw-rw-rw-  2.0 fat     1754 b- defN 23-May-05 16:07 Snoopy/TimeDomain/slammingVelocity.py
+-rw-rw-rw-  2.0 fat     7877 b- defN 23-May-05 16:07 Snoopy/TimeDomain/srs.py
+-rw-rw-rw-  2.0 fat    13164 b- defN 23-May-05 16:07 Snoopy/TimeDomain/upCross.py
+-rw-rw-rw-  2.0 fat      216 b- defN 23-May-05 16:07 Snoopy/Tools/__init__.py
+-rw-rw-rw-  2.0 fat     5510 b- defN 23-May-05 16:07 Snoopy/Tools/_deprecated.py
+-rw-rw-rw-  2.0 fat      453 b- defN 23-May-05 16:07 Snoopy/Tools/callCounter.py
+-rw-rw-rw-  2.0 fat     1729 b- defN 23-May-05 16:07 Snoopy/Tools/logTimerFormatter.py
+-rw-rw-rw-  2.0 fat     1570 b- defN 23-May-25 14:05 Snoopy/Tools/print_format.py
+-rw-rw-rw-  2.0 fat      546 b- defN 23-May-05 16:07 Snoopy/Tools/string_tools.py
+-rw-rw-rw-  2.0 fat     1313 b- defN 23-May-05 16:07 Snoopy/Tools/timeout.py
+-rw-rw-rw-  2.0 fat      354 b- defN 23-May-05 16:07 Snoopy/WaveKinematic/__init__.py
+-rw-rw-rw-  2.0 fat     2862 b- defN 23-May-05 16:07 Snoopy/WaveKinematic/bathymetry_utils.py
+-rw-rw-rw-  2.0 fat    34878 b- defN 23-May-05 16:07 Snoopy/WaveKinematic/variableBathymetry.py
+-rw-rw-rw-  2.0 fat     9008 b- defN 23-May-05 16:07 Snoopy/WaveKinematic/waveKinematic.py
+-rw-rw-rw-  2.0 fat    33803 b- defN 23-May-26 11:20 snoopy_bv-2.0.2.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     2683 b- defN 23-May-26 11:20 snoopy_bv-2.0.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 23-May-26 11:20 snoopy_bv-2.0.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-May-26 11:19 snoopy_bv-2.0.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat    14269 b- defN 23-May-26 11:20 snoopy_bv-2.0.2.dist-info/RECORD
+164 files, 15071237 bytes uncompressed, 4623753 bytes compressed:  69.3%
```

## zipnote {}

```diff
@@ -1,40 +1,79 @@
 Filename: Snoopy/__init__.py
 Comment: 
 
 Filename: Snoopy/version.py
 Comment: 
 
-Filename: Snoopy/DLLs/_Geometry.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/DspFilters.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_Math.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/FiniteDifference.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_Mechanics.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/Geometry.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_Meshing.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/Integration.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_Spectral.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/MathTools.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_Statistics.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/Mechanics.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_TimeDomain.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/Meshing.dll
 Comment: 
 
-Filename: Snoopy/DLLs/_WaveKinematic.cp39-win_amd64.pyd
+Filename: Snoopy/DLLs/Solvers.dll
+Comment: 
+
+Filename: Snoopy/DLLs/Spectral.dll
+Comment: 
+
+Filename: Snoopy/DLLs/Statistics.dll
+Comment: 
+
+Filename: Snoopy/DLLs/TimeDomain.dll
+Comment: 
+
+Filename: Snoopy/DLLs/WaveKinematic.dll
+Comment: 
+
+Filename: Snoopy/DLLs/_Geometry.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_Math.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_Mechanics.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_Meshing.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_Spectral.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_Statistics.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_TimeDomain.cp311-win_amd64.pyd
+Comment: 
+
+Filename: Snoopy/DLLs/_WaveKinematic.cp311-win_amd64.pyd
 Comment: 
 
 Filename: Snoopy/Dataset/__init__.py
 Comment: 
 
+Filename: Snoopy/Dataset/rec34_rev2.csv
+Comment: 
+
 Filename: Snoopy/Fatigue/__init__.py
 Comment: 
 
 Filename: Snoopy/Fatigue/rainflow.py
 Comment: 
 
 Filename: Snoopy/Fatigue/sn_curve.py
@@ -81,14 +120,17 @@
 
 Filename: Snoopy/Mechanics/hydro_coef.py
 Comment: 
 
 Filename: Snoopy/Mechanics/hydro_coef_io.py
 Comment: 
 
+Filename: Snoopy/Mechanics/hydro_data.csv
+Comment: 
+
 Filename: Snoopy/Mechanics/internal_load.py
 Comment: 
 
 Filename: Snoopy/Mechanics/mass_distribution.py
 Comment: 
 
 Filename: Snoopy/Mechanics/mass_section.py
@@ -429,23 +471,23 @@
 
 Filename: Snoopy/WaveKinematic/variableBathymetry.py
 Comment: 
 
 Filename: Snoopy/WaveKinematic/waveKinematic.py
 Comment: 
 
-Filename: snoopy_bv-2.0.1.dist-info/LICENSE
+Filename: snoopy_bv-2.0.2.dist-info/LICENSE
 Comment: 
 
-Filename: snoopy_bv-2.0.1.dist-info/METADATA
+Filename: snoopy_bv-2.0.2.dist-info/METADATA
 Comment: 
 
-Filename: snoopy_bv-2.0.1.dist-info/WHEEL
+Filename: snoopy_bv-2.0.2.dist-info/WHEEL
 Comment: 
 
-Filename: snoopy_bv-2.0.1.dist-info/top_level.txt
+Filename: snoopy_bv-2.0.2.dist-info/top_level.txt
 Comment: 
 
-Filename: snoopy_bv-2.0.1.dist-info/RECORD
+Filename: snoopy_bv-2.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Snoopy/version.py

```diff
@@ -1,5 +1,5 @@
 #Tags with hash (if version is not exactly the hash)
-snoopy_tag = "v2.0.1-1-g36cdac21"
+snoopy_tag = "v2.0.2"
 
 #Tags only
-snoopy_tag_only = "v2.0.1"
+snoopy_tag_only = "v2.0.2"
```

## Snoopy/Math/Functions.py

```diff
@@ -229,15 +229,21 @@
     def getSerializable(self):
         return {'type': self.__class__.__name__,
                 'arguments': self._constructionArgs,
                 'execCode': self._execCode,
                 'functors': self._functors}
 
     def __repr__(self):
-        return ' '.join(map(str, self._constructionArgs))
+        return self.__class__.__name__[6:] + ', ' + ', '.join(map(str, self._constructionArgs))
+
+    def __str__(self):
+        name = self.__class__.__name__[6:]
+        if name != 'Uniform':
+            return name + ', ' + ', '.join(map(str, self._constructionArgs))
+        return ', '.join(map(str, self._constructionArgs))
 
 
 for attr in [a for a in dir(_Functions) if a.startswith('R')]:
     globals()[attr] = type(attr, (_DecoratorFunction,
                                   getattr(_Functions, attr)), {})
 
 for attr in [a for a in dir(_Functions) if a.startswith('_R')]:
```

## Snoopy/Mechanics/__init__.py

```diff
@@ -12,15 +12,15 @@
 from .matrans import matrans3, matrans_freq_head, vectran_freq_head, vectran3
 import xarray as xa
 
 g = 9.81
 
 from .hydro_coef import RdfCoef, McnInput, HydroCoef, McnCoef
 from .internal_load import InternalLoad, get_from_pressure_integration
-from .mechanicalsolver import MechanicalSolver
+from .mechanicalsolver import MechanicalSolver, get_gravity_stiffness
 
 
     
 # Redirection
 Torsor = _Mechanics._Torsor
 #KinematicTorsor = _Mechanics._KinematicTorsor
 #StaticTorsor = _Mechanics._StaticTorsor
```

## Snoopy/Mechanics/hydro_coef.py

```diff
@@ -120,45 +120,49 @@
         -------
         Dataset
             The moved dataset
         """
         if self.nbbody > 1:
             raise NotImplementedError("This function can't be used to change refpoint of multibody system!")
         
-        ds = self._data.copy(True) #To be sure that original dataset is not modified. 
         
-        old_ref_point = ds.ref_point[0,:]
-        
-        logger.debug("Changing ref_point")
-        
-        for var in self.content_df.query( "TRANS in ['load_vector', 'motion_vector' , 'matrix' ]").index.values:
-            if var in ds.data_vars : 
-                kind = self.content_df.loc[var, "TRANS"]
-                isMotion = "motion" in kind
-                logger.debug(f"            -> {var:} {isMotion:}")
-                
-                trans_dims = TransDims( self._data[var].dims )
-                # da = ds[var].transpose( *trans_dims.ordered_dims )
-
-                # Stack all dimension 
-                da = ds[var].stack( all_but_mode = trans_dims.other_dims )
-                
-                if kind == "matrix" : 
-                    for i in range(da.shape[-1]) :
-                        da.values[:,:,i] = matrans3(da.values[:,:,i], origin = old_ref_point, destination = ref_point)
-                elif "vector" in kind :
-                    for i in range(da.shape[-1]) :
-                        da.values[:,i] = vectran3(da.values[:,i], origin = old_ref_point, destination = ref_point, isMotion = isMotion)
+        old_ref_point = self._data.ref_point[0,:].values
+        new_ref_point = np.asarray(ref_point).reshape(3,)
+        if np.allclose(old_ref_point,new_ref_point):
+            return self._data
+        else:
+            ds = self._data.copy(True) #To be sure that original dataset is not modified. 
+            logger.debug(f"Changing ref_point from {old_ref_point} to {new_ref_point}")
+            for var in self.content_df.query( "TRANS in ['load_vector', 'motion_vector' , 'matrix' ]").index.values:
+                if var in ds.data_vars : 
+                    kind = self.content_df.loc[var, "TRANS"]
+                    isMotion = "motion" in kind
+                    logger.debug(f"            -> {var:} {isMotion:}")
+                    
+                    trans_dims = TransDims( self._data[var].dims )
+                    # da = ds[var].transpose( *trans_dims.ordered_dims )
+
+                    # Stack all dimension 
+                    da = ds[var].stack( all_but_mode = trans_dims.other_dims )
+                    
+                    if kind == "matrix" : 
+                        for i in range(da.shape[-1]) :
+                            da.values[:,:,i] = matrans3(da.values[:,:,i], origin = old_ref_point, 
+                                                        destination = new_ref_point)
+                    elif "vector" in kind :
+                        for i in range(da.shape[-1]) :
+                            da.values[:,i] = vectran3(  da.values[:,i], origin = old_ref_point, 
+                                                        destination = new_ref_point, isMotion = isMotion)
 
-                # Unstack
-                ds[var] = da.unstack().transpose( *trans_dims.original_dims )
+                    # Unstack
+                    ds[var] = da.unstack().transpose( *trans_dims.original_dims )
 
-        ds["ref_point"].values[0,:] = ref_point
+            ds["ref_point"].values[0,:] = ref_point
 
-        return ds
+            return ds
 
 
     def get_at_ref_wave(self, ref_wave):
         # TODO: implement phase shift when set to new wave reference point.
         raise NotImplementedError("Setting a new value for ref_wave is not yet implemented!")
```

## Snoopy/Mechanics/internal_load.py

```diff
@@ -56,15 +56,15 @@
     
     if "baseFlowStiffness_integrant" in panelsMetaData.data_name.values:
         returnDict["base_flow_stiffness"] = \
             get_baseFlowStiffness_scaled_from_SnoopyMesh(pressure_mesh, rho, speed)[np.newaxis, ...]
         
         
     
-    hydrostatic_hull = pressure_mesh.integrate_stiffness_matrix(ref_frame = "hydro", output_ref_point = output_ref_point)
+    hydrostatic_hull = pressure_mesh.integrate_stiffness_matrix(ref_frame = "hydro", output_ref_point = output_ref_point, buoyancy_stiffness = False)
     returnDict["hydrostatic_hull"] = (hydrostatic_hull* rho*g)[np.newaxis, ...]
 
 
     encounter_frequency = np.zeros((nb_heading,nb_frequency),dtype = float)
     for ihead,head in enumerate(all_heading):
         for ifreq,freq in enumerate(all_freq):
             encounter_frequency[ihead, ifreq] = w2we( w = freq, speed=speed, b=head*np.pi / 180., depth=depth )
@@ -346,28 +346,32 @@
         IDs = []
         section_points = []
         for s in self.allsections.sectionlist:
             IDs.append(s.ID)
             section_points.append(s.section_point)
         section_points = np.array(section_points)
         #IDs = np.array(IDs)
-        heading = self._rdf_coef.heading 
-        frequency = self._rdf_coef.frequency
-        mode = self._rdf_coef.mode
-
+        rdf_coef = self._rdf_coef
+        heading = rdf_coef.heading 
+        frequency = rdf_coef.frequency
+        mode = rdf_coef.mode
+        attrs = rdf_coef.attrs
+        ref_wave = rdf_coef.ref_wave
+        attrs["ref_wave_X"] = ref_wave[0]
+        attrs["ref_wave_Y"] = ref_wave[0]
 
         return xa.Dataset(
             data_vars = {"internal_loads": (["ID","heading","frequency","mode"],self.internal_loads[...]),
                          "section_points": (["ID","xyz"], section_points) },
             coords    = {"ID"       : ("ID"        , IDs),
                          "xyz"      : ("xyz",  ["x","y","z"]),
                          "heading"  : heading,  
                          "frequency": frequency,
                          "mode"     : mode },
-            attrs     = self._rdf_coef.attrs) 
+            attrs     = attrs) 
 
 
         
 
     def get_motion_da(self) :
         """Return motion as xarray.DataArray
         """
```

## Snoopy/Mechanics/mechanicalsolver.py

```diff
@@ -140,16 +140,23 @@
         gravity_stiffness[0,4] = -1.0
         gravity_stiffness[1,3] = +1.0
         gravity_stiffness[3,3] = +GQ[2]
         gravity_stiffness[4,4] = +GQ[2]
 
         gravity_stiffness[5,3] = -GQ[0]
         gravity_stiffness[5,4] = -GQ[1]  # Signed opposed to the one in HydroStar++. 
+    elif ref_frame == "hydro": 
+        gravity_stiffness[3,3] = +GQ[2]
+        gravity_stiffness[4,4] = +GQ[2]
+
+        gravity_stiffness[3,5] = -GQ[0]
+        gravity_stiffness[4,5] = -GQ[1]
     else : 
         raise(Exception())
+
     return gravity_stiffness * mass * 9.81
     
 
 
 class MechanicalSolver :
 
     def __init__(self, mcn_input_obj, rdf_coef_obj):
@@ -226,29 +233,29 @@
         mass_matrix = mcn_input_obj_sel.mass_matrix.data
         
         gravity_stiffness = np.zeros((6,6), dtype='float64')
         if ref_frame == "hydro" : 
 
             hydrostatic_hull    = rdf_coef_obj_sel.hydrostatic_hull.data 
 
-            # Term not in hydrostatic_hull
+            # Term not in hydrostatic_hull from hydrostar... 
             volume = mass
-            add_stiff = np.zeros((6,6), dtype='float64')
-            add_stiff[3,3] = (rdf_coef_obj.cob[0,2] - ref_point[2] ) * volume * g
-            add_stiff[4,4] = (rdf_coef_obj.cob[0,2] - ref_point[2] ) * volume * g
+            buoyancy_stiffness = np.zeros((6,6), dtype='float64')
+            buoyancy_stiffness[3,3] = (rdf_coef_obj.cob[0,2] - ref_point[2] ) * volume * g
+            buoyancy_stiffness[4,4] = (rdf_coef_obj.cob[0,2] - ref_point[2] ) * volume * g
 
             # Add gravity stiffness
             gravity_stiffness[3,3] = ref_point[2] - cog_point[2] 
-            gravity_stiffness[4,4] = ref_point[2] - cog_point[2] 
-            # gravity_stiffness[3,5] = +cog_point[0] - ref_point[0]  # term balancing this are not in hydrostatic_hull
-            # gravity_stiffness[4,5] = +cog_point[1] - ref_point[1]  # term balancing this are not in hydrostatic_hull
+            gravity_stiffness[4,4] = ref_point[2] - cog_point[2]
             gravity_stiffness = gravity_stiffness * mass * g
+            
+            # Body is assumed in equilibrium at rest, so that buoyancy_stiffness and gravity_stiffness compensate each other for terms [3,5] and [4,5].
 
             # Total hydrostatic stiffness
-            hydrostatic = hydrostatic_hull + gravity_stiffness + add_stiff
+            hydrostatic = hydrostatic_hull + gravity_stiffness + buoyancy_stiffness
 
         elif ref_frame == "body-fixed" :
             hydrostatic_hull_bf = rdf_coef_obj_sel.hydrostatic_hull_bf.data[:,:]
             gravity_stiffness = get_gravity_stiffness( mass, cog_point , ref_point , ref_frame  )
             hydrostatic = hydrostatic_hull_bf + gravity_stiffness
         else : 
             raise ValueError(f"Unavailable ref_frame {ref_frame}. Please choose between body-fixed or hydro.")
```

## Snoopy/Meshing/mesh.py

```diff
@@ -43,14 +43,47 @@
                     {"frequency"    : self.getDataFreqs(),
                      "heading"      : self.getDataHeads(),
                      "data_name"    : self.getDataNames(),
                      "data_type"    : self.getDataTypes()})
 
 
 
+    def appendPanelsData(self , data, dataName, dataType = 0, dataFreq= np.nan, dataHead = np.nan) :
+        """Append panel data, inplace
+        
+        Parameters
+        ----------
+        data : np.ndarray
+            The data to add  (n_panels)
+        dataName : str 
+            Name of the field
+        dataType : TYPE, optional
+            DESCRIPTION. The default is 0.
+        dataFreq : TYPE, optional
+            DESCRIPTION. The default is np.nan.
+        dataHead : TYPE, optional
+            DESCRIPTION. The default is np.nan.
+        """
+        
+        if len(self.getDataNames()) == 0 :
+            self.setPanelsData( panelsData = data[: , np.newaxis] ,
+                                dataNames = [dataName],
+                                dataTypes = [dataType],
+                                dataFreqs = [dataFreq],
+                                dataHeads = [dataHead],
+                              )
+        else : 
+            self.setPanelsData( panelsData = np.append(  self.getPanelsData() , data[: , np.newaxis], axis = 1 ) ,
+                                dataNames = self.getDataNames() + [dataName],
+                                dataTypes = np.append( self.getDataTypes() , dataType),
+                                dataFreqs = np.append( self.getDataFreqs() , dataFreq),
+                                dataHeads = np.append( self.getDataHeads() , dataHead),
+                               )
+
+
     def get_radiation_coef(self):
         return self.integrate_fields_xarray("PRESSURE_RAD",
                                             dimension   = ["heading" , "frequency","mode_j"])
 
     def get_excitation_force(self):
         all_data_names = self.getDataNames()
         if "PRESSURE_EXC" in  all_data_names:
@@ -201,134 +234,251 @@
         if nbGP is not None :
             self.refreshGaussPoints(nbGP)
         normals = self.getNormalsAtGaussPoints()
         weight = self.getGaussWiWjdetJ()
         return -np.sum(normals[:,2] * weight)
     
     
-    def integrate_stiffness_matrix(self , output_ref_point,  
-                                    ref_frame = "body-fixed",
-                                    is_hull_closed = True,
-                                    is_hydrostatic_equilibrium = False):
-        """Integrate hydrostatic stiffness matrix.
-        
+    def integrate_stiffness_matrix(self , output_ref_point,
+                                   ref_frame = "body-fixed",
+                                   hull_stiffness = True, 
+                                   buoyancy_stiffness = True, 
+                                   rho_g = None):
+        r"""Integrate hydrostatic stiffness matrix (pressure part).
+
         Parameters
         ----------
         output_ref_point : np.ndarray (3).
             Reference point.
-            
+
         ref_frame : str
             "body-fixed" (translate and rotate with the ship), or "hydro" (only translate with the ship)
-        
-        is_hull_closed : bool, optional
-            use the fact that hull is closed, to analytically remove some terms. The default is False.
-
-        is_hydrostatic_equilibrium : bool
-            If True, terms that will be balanced by gravity stiffness are removed. ([3,5] , [4,5])
-
+            
+        hull_stiffness : True, optional
+            If true (only relevant for ref_frame == 'hydro'), the hull_stiffness part is included.
+            
+        buoyancy_stiffness : True, optional
+            If true (only relevant for ref_frame == 'hydro'), the buyancy_stiffness part is included.
+            
+        rho_g : float or None, optional
+            Water density * multiplied with gravity, default to None
+            
         Returns
         -------
         np.ndarray(6,6)
-            Hydrostatic stiffness matrix (pressure part only).
+            Hydrostatic stiffness matrix (without gravity stiffness, which would need mass properties).
+
+        Note
+        ----
+        When in hydrodynamic reference frame, the buoyancy stiffness cannot be transfered to another reference point (i.e. mcn.matrans3 must not be used).
+        
+        Formulas (hydrodynamic reference frame)
+        ---------------------------------------
+        
+        Matrix expressed at a reference point R (x_r, y_r, z_r).
+        
+        .. list-table:: Hull stiffness (in hydrodynamic reference frame)
+            :widths: 40 40 40 40 40 40
+            :header-rows: 0
+        
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - .. math:: \rho g \int\int n_3 dS
+              - .. math:: \rho g \int\int (y-y_r) n_3 dS
+              - .. math:: \rho g \int\int (x-x_r) n_3 dS
+              - 0
+            * - 0
+              - 0
+              - .. math:: \rho g \int\int (y-y_r) n_3 dS
+              - .. math:: \rho g \int\int (y-y_r)^2  n_3 dS
+              - .. math:: \rho g \int\int (x-x_r)*(y-y_r) n_3 dS
+              - 0
+            * - 0
+              - 0
+              - .. math:: \rho g \int\int (x-x_r) n_3 dS
+              - .. math:: \rho g \int\int (x-x_r)*(y-y_r) n_3 dS
+              - .. math:: \rho g \int\int (x-x_r)**2 n_3 dS
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+        
+        
+        
+        .. list-table:: Buoyancy stiffness  (in hydrodynamic reference frame)
+            :widths: 40 40 40 40 40 40
+            :header-rows: 0
+        
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - .. math:: \rho g V * (z_b-z_r)
+              - 0
+              - .. math:: -\rho g V * (x_b-x_r)
+            * - 0
+              - 0
+              - 0
+              - 0
+              - .. math:: \rho g V * (z_b-z_r)
+              - .. math:: -\rho g V * (y_b-y_r)
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+        
+        
+        
+        .. list-table:: Gravity stiffness  (in hydrodynamic reference frame), for reference (implementation in Snoopy.Mechanics.MechanicalSolver.get_gravity_stiffness)
+            :widths: 40 40 40 40 40 40
+            :header-rows: 0
+        
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+            * - 0
+              - 0
+              - 0
+              - .. math:: -mg(z_g-z_r)
+              - 0
+              - .. math:: mg(x_g-x_r)
+            * - 0
+              - 0
+              - 0
+              - 0
+              - .. math:: -mg(z_g-z_r)
+              - .. math:: mg(y_g-y_r)
+            * - 0
+              - 0
+              - 0
+              - 0
+              - 0
+              - 0
+
+        Formulas (body-fixed reference frame)
+        -------------------------------------
+        ...
         """
         from Snoopy import Mechanics as mcn
         
         if self.nbpanels == 0:
             # Empty mesh, return zeros
+            logger.debug("Mesh is empty, cannot integrate hydrostatic.")
             return np.zeros((6,6),dtype=float)
         
         normal_ref_point = self.getRefPoint()
                 
         res = np.zeros( (6,6), dtype = float )
 
         normalsAtGaussPoints    = self.getNormalsAtGaussPoints()
         weight                  = self.getGaussWiWjdetJ()
         gaussPoints             = self.getGaussPoints()
-        axoi =  ( gaussPoints[:,0]  - normal_ref_point[0] )
-        ayoi =  ( gaussPoints[:,1]  - normal_ref_point[1] )
-            
-        for i in range(6):
-            res[i,2] -= np.sum( weight *  normalsAtGaussPoints[:,i] )
-            res[i,3] -= np.sum( ayoi*weight *  normalsAtGaussPoints[:,i] )
-            res[i,4] = np.sum( axoi*weight *  normalsAtGaussPoints[:,i] )
-        if ref_frame == "body-fixed" : 
-            return mcn.matrans3(res, origin = normal_ref_point, destination= output_ref_point)
-
-        elif ref_frame == "hydro" :  
 
-            if is_hull_closed:  # If hull is closed, some terms should be 0.0
-                list_mode =  [2,3,4]
-                # Motion z_1, force Fx = Fy = 0, moment Mz = 0
-                logger.debug(f'Term 0,2 and 1,2 and 5,2 should be zero: {res[0,2]} , {res[1,2]} and  {res[5,2]}')
-                res[0,2] = 0.
-                res[1,2] = 0.
-                res[5,2] = 0.
-
-                # Motion theta_x, Fx =  0, M_y = 0
-                logger.debug(f'Term 0-3 and 4-3 should be zero: {res[0,3]} and {res[4,3]}')
-                res[0,3] = 0.
-                res[4,3] = 0
+        if ref_frame == "body-fixed" : 
+            axoi =  ( gaussPoints[:,0]  - normal_ref_point[0] )
+            ayoi =  ( gaussPoints[:,1]  - normal_ref_point[1] )
+            for i in range(6):
+                res[i,2] -= np.sum( weight *  normalsAtGaussPoints[:,i] )
+                res[i,3] -= np.sum( ayoi*weight *  normalsAtGaussPoints[:,i] )
+                res[i,4] = np.sum( axoi*weight *  normalsAtGaussPoints[:,i] )
                 
-                # Motion theta_y, Fy  = 0, M_x = 0
-                logger.debug(f'Term 1-4 and 3-4 should be zero: {res[1,4]} and {res[3,4]}')
-
-                res[1,4] = 0.
-                res[3,4] = 0.
-            else:
-                list_mode = range(6)
+            res = mcn.matrans3(res, origin = normal_ref_point, destination= output_ref_point)
 
-            # Need to add another term because of rotating frame
-            res2 = np.zeros( (6,6), dtype = float )                
-            vec = np.zeros( (6,), dtype = float )
-
-            for i in list_mode:
-                vec[i] = -np.sum( gaussPoints[:,2]*weight *  normalsAtGaussPoints[:,i] ) 
-            def _vect_to_mat(vec):
-                mat = np.zeros((3,3), dtype = vec.dtype)
-                mat[0,1] = vec[2]
-                mat[0,2] = - vec[1]
-                mat[1,0] = - vec[2]
-                mat[1,2] = vec[0]
-                mat[2,0] = vec[1]
-                mat[2,1] = -vec[0]
-                return mat
-
-            res2[:3,3:] = _vect_to_mat(vec[:3])
-            res2[3:,3:] = _vect_to_mat(vec[3:])
-
-            res_total = res + res2
-
-            if is_hull_closed:
-                logger.debug(f'Balance in hydrostatic in body-fixed reference frame of term 1 3: {res2[1,3]} vs {res[1,3]} ')
-                logger.debug(f'Balance in hydrostatic in body-fixed reference frame of term 0 4: {res2[0,4]} vs {res[0,4]} ')
-                logger.debug(f'Balance in hydrostatic in body-fixed reference frame of term 5 3: {res2[5,3]} vs {res[5,3]} ')
-
-                res_total[1,3] = 0
-                res_total[0,4] = 0
-                res_total[5,3] = 0
-
-            if is_hydrostatic_equilibrium:
-                # In hydrostatic equilibrium, CoB and CoG are aligned vertically, 
-                # so the terms (3,5) and (4,5) are canceled in both hydrostatic and gravity:
-                # But we can only take off these terms if ref_point = CoB or ref_point = CoG
-                # The gravity stiffness has then to be calculated consistently!
-                cob =self.integrate_cob()
-                res_total = mcn.matrans3(res_total, origin = normal_ref_point, destination= cob)
-                logger.debug(f'Hydrostatic term (3,5) and (4,5) are balanced with gravity: {res_total[3,5]} and {res_total[4,5]}')
-
-                res_total[3,5] = 0.
-                res_total[4,5] = 0.
-                res_total = mcn.matrans3(res_total, origin = cob, destination = output_ref_point)
-            else: 
-                res_total = mcn.matrans3(res_total, origin = normal_ref_point, destination = output_ref_point)
+        elif "hydro" in ref_frame :
+            
+            if hull_stiffness :
+                axoi =  ( gaussPoints[:,0]  - output_ref_point[0] )
+                ayoi =  ( gaussPoints[:,1]  - output_ref_point[1] )
+                
+                res[2,2] += -np.sum( weight * normalsAtGaussPoints[:,2] )
+                res[2,3] += -np.sum( ayoi * weight * normalsAtGaussPoints[:,2] )
+                res[2,4] += np.sum( axoi * weight * normalsAtGaussPoints[:,2] ) 
+                res[3,3] += -np.sum( ayoi**2 * weight * normalsAtGaussPoints[:,2] )
+                res[3,4] += np.sum( axoi * ayoi * weight * normalsAtGaussPoints[:,2] )
+                res[4,4] += -np.sum( axoi**2 * weight * normalsAtGaussPoints[:,2] )
+            
+                # Alternate implementation with generalized normals
+                # axoi =  ( gaussPoints[:,0]  - normal_ref_point[0] )
+                # ayoi =  ( gaussPoints[:,1]  - normal_ref_point[1] )
+                # for i in [2,3,4]:
+                #     res[i,2] -= np.sum( weight *  normalsAtGaussPoints[:,i] )
+                #     res[i,3] -= np.sum( ayoi*weight *  normalsAtGaussPoints[:,i] )
+                #     res[i,4] = np.sum( axoi*weight *  normalsAtGaussPoints[:,i] )
+                # return mcn.matrans3(res, origin = normal_ref_point, destination= output_ref_point)
+        
+            if buoyancy_stiffness :   # Warning : if this part is added, the matrix cannot be moved with matrans.
+                volume = self.integrate_volume()
+                cob = self.integrate_cob()
+                cob_ref = cob - output_ref_point
+                res[4,4] += cob_ref[2] * volume
+                res[3,3] += cob_ref[2] * volume
+                res[3,5] += -volume * cob_ref[0]
+                res[4,5] += -volume * cob_ref[1]
+
+            res[3,2] = res[2,3]
+            res[4,2] = res[2,4]
+            res[4,3] = res[3,4]
 
-            return res_total
         else :
             raise(Exception("ref_frame {ref_frame:} not recognized"))
-
+            
+        if rho_g is not None : 
+            res *= rho_g
+            
+        return res
+                
 
 
     def integrate_cob_py(self, nbGP = 1):
         """Compute and return the center of buoyancy (Assuming closed hull, with free-surface at z=0)
         """
         if nbGP is not None :
             self.refreshGaussPoints(nbGP)
@@ -535,20 +685,22 @@
             f.write( "GROUPS\n1 Hull\nENDGROUPS")
 
         return
 
 
 
     def getCb(self):
+        """Compute block coefficient.
+        """
         dims = [ a[1]-a[0] for a in self.getBounds() ]
         return self.integrate_volume() / np.prod( dims )
 
 
     def __str__(self) :
-        """
+        """Print basic mesh information.
         """
 
         if self.nbnodes == 0 :
             return "Empty mesh"
 
         s = """
 #------- Mesh object ------------------------#
@@ -574,26 +726,26 @@
         return [(np.min(self.nodes[:,0]), np.max(self.nodes[:,0])) ,
                 (np.min(self.nodes[:,1]), np.max(self.nodes[:,1])) ,
                 (np.min(self.nodes[:,2]), np.max(self.nodes[:,2])) ]
 
 
 
     def rotateAxis( self, axis=[0.,1.,0.], angle=0. ):
-        """ Rotate a mesh around axis given by vector (angle in radians)
+        """Rotate a mesh around axis given by vector (angle in radians).
 
         """
         if angle != 0.:
             v = geo.Vector(axis)
             v.normalise()
             rmat = np.transpose(geo.AxisAndAngle(v,angle).getMatrix())
 
             self.setVertices( np.matmul(self.getVertices(),rmat) )
 
     def rotateZYX( self, center=[0.,0.,0.], angle=[0.,0.,0.] ):
-        """ Rotate a mesh around center with Euler angles [roll, pitch, yaw] (angle in radians)
+        """Rotate a mesh around center with Euler angles [roll, pitch, yaw] (angle in radians).
 
         """
         if any(angle) != 0.:
             rmat = geo.EulerAngles_XYZ_e(*angle).getMatrix()
 
             #Apply rotation around center : V' = [rmat]*[V-center] + center
             self.offset([-1.*i for i in center])
@@ -660,15 +812,15 @@
 
     def toVtkUnstructuredGrid(self,offset=(0., 0., 0.)):
         obj = self.convertToVtk(offset=offset,format = "vtkUnstructuredGrid")
         return obj
 
 
     def vtkView(self, *args, **kwargs) :
-        """ Display mesh with vtk
+        """Display mesh with vtk.
         """
         from .vtkView import viewPolyData
         viewPolyData(self.toVtkPolyData(), *args, **kwargs)
 
     def toImage(self, outputFile, **kwargs):
         from .vtkView import polydataPicture
         polydataPicture(self.toVtkPolyData(), outputFile = outputFile, **kwargs)
```

## Snoopy/Meshing/mesh_io.py

```diff
@@ -1,62 +1,60 @@
-import pandas as pd
 import numpy as np
 from Snoopy import Meshing as msh
-from Snoopy.Meshing.structuredGrid import getQuadsConnectivity
 
+def convertPropHull(propHull, symType = msh.SymmetryTypes.NONE, read_coef = False):
+    """Convert mesh from HydrpStar mesh storage to Snoopy object.
 
-def read_gridgen_c(filename, z = 0) :
-    """Read gridgen_c output file and return mesh
-    """
-    nodes = pd.read_csv(filename, delim_whitespace = True, comment = "#", header = None, names = ("x", "y"))
-    nodes.loc[:,"z"] = z
-
-    with open(filename, "r") as f :
-        nx, ny = [int(a) for a in f.readline().split()[1:4:2]]
-
-    nbPanel = (nx-1)*(ny-1)
-    panels = np.empty( (nbPanel,4), dtype = int )
-
-    panels = getQuadsConnectivity(nx,ny)
-
-    #Remove panels containing NaN coordinates
-    nans = np.isnan( np.max(nodes.values[panels, 0], axis = 1) )
-    mesh = msh.Mesh(  Vertices = nodes.values, Tris = np.zeros( (0,3), dtype = float ), Quads = panels[ ~nans ]  )
-    return mesh
-
+    Parameters
+    ----------
+    propHull : np.ndarray
+        The mesh in HydroStar storage format
+    symType : int, optional
+        Symmetry, by default msh.SymmetryTypes.NONE
 
-def convertPropHull(propHull, symType = msh.SymmetryTypes.NONE):
-    """Convert
+    Returns
+    -------
+    Mesh
+        The mesh object
     """
+
     nPanel = len(propHull)
     nodes = np.stack( [ np.hstack( [propHull[:,12],  propHull[:,15],propHull[:,18], propHull[:,21]  ] ),
                         np.hstack( [propHull[:,13],  propHull[:,16],propHull[:,19], propHull[:,22]  ] ),
                         np.hstack( [propHull[:,14],  propHull[:,17],propHull[:,20], propHull[:,23]  ] ),
                       ]).T
 
     panels = np.arange( 0, nPanel*4,1 ).reshape( 4, nPanel ).T
+    
+    mesh = msh.Mesh( Vertices = nodes, Quads = panels, Tris = np.zeros((0,3), dtype = int),
+                     keepSymmetry = True , symType = symType)
+        
+    if read_coef : 
+        mesh.setPanelsData( propHull[:,11][:,np.newaxis], dataNames = ["POROSITY"], dataTypes = [0] , dataFreqs = [np.nan], dataHeads = [np.nan] )
 
+    return mesh
+    
 
 
-    return msh.Mesh( Vertices = nodes, Quads = panels, Tris = np.zeros((0,3), dtype = int),
-                     panelsData = propHull[:,11], keepSymmetry = True , symType = symType)
-
-
-def read_hslec_h5(filename, engine = "h5py"):
-    """Read hslec hdf output and convert to Snoopy.Mesh
+def read_hslec_h5(filename, engine = "h5py", format = "hydrostarmesh"):
+    """Read hslec hdf output and convert to Snoopy.Mesh.
 
     Parameters
     ----------
     filename : str
         Filename
-
+        
+    format : str
+        If format "hydrostarmesh", the mesh is returned as a ````HydroStarMesh```` object (concatenation of meshes), 
+        If format "mesh", the mesh is returned as a ````Mesh````, where belong the panels is then given by "SECTION" data.
+        
     Returns
     -------
-    msh.HydroStarMesh
-        The hydrostar mesh object
+    msh.HydroStarMesh or msh.Mesh
+        The mesh
     """
 
     # Note: hslec h4 does not fully comply with netcdf4, so that it is more robust to open it with h5py directly
     if engine == "h5py" :
         import h5py
         with h5py.File(filename, "r") as da :
             nbbody = da.attrs["NBBODY"][0]
@@ -76,27 +74,46 @@
     symType = msh.SymmetryTypes.NONE
     if hull_symmetry == 1:
         symType = msh.SymmetryTypes.XZ_PLANE
     elif hull_symmetry == 2:
         symType = msh.SymmetryTypes.XZ_YZ_PLANES
 
     underWaterHullMeshes = [  convertPropHull(  prophull[ibody] , symType = symType) for ibody in range(nbbody) ]
+
     aboveWaterHullMeshes = [  convertPropHull( propont[ibody] , symType = symType) for ibody in range(nbbody) ]
+    
     plateMeshes = [  convertPropHull( proplate[ibody] , symType = symType ) for ibody in range(nbbody) ]
 
     # TODO
     tankMeshes = []
     fsMeshes = []
 
-    return msh.HydroStarMesh( underWaterHullMeshes = underWaterHullMeshes,
-                              aboveWaterHullMeshes = aboveWaterHullMeshes,
-                              plateMeshes = plateMeshes,
-                              fsMeshes = fsMeshes,
-                              tankMeshes = tankMeshes,
-                            )
+    if format.lower() == "hydrostarmesh":
+        return msh.HydroStarMesh( underWaterHullMeshes = underWaterHullMeshes,
+                                aboveWaterHullMeshes = aboveWaterHullMeshes,
+                                plateMeshes = plateMeshes,
+                                fsMeshes = fsMeshes,
+                                tankMeshes = tankMeshes,
+                                )
+
+    if format.lower() == "mesh":
+        total_mesh = None
+        for ibd in range(len(underWaterHullMeshes)) :
+            for meshList, i_s in [ (underWaterHullMeshes,1) , (aboveWaterHullMeshes,10), (plateMeshes, 40) ,]:
+                isection = i_s + ibd
+                mesh = meshList[ibd]
+                mesh.appendPanelsData( np.full( (mesh.getNPanels()) , isection) , dataName = "SECTION" )
+                if total_mesh is None : 
+                    total_mesh = mesh
+                else :
+                    total_mesh.append( mesh )
+        return total_mesh
+    else:
+        raise(Exception(f"{format:} is not an available format"))
+                
 
 
 def read_hslec_waterline_h5(filename, engine = "h5py") :
     if engine == "h5py" :
         import h5py
         with h5py.File(filename, "r") as da :
             sym = da.attrs["HULL_SYMMETRY"][0]
@@ -123,12 +140,10 @@
     return x1, y1, x2, y2
 
 
 if __name__ == "__main__" :
     from Snoopy import logger
     logger.setLevel(10)
 
-    filename =  r"D:\Etudes\Basic\hdf\hslec_basic.h5"
-    a = read_hslec_h5(filename)
-    a.write(r"D:\Etudes\Basic\test.hst")
-
+    filename = rf"{msh.TEST_DATA:}/hslec_b31.h5"
+    mesh = read_hslec_h5(filename , format = "mesh")
```

## Snoopy/Reader/__init__.py

```diff
@@ -2,14 +2,15 @@
 from .hydrostar import read_hsprs_h5
 from .hydrostar_v import read_hydrostarV_database
 from .starspec import StarspecParser
 from .bvFormat import bvReader, bvWriter
 from .tecplot import tecplot_HOS
 from .openFoam import openFoamReader, openFoamReadMotion
 from .arianeReader import ariane8Reader, ariane702Reader
+from .OperaH5Reader import OperaH5Reader
 from .bvHdf5 import bvReader_h5, bvWriter_h5
 from .simpleReader import simpleReader
 from .json_tools import NumpyEncoder
 
 TEST_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "tests", "test_data")
 
 #Reader dictionary => possible to pass reader as string
```

## Snoopy/Spectral/edw.py

```diff
@@ -1,13 +1,14 @@
 from copy import deepcopy
 import numpy as np
-import pandas as pd
+
+from matplotlib import pyplot as plt
 from Snoopy import Spectral as sp
 from Snoopy import TimeDomain as td
-from matplotlib import pyplot as plt
+from Snoopy import Math as smt
 from Snoopy import logger
 
 
 class EdwABC(object):
 
     def __init__(self, target , ss, *, method = "MHLGA", wmin = None, wmax = None, dw = None, depth = -1, speed = 0.0):
         self.target = target
@@ -102,32 +103,26 @@
         raise(NotImplementedError)
 
 
 
 class Edw_Rao(EdwABC):
 
     def __init__(self , target, ss, rao,  method = "analytical") :
-        """
-
+        """Compute RCW based on linear RAO.
 
         Parameters
         ----------
         target : float
-            DESCRIPTION.
-        ss : TYPE
-            DESCRIPTION.
-        rao : TYPE
-            DESCRIPTION.
-        method : TYPE, optional
-            DESCRIPTION. The default is "analytical".
-
-        Returns
-        -------
-        None.
-
+            Target to achieve at t=0.0
+        ss : SeaState
+            The sea-state
+        rao : Rao
+            The transfer function
+        method : str, optional
+            "analytical" or "numerical". The default is "analytical".
         """
         self.rao = rao
         EdwABC.__init__(self, target, ss, method = method)
         self._wmin = np.min( self.rao.freq )
         self._wmax = np.max( self.rao.freq )
         self._dw = self.rao.freq[1] - self.rao.freq[0]
         self._nbSeed = len(self.rao.freq)
@@ -264,39 +259,51 @@
         self.wif = sp.Wif( a = [ target / np.abs(v_)], w = [self.freq] , b = [self.head]  , phi = [-p_] )
 
     def _getReconstructor(self, wif ) :
         return lambda x : td.ReconstructionRaoLocal( wif , self.rao )(x)[:, 0]
 
 
 
-def rcwCalc(  targetVal , rao , seaState ) :
-    """
-       Compute RCW and return wif. Only 1 mode, without spreading for now
+def rcwCalc(  targetVal , rao , seaState, dw = None ) :
+    """Compute RCW and return wif. Only 1 mode, without spreading for now.
     """
 
     if seaState.getSpectrumCount() > 1 :
         print ("Design waves not implemented for multi-modal sea-state")
         raise(NotImplementedError)
-    heading = seaState.getSpectrum(0).heading
-
+        
     if not seaState.isUnidirectional() :
         raise(Exception("For unidirectional RCW, the input seastate should be unidirectional"))
+        
+    heading = seaState.getSpectrum(0).heading
+
+    if dw is not None :
+        rao_ = rao.getRaoAtFrequencies( np.arange( smt.round_nearest( np.min(rao.freq), dw) ,
+                                         smt.round_nearest( np.max(rao.freq), dw) + dw ,
+                                         dw ))
+    else :
+        dw = smt.get_dx(rao.freq)
+        rao_ = rao
+        if dw is None :
+            raise(Exception("EDW calculation requires a constant dw step, please provide dw"))
+
+    rSpec = sp.ResponseSpectrum( seaState , rao_.getSorted(duplicatesBounds = False)  )
+    m0  = rSpec.getM0()  # TODO remove spreading if any
+    sw = seaState.compute(rao_.freq)
 
-    rSpec = sp.ResponseSpectrum( seaState , rao  )
-    m0 , m2 = rSpec.computeMoment()  # TODO remove spreading if any
-    sw = seaState.compute(rao.freq)
-    freq = deepcopy(rao.freq)
     ihead = np.argmin( abs(rao.head[:] - heading ) )
-    dw = freq[1] - freq[0]
-    amp = rao.module[ihead, :,0] * sw[:] * dw * targetVal
-    phi = -rao.phasis[ihead, :, 0]
+    
+    if np.rad2deg(abs(rao.head[ihead] - heading )) > 5.0 : 
+        logger.warning("Warning EDW is calculated using a heading far from what is available in the RAO. (> 5 degrees)")
+
+    amp = rao_.module[ihead, :,0] * sw[:] * dw * targetVal
+    phi = -rao_.phasis[ihead, :, 0]
     amp /= m0
-    heading_ = np.empty( (len(freq)) )
-    heading_[:] = heading
-    return sp.Wif( w = freq , a = amp , phi = phi , b = heading_  )
+
+    return sp.Wif( w = rao_.freq , a = amp , phi = phi , b = np.full( (len(rao_.freq)), heading )  )
 
 
 def newWave( targetVal, seaState , wmin=0.2, wmax=1.8, dw=0.05 ):
     """Return wif corresponding to the new wave
     """
 
     if seaState.getSpectrumCount() > 1 :
```

## Snoopy/Spectral/qtf.py

```diff
@@ -14,49 +14,116 @@
         dw = array[1] -array[0]
         for i in range(2, nbarray):
             dw_next = array[i] -array[i-1]
             if abs(dw -dw_next) > 1e-6:
                 return (i, dw, dw_next)
     return (0, dw, dw)
 
-"""Class to handle transfer function
 
-    For rapid prototyping, back and forth with pandas are used.
-    Most of the routines could be transfer to the c++ base class.
-"""
+
 class Qtf(_Spectral.Qtf) :
-    """
-	Full Quadratic Transfer Function data definition, called Qtf here.
+    """Full Quadratic Transfer Function data definition, called Qtf here.
 
     Qtf terms are obtained from a second order diffraction-radiation analysis.
-    They correspond to the mean loads applied to the vessel
-    when subjected to the action of a bichromatic wave of unitary amplitude.
-    They are calculated for given vessel motion coordinates called here modes.
+    They correspond to the 2nd order loads applied to the vessel
+    when subjected to the action of a bichromatic wave.
+    
     The Qtf are then available for Nm modes, but also for
     a limited number Nb of incidences relative to the vessel heading,
     and couples of wave frequencies Nf x Ndf.
 
-    Qtf is then a Nb x Nf x Ndf x Nm matrix defined in the rigid body reference frame.
+    Qtf is then a N_heading x N_frequency x N_difference_frequency x N_mode matrix defined in the rigid body reference frame.
+
     """
 
-    def __init__(self, *args , **kwargs) :
+    def __init__(self, *args , **kwargs):
+        """Construct the QTF object.
+        
+        The Qtf can be constructed from
+            - Data given in amplitude/phase or complex.
+            - File name
+            
+        Parameters
+        ----------
+        b : np.ndarray
+            Headings (in radians)
+        w : np.ndarray
+            wave frequencies
+        dw : np.ndarray
+            Difference frequencies
+        amplitudes : np.ndarray, optional*
+            Qtf module value (n_heading * n_freq * n_diff * n_mode)
+        phases : np.ndarray, optional*
+            Qtf module value (n_heading * n_freq * n_diff * n_mode)
+        reIm : np.ndarray, complex, optional*
+            Qtf module value (n_heading * n_freq * n_diff * n_mode)
+        modes : np.ndarray, optional 
+            modes
+        modeCoefficients : np.ndarray, optional 
+            modes
+        qtfStorageType : sp.QtfStorageType, optional
+            How the qtf is stored, default to sp.QtfStorageType.W_DW
+        refPoint : np.ndarray
+            Reference point
+        waveRefPoint : np.ndarray
+            Phase reference point
+        qtfMode : int, optional
+            DIFF or SUM. The default is sp.QtfMode.DIFF.
+        forwardSpeed : float, optional
+            Forward speed. The default is 0.0.
+        depth : float, optional
+            waterdepth. The default is -1.0.
+            
+            
+        Parameters
+        ----------
+        filename : str
+            File to read
+            
+        Example
+        -------
+        >>> # From file
+        >>> qtf = sp.Qtf("filename.qtf")
+        >>>
+        >>> # From variables
+        >>> w = np.arange(0.2, 1.8, 0.05)
+        >>> dw = np.arange(0., 0.205, 0.05)
+        >>> b = np.linspace(0. , np.pi*2 , 13)
+        >>> data = np.zeros( (len(b) , len(w) , len(dw) , 1) , dtype = complex )
+        >>> qtf = sp.Qtf( b=b, w=w , dw=dw , reIm = data , refPoint = [0.,0.,0.] , waveRefPoint = [0.,0])
+        """
+
         if len(args) == 1 and type(args[0]) == str :
             fn, ext = os.path.splitext(args[0])
             if ext.lower() == ".h5":
                 super().__init__( Qtf.ReadHstarH5( args[0] ))
             else:
                 super().__init__(  Qtf.ReadHstar( args[0]  ))
         elif "filename" in kwargs :
             fn, ext = os.path.splitext(kwargs["filename"])
             if ext.lower() == ".h5":
                 super().__init__( Qtf.ReadHstarH5( **kwargs ) )
             else:
                 super().__init__( Qtf.ReadHstar( **kwargs  ) )
         else :
-            super().__init__( *args , **kwargs )
+            qtfStorageType = kwargs.pop( "qtfStorageType" , _Spectral.QtfStorageType.W_DW )
+            try :
+                if not len(list(filter(lambda arg : (isinstance(arg, _Spectral.QtfStorageType)), args))):
+                    super().__init__( *args , qtfStorageType=qtfStorageType, **kwargs )
+                else:
+                    super().__init__( *args , **kwargs )
+            except TypeError as e: 
+                print (e)
+                raise(TypeError( """Wrong signature for Qtf constructor.
+Available signatures : 
+
+- b(nb_headings) w(nb_frequencies) dw(nb_diff) amplitudes(nb_heading, nb_frequencies, nb_diff, nb_modes) phases(nb_heading, nb_frequencies, nb_diff, nb_modes) refPoint(3) waveRefPoint(2) + optional kwds
+
+- b(nb_headings) w(nb_frequencies) dw(nb_diff) reIm(nb_heading, nb_frequencies, nb_diff, nb_modes)  refPoint(3) waveRefPoint(2) + optional kwds
+"""))
 
     def __str__(self) :
         s = "Frequency ({:}) , {:}\n".format( self.nbfreq , self.freq )
         s += "Difference frequencies ({:}) , {:}\n".format( self.nbdiff , self.diff )
         s += "Headings ({:}) , {:}\n".format( self.nbhead , self.head )
         return s
```

## Snoopy/Spectral/rao.py

```diff
@@ -67,30 +67,59 @@
 
         The based class is in c++, and several constructor are available (see below example). Most of the time, the Rao object is build from a datafile (HydroStar format)
 
         Parameters
         ----------
         filename : str
             Name of the HydroStar rao output
+            
+        Parameters
+        ----------
+        b : np.ndarray
+            Headings (in radians)
+        w : np.ndarray
+            wave frequencies
+        module : np.ndarray, optional*
+            Qtf module value (n_heading * n_freq * n_mode)
+        phase : np.ndarray, optional*
+            Qtf module value (n_heading * n_freq * n_mode)
+        cvalue : np.ndarray, complex, optional*
+            Qtf module value (n_heading * n_freq * n_mode)
+        modes : np.ndarray, optional 
+            modes
+        modeCoefficients : np.ndarray, optional 
+            modes
+        refPoint : np.ndarray
+            Reference point
+        waveRefPoint : np.ndarray
+            Phase reference point
+        forwardSpeed : float, optional
+            Forward speed. The default is 0.0.
+        depth : float, optional
+            waterdepth. The default is -1.0.
 
         Example
         -------
+        >>> # From file
         >>> rao1 = sp.Rao( filename = "heave.rao" )
+        >>> # Copy constructor
         >>> rao2 = sp.Rao( rao  )
+        >>> # From variable
         >>> rao3 = sp.Rao( w =[0.1, 0.2], b = [np.pi] , module = np.ones( (1,2,1) ) ,phase = np.zeros( (1,2,1) ),  refPoint = [0.,0.,0.], waveRefPoint = [0., 0.])
         """
         
         if len(args) == 1 and type(args[0]) == str :
             kwargs =  parse_rao_file( args[0])
             args = []
         elif "filename" in kwargs :
             kwargs = parse_rao_file( **kwargs)
         rho = kwargs.pop("rho",None)
         grav = kwargs.pop("grav",None)
-
+        
+                
         try:
             super().__init__(*args,**kwargs)
         except TypeError:
             # Analyse signature for clearer error message:
             check_input_signature(kwargs)
 
         self.rho = rho
@@ -1549,18 +1578,19 @@
     kwargs.update(metaData)
     return kwargs
 
 
 
 
 def check_input_signature(kwargs):
-    """Check if input of Rao is compatible with C++ init
+    """Check if input of Rao is compatible with C++ init.
     
-    Objective is to get a message easier to read than the one provided by c++
+    Objective is to get a message easier to read than the one provided by c++. It always raises an exception.
     
+        
     
     Parameters
     ----------
     kwargs : dict
         input that are supposed to passed to C++ initiator
 
     Raises
@@ -1584,43 +1614,46 @@
         _must_match_input(keys,[input1,input2])
     elif "modes" in keys:
         _must_match_input(keys,[input4,input6])
     else:
         _must_match_input(keys,[input3,input5])
 
 def _must_match_input(keys,possibility_list):
-    """ Check in set of input keys match the admissible format
+    """Check in set of input keys match the admissible format.
+    
     Parameters
     ----------
     keys : list
         list of input keys
     possibility_list: list
         list of admissible input keys
+
     Raises
     ------
     TypeError
         When something wrong in signature
     """
     all_expected_keys = []
     all_admissible_input = []
     str_all_admissible_input = ""
     for possibility in possibility_list:
         all_expected_keys += possibility
         all_admissible_input.append(set(possibility))
         str_all_admissible_input += "\t"+ ", ".join(possibility) + "\n"
+        
     #Check if there are unexpected keys:
     for key in keys:
         if key not in all_expected_keys:
             raise TypeError(f"__init__() of RAO got an unexpected keyword argument '{key}'")
     
     set_keys = set(keys)
     
     for admissible_input in all_admissible_input:
         if set_keys == admissible_input:
-            return 
+            raise TypeError("Keyword argument names are correct, but type seems wrong") 
         elif len(set_keys.difference(admissible_input)) == 0:
             missing_keys = admissible_input.difference(set_keys)
 
 
     raise TypeError(f"""__init__() is called with invalid set of keywords : {keys}    
 Reminder: input must match one of the following possibility:
 {str_all_admissible_input}May be you miss the following key: {missing_keys}""")
```

## Snoopy/Spectral/spectralStats.py

```diff
@@ -288,27 +288,49 @@
            risk (exceedance probability)
 
         """
         return self.getShtMaxDistribution(duration).cdf(value)
 
 
 
+
+    def stdMaxAmplitude(self , duration):
+        """Return the standard deviation of the maximum on duration.
+        
+        The expression is asymptotic (duration >> RTz)
+
+        Parameters
+        ----------
+        duration : float
+            Sea-state duration, in seconds.
+
+        Returns
+        -------
+        float
+            Standard deviation of the maximum on duration.
+        """
+        return 0.5 * np.pi *  np.sqrt( self.m0 / (3*np.log( duration / self.Rtz )))
+
+
+
+
     def meanMaxAmplitude( self , duration ):
         """Mean maximum on duration.
+        
+        The expression is asymptotic (duration >> RTz)
 
         Parameters
         ----------
         duration : float
             Sea-state duration, in seconds.
 
         Returns
         -------
         float
             Mean maximum on duration.
-
         """
         n = duration / self.Rtz
         return (  ( 2*np.log(n))**0.5 + np.euler_gamma / (2*np.log(n))**0.5 ) * self.m0**0.5
 
 
 
     def getShtMaxDistribution( self , duration ) :
@@ -704,8 +726,10 @@
     p = np.linspace(0.01,0.99,100)
     fig, ax = plt.subplots()
     ax.plot(  stats.risk_to_x( p, duration = 10800 ) , p )
     ax.set_yscale( "log" )
 
     statsVect.getShtMaxDistribution(10800).isf( 0.1 )
 
-
+    np.std(stats.getShtMaxDistribution(1e4).rvs(100000)) / stats.stdMaxAmplitude(1e4)
+    
+    np.mean(stats.getShtMaxDistribution(1e4).rvs(100000)) / stats.meanMaxAmplitude(1e4)
```

## Snoopy/Spectral/wif.py

```diff
@@ -260,15 +260,15 @@
                     w = freq ,
                     phi = data.iloc[:,4] ,
                     b = np.zeros( (len(data)) , dtype = float ),
                     depth = depth)
 
 
 
-    def plot(self , ax=None, marker = "+", linestyle = "", **kwargs  ) :
+    def plot(self , ax=None, marker = "+", linestyle = "", label = "Wave components", **kwargs  ) :
         """Plot the component amplitude against the frequency, if bin width is available, the spectral density is plotted as well.
 
         Parameters
         ----------
         ax : ax or None, optional
             Where tp plot the graph, if None, a new ax is created and returned. The default is None.
         marker : str, optional
@@ -283,24 +283,27 @@
         ax : TYPE
             DESCRIPTION.
 
         """
         if ax is None :
             _ , ax = plt.subplots()
 
-        ax.plot( self.freq , self.amp , marker = marker , linestyle = linestyle, **kwargs )
+        ax.plot( self.freq , self.amp , marker = marker , linestyle = linestyle, label = label, **kwargs )
         ax.set_ylim( bottom=0. , )
         ax.set_xlabel( r"$\omega$ $(rad/s)$" )
         ax.set_ylabel( "Components amplitude" )
         if self.isWidth :
+            label_spectrum = kwargs.pop( "label_spectrum", "Wave spectrum" )
             ax1 = ax.twinx()
             d_ = self.getDensity()
             ax1.set_ylim( bottom=0. , top = max(d_)*1.05 )
-            ax1.plot( self.freq , d_ , "o-" , markersize = 2, color = "red" )
+            ax1.plot( self.freq , d_ , "o-" , markersize = 2, color = "red", label = label_spectrum )
             ax1.set_ylabel( "Spectral density" )
+            ax1.legend(loc = "upper left")
+        ax.legend(loc = "upper right")
         return ax
 
     def plotTime(self, tmin = -100.0 , tmax = +100.0 , dt = 0.5, ax = None):
 
         if ax is None :
             fig, ax = plt.subplots()
 
@@ -399,27 +402,25 @@
 
     @property
     def nbwave(self) :
         return len(self.getPhases())
 
 
     @classmethod
-    def FromTS(cls, se, b , method = "FFT", window = None , **kwargs):
+    def FromTS(cls, se, b , method = "FFT", **kwargs):
         """Generate wif from time series.
 
         Parameters
         ----------
         se : pd.Series
             DESCRIPTION.
         b : float, optional
             Heading.
         method : str, optional
             How to generate wif. The default is "FFT".
-        window : str or None, optional
-            DESCRIPTION. The default is None.
         **kwargs : Any
             Argument passed to underlying algorythm  (freq, model, x0)
 
         Returns
         -------
         sp.Wif
             Wif object
@@ -464,52 +465,53 @@
             kinModel = wk.SecondOrderKinematic21
 
         return kinModel( self ).getElevation( time , 0, 0 ) - wk.FirstOrderKinematic( self ).getElevation( time , 0, 0 )
 
 
 
     @classmethod
-    def FromTS_FFT2(cls, se, b = 0.0, depth = -1., windows = None, wmin = 0.01, wmax = 1.5, itmax = 15, tol = 0.01, full2nd = False):
+    def FromTS_FFT2(cls, se, b = 0.0, depth = -1., wmin = 0.01, wmax = 1.5, itmax = 15, tol = 0.01, full2nd = False):
         """Create a wif from time serie, through FFT
         with iterative process to remove 2nd component
 
 
         Parameters
         ----------
         se : Pandas.Series
             Wave time trace
         b : float, optional
             Wave heading (rad). The default is 0.0.
-        windows : TYPE, optional
-            DESCRIPTION. The default is None.
         wmax : float, optional
             DESCRIPTION. The default is 1.5.
         itmax : int, optional
             Maximum number of iteration. The default is 15.
         tol : float, optional
             Tolerance for convergence criteria. The default is 0.01.
         full2nd : bool, optional
             If True 2nd order potential is accounted for, otherwise, only the quadratic part. The default is True.
 
         Returns
         -------
         Wif
             Wif object corresponding to the input time series.
-
         """
 
-        wif = cls.FromTS( se=se , b=b , depth = depth, windows = windows )
+        wif = cls.FromTS( se=se , b=b , depth = depth)
         wif = wif.getFiltered(wmin = wmin , wmax = wmax)
         for i in range(itmax):
             se1 = se - wif.get2ndOrderElevation( se.index.values , full2nd )
             wif_new = cls.FromTS( se = se1 , b=b , depth = depth )
             diff = abs( wif_new.hs - wif.hs )
             wif = wif_new.getFiltered( wmin = wmin , wmax = wmax )
             if diff < tol :
                 break
+        else : 
+            logger.error( f"Convergence not reached after itmax={itmax:} iterations" )
+            
+        logger.debug(f"FromTS_FFT2 : number of iteration = {i+1:}" )
         return wif
 
 
 
     @classmethod
     def FromTS_FFT(cls, se, b = 0.0, depth = -1., windows = None, wmax = None):
         """Create a wif from time serie, through FFT.
```

## Snoopy/Statistics/_longTerm.py

```diff
@@ -181,15 +181,15 @@
             Contribution coefficient for all sea-states
         """
         contrib = self.probabilityList * (1. - self.shtProb(x))
         contrib /= np.sum(contrib)
         return contrib
 
 
-    def plot_rp(self, rp_range, ax=None, **kwargs):
+    def plot_rp(self, rp_range, ax=None, scale_y = 1.0, **kwargs):
         """Plot return value against return period.
 
         Parameters
         ----------
         rp_range : np.ndarray
             Response period range (in year)
             Only range and number of points are considered.
@@ -206,21 +206,39 @@
             fig, ax = plt.subplots()
 
         # Do not use self.rp_to_x to avoid numerical solving at each point. 
         x_min = self.rp_to_x( np.min(rp_range) )
         x_max = self.rp_to_x( np.max(rp_range) )
         x_range = np.linspace(x_min, x_max, len(rp_range) )
 
-        ax.plot( [self.x_to_rp(x) for x in x_range], x_range , **kwargs )
+        ax.plot( [self.x_to_rp(x) for x in x_range], x_range * scale_y , **kwargs )
         
         ax.set_xscale("log")
         ax.set(xlabel = "Return period (Years)")
         return ax
 
 
+    def slope(self, rp, d_rp = 0.1):
+        """Compute the slope of the long-term distribution with respect to the log of RP (a.k.a. 'severity factor').
+
+        Parameters
+        ----------
+        rp : float
+            Return period
+        d_rp : float, optional
+            Step to calculate the slope, by default 0.1
+
+        Returns
+        -------
+        Float
+            The slope value
+        """
+        x1 = self.rp_to_x(rp)
+        x2 = self.rp_to_x(rp + d_rp)
+        return (x2-x1) / ( np.log(rp+d_rp) - np.log(rp)  )
 
 def _longTermBaseGen( shtProb,  probabilityList, x, duration_s, dss ):
     if x < 1e-20 :
         return 0.0
     pe_ss = np.sum( probabilityList * (1 - (shtProb)))
     res = (1-pe_ss) ** (duration_s / dss)
     return res
@@ -322,15 +340,14 @@
             Long term duration (in year)
 
         Returns
         -------
         float
             cdf (  P( x < X )  )
         """
-
         cycleProb = self.cycleProb(x)
         duration_s = duration * 365.24 * 24 * 3600
         return self.lt_base( cycleProb, self.rTzList, self.probabilityList, x, duration_s, self._idss )
 
 
 
     def x_to_pcycle(self , x, ncycle = None):
@@ -589,43 +606,44 @@
     a = pd.DataFrame( data = {"Rs" : rsList, "Rtz" : rTzList, "prob" : probabilityList } )
     arr = a.groupby( ["Rs" , "Rtz"]).prob.sum().reset_index().loc[ : , ["Rs" , "Rtz", "prob"]].values
     return arr[:,0] , arr[:,1] , arr[:,2]
 
 
 
 
-class LongTermConstant() :
-    """Simple long term calculation without short-term variability
+class LongTermConstant(LongTermGen) :
+    """Simple long term calculation without short-term variability.
     """
 
-    def __init__(self, responseList, probabilityList):
-        from Pluto.statistics.ecdf import Empirical
+    def __init__(self, responseList, probabilityList, dss):
+        """Simple long term calculation without short-term variability.
+
+        Parameters
+        ----------
+        responseList : np.ndarray
+            The constant response in each seastate.
+        probabilityList : np.ndarray
+            The probability of each seastate.
+        dss : float
+            The seastate duration.
+        """
+
+        self.dss = dss
+        self.responseList = responseList
+
         if isinstance(probabilityList, str) :
             if probabilityList == "iso" :
                 self.probabilityList = np.ones( (len(responseList)), dtype = float ) / len(responseList)
         else :
             self.probabilityList = probabilityList / probabilityList.sum()
 
-        self.r = pd.DataFrame( data = np.stack( [ self.probabilityList , responseList] ).transpose() , columns = ["pdf", "response"] )
-        self.r = self.r.loc[self.r.pdf > 0.]
-        self.r.sort_values(by = "response", inplace = True)
-
-        self.r.loc[ : , "cdf"] = (1-np.cumsum(self.r.pdf.values[::-1]))[::-1]
-
-        self.dist = Empirical.FromPieceWiseCDF( self.r.cdf.values , self.r.response.values )
-
-    def plotExceedance(self, ax = None, **kwargs):
-        if ax is None :
-            fig , ax = plt.subplots()
-        ax.plot( self.r.loc[ : , "response"].values ,  1-self.r.loc[ : , "cdf"].values, **kwargs )
-        ax.set_yscale("log")
-        return ax
+    def shtProb(self , x):
+        return ( x > self.responseList ).astype(int)
+        
 
-    def x_to_p(self , p , duration) :
-        raise(NotImplementedError)
 
 if __name__ == "__main__":
     lt = LongTermSpectral( np.array([1,100]) , np.array([10,10]), np.array([1,1]) , dss = 10800)
 
     lt.x_to_rp( lt.rp_to_x(25)  )
     
     lt.plot_rp( rp_range = np.linspace(0.01, 100, 100) )
```

## Snoopy/Tools/print_format.py

```diff
@@ -1,23 +1,26 @@
 import numpy as np
 
-def write_matrix(mat):
-    """Utility function to write matrix
+def write_matrix(mat, threshold = None):
+    """Utility function to write matrix.
 
     Parameters
     ----------
     mat : ndarray
         matrix to be write to text
 
     Returns
     -------
     str
         write matrix to text
     """
-    mat = np.asarray(mat)
+    
+    mat = np.array(mat)
+    if threshold is not None :
+        mat[np.where(np.abs(mat)<threshold) ] = 0.0
     nb_line,nb_collum = mat.shape
     out = ""
     for iline in range(nb_line):
         out += " ".join(["{:.6e}".format(mat[iline,icol]).rjust(14) 
                             for icol in range(nb_collum)]) +"\n"
     return out
```

## Comparing `snoopy_bv-2.0.1.dist-info/LICENSE` & `snoopy_bv-2.0.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `snoopy_bv-2.0.1.dist-info/METADATA` & `snoopy_bv-2.0.2.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,114 +1,114 @@
-Metadata-Version: 2.1
-Name: snoopy-bv
-Version: 2.0.1
-Summary: DR C++/Python library
-Home-page: https://gitlab.com/bv-dr/Snoopy
-Author: Research Department BV M&O
-Author-email: 
-Classifier: Intended Audience :: Science/Research
-Classifier: Topic :: Scientific/Engineering
-Classifier: License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Operating System :: Microsoft :: Windows
-Description-Content-Type: text/x-rst
-License-File: LICENSE
-Requires-Dist: xarray
-Requires-Dist: numpy
-Requires-Dist: scipy
-Requires-Dist: pandas
-Requires-Dist: matplotlib
-Requires-Dist: h5py
-Requires-Dist: tqdm
-Requires-Dist: Deprecated
-
-.. image:: https://gitlab.com/bv-dr/Snoopy/badges/master/pipeline.svg?branch=master
-   :target: https://gitlab.com/bv-dr/Snoopy/badges/master/pipeline.svg
-   :alt: Build Status
-
-
-Snoopy library
-==============
-
-Documentation and tutorials : `https://bv-dr.gitlab.io/Snoopy <https://bv-dr.gitlab.io/Snoopy>`_
-
-Snoopy is an open source library for marine applications. Among other things, it contains the following sub-packages
-
-* 
-  Spectral : Routines for spectral analysis of sea-keeping results
-
-  * Wave spectra (Jonswap, Ochihubble, spreading function...)
-  * Manipulation of transfer function (RAOs)
-  * Response spectrum
-  * 2nd order response spectrum
-
-
-* 
-  TimeDomain
-
-  * Reconstruction of seakeeping results in time domain (1st and 2nd order)
-  * Convolution for wave radiation in time domain (from added-mass).
-  * Upcrossing analysis
-
-* 
-  Fatigue
-
-  * Rainflow counting
-  * Spectral fatigue
-
-* 
-  Meshing
-
-* 
-   WaveKinematics : (Linear, wheeler stretching, 2nd order...)
-  
-* 
-   Statistics
-
-   * Peak Over Threshold
-   * Long term analysis
-  
-
-
-
-
-
-Example of use
---------------
-
-.. code-block:: python
-
-   >>> from Snoopy import Spectral as sp
-   >>> spec = sp.Jonswap( hs = 1.0 , tp = 10.0 , gamma = 1.0)
-   >>> spec.plot()
-
-.. image:: https://gitlab.com/bv-dr/Snoopy/-/raw/master/Doc/pictures/Jonswap.png
-   :width: 400
-   :alt: Jonswap picture
-
-
-
-How to install
---------------
-
-Snoopy is available on pypi.org and can be using pip: 
-
-.. code-block:: sh
-
-   pip install snoopy-bv
-
-
-In case conda is used, it is recommended to install dependencies using conda (hence the --no-deps in above command line):
-
-.. code-block:: sh
-
-   conda install xarray numpy scipy pandas matplotlib h5py tqdm Deprecated
-   pip install snoopy-bv --no-deps
-
-
-
-How to build from sources
--------------------------
-
-To build the package from sources, instructions are given "readme_dev.rst"
+Metadata-Version: 2.1
+Name: snoopy-bv
+Version: 2.0.2
+Summary: DR C++/Python library
+Home-page: https://gitlab.com/bv-dr/Snoopy
+Author: Research Department BV M&O
+Author-email: 
+Classifier: Intended Audience :: Science/Research
+Classifier: Topic :: Scientific/Engineering
+Classifier: License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Operating System :: Microsoft :: Windows
+Description-Content-Type: text/x-rst
+License-File: LICENSE
+Requires-Dist: xarray
+Requires-Dist: numpy
+Requires-Dist: scipy
+Requires-Dist: pandas
+Requires-Dist: matplotlib
+Requires-Dist: h5py
+Requires-Dist: tqdm
+Requires-Dist: Deprecated
+
+.. image:: https://gitlab.com/bv-dr/Snoopy/badges/master/pipeline.svg?branch=master
+   :target: https://gitlab.com/bv-dr/Snoopy/badges/master/pipeline.svg
+   :alt: Build Status
+
+
+Snoopy library
+==============
+
+Documentation and tutorials : `https://bv-dr.gitlab.io/Snoopy <https://bv-dr.gitlab.io/Snoopy>`_
+
+Snoopy is an open source library for marine applications. Among other things, it contains the following sub-packages
+
+* 
+  Spectral : Routines for spectral analysis of sea-keeping results
+
+  * Wave spectra (Jonswap, Ochihubble, spreading function...)
+  * Manipulation of transfer function (RAOs)
+  * Response spectrum
+  * 2nd order response spectrum
+
+
+* 
+  TimeDomain
+
+  * Reconstruction of seakeeping results in time domain (1st and 2nd order)
+  * Convolution for wave radiation in time domain (from added-mass).
+  * Upcrossing analysis
+
+* 
+  Fatigue
+
+  * Rainflow counting
+  * Spectral fatigue
+
+* 
+  Meshing
+
+* 
+   WaveKinematics : (Linear, wheeler stretching, 2nd order...)
+  
+* 
+   Statistics
+
+   * Peak Over Threshold
+   * Long term analysis
+  
+
+
+
+
+
+Example of use
+--------------
+
+.. code-block:: python
+
+   >>> from Snoopy import Spectral as sp
+   >>> spec = sp.Jonswap( hs = 1.0 , tp = 10.0 , gamma = 1.0)
+   >>> spec.plot()
+
+.. image:: https://gitlab.com/bv-dr/Snoopy/-/raw/master/Doc/pictures/Jonswap.png
+   :width: 400
+   :alt: Jonswap picture
+
+
+
+How to install
+--------------
+
+Snoopy is available on pypi.org and can be using pip: 
+
+.. code-block:: sh
+
+   pip install snoopy-bv
+
+
+In case conda is used, it is recommended to install dependencies using conda (hence the --no-deps in above command line):
+
+.. code-block:: sh
+
+   conda install xarray numpy scipy pandas matplotlib h5py tqdm Deprecated
+   pip install snoopy-bv --no-deps
+
+
+
+How to build from sources
+-------------------------
+
+To build the package from sources, instructions are given "readme_dev.rst"
```

## Comparing `snoopy_bv-2.0.1.dist-info/RECORD` & `snoopy_bv-2.0.2.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,49 +1,63 @@
 Snoopy/__init__.py,sha256=RvdMaGLgYBV5AoFG2AZtz49LtXrdW5_vvOoESKyAdjQ,2816
-Snoopy/version.py,sha256=A6OOuUF_-lYQTQRteDEPLdaiChKfoYGPVlQFHZUzbhg,131
-Snoopy/DLLs/_Geometry.cp39-win_amd64.pyd,sha256=EaMbTSiG6PSq6BWJPEzfdCOOHrF_LtbzEBvYOOhL9ms,3260928
-Snoopy/DLLs/_Math.cp39-win_amd64.pyd,sha256=RMjfeVeCaAcU5hcxXPXthc72CLPsZnx5bSBewd3FM6I,2544128
-Snoopy/DLLs/_Mechanics.cp39-win_amd64.pyd,sha256=MLcKa3gKBJlqnRm7Vm4KySbS9mE8p_1Ww9YoFrSRoOM,1123328
-Snoopy/DLLs/_Meshing.cp39-win_amd64.pyd,sha256=P_Dq4OJAUNF1S7UxFPaSCW3soiG4jx5yC_N5smibAS8,1093120
-Snoopy/DLLs/_Spectral.cp39-win_amd64.pyd,sha256=k79zcB8PoQ-Z70oM9oHZ_I1edzbaWq7W23kFI90K2Ro,2224128
-Snoopy/DLLs/_Statistics.cp39-win_amd64.pyd,sha256=ztB62dK4Cpugp1Vi0CZBZf5gxZa0_mYKOVl6pPNkgNA,599040
-Snoopy/DLLs/_TimeDomain.cp39-win_amd64.pyd,sha256=qd-ZiXzZX-B4eJFOO4AlYtinQN290uraDws1zyv4Yys,1214976
-Snoopy/DLLs/_WaveKinematic.cp39-win_amd64.pyd,sha256=SS97oiofN41neISx9MC9iliVRgsDyqhsSKuizcGbl84,740864
+Snoopy/version.py,sha256=bUti4onbBzsidZOucrhPd8sWS7jLs6lqfeNRcWv0fBc,119
+Snoopy/DLLs/DspFilters.dll,sha256=LJezY-zE89e64luIGKihZ6XIBs0oC8cHOvYt7SCHfVo,157696
+Snoopy/DLLs/FiniteDifference.dll,sha256=xYbNOxsjSSl9hKHg2TO-mADnttcoHp9Y9xCgX751wpI,45568
+Snoopy/DLLs/Geometry.dll,sha256=wwdE2910ntoD9u7U-2RU227MLhclUfysjNB5vhhWqs0,841216
+Snoopy/DLLs/Integration.dll,sha256=bB9G14pOetg5-QPWrxHwh99eM0QtapIy_3uw-sgEDw0,221184
+Snoopy/DLLs/MathTools.dll,sha256=JzD1VH_fnDrV9wBDBbCwbAU8xW3RhwHw7CiluEd4ZHU,73728
+Snoopy/DLLs/Mechanics.dll,sha256=JUQaDm-JY6IVZnAfZ3yIFuM6wn5wH-Z_nvTXe6Emgks,59904
+Snoopy/DLLs/Meshing.dll,sha256=Hf8qiBtSTXMiuQOaBxoY78jfDmfpKv3LDVUBu6SpL3g,705536
+Snoopy/DLLs/Solvers.dll,sha256=VlKjFCmg8lFN9aWKQrpO_enUqMw425TgUIzj1uGvhPg,38400
+Snoopy/DLLs/Spectral.dll,sha256=o8b8o2VMV4AcjT6fctByT6vTN6ZGksIbTPf0fPZ3Ctg,1307136
+Snoopy/DLLs/Statistics.dll,sha256=fwVU5_VPyABiDsKfFSG8-8HZMz3W7iBV09P0HpmtIpY,121344
+Snoopy/DLLs/TimeDomain.dll,sha256=RRgPEYYHESLTEjnrudpFCuZxGjBDUzdbZaYjRwd9uRM,356864
+Snoopy/DLLs/WaveKinematic.dll,sha256=ny5PDUEEt6-GnQuvm5dt36sZ2c1F3rE9FgqSf5AM_dQ,127488
+Snoopy/DLLs/_Geometry.cp311-win_amd64.pyd,sha256=prmon3_fiZsVevEN7C1d28-4joBl0qs4ImJEpcDKuoM,2786304
+Snoopy/DLLs/_Math.cp311-win_amd64.pyd,sha256=7xw4Abapd4SYga64kRQ1b_uYXCBG7NgW3PAugrb-pdI,2176512
+Snoopy/DLLs/_Mechanics.cp311-win_amd64.pyd,sha256=-3cNw2iAnkZ9IqWHyeMR5yy2ADhwDPGqsmLotkphpaQ,925696
+Snoopy/DLLs/_Meshing.cp311-win_amd64.pyd,sha256=O0qXEVZTrSHcmWdbQ15Yo2P9w3j694nosRPij-K5Q-k,636928
+Snoopy/DLLs/_Spectral.cp311-win_amd64.pyd,sha256=3td8Pka0YKD-f_LeQb366zpkE_JkU3YPaRllnfBkQkE,1524736
+Snoopy/DLLs/_Statistics.cp311-win_amd64.pyd,sha256=3iRvJr6x5cJsDXOPCmJ2M7wLwlTV_IApcJBtTkbhGKs,518144
+Snoopy/DLLs/_TimeDomain.cp311-win_amd64.pyd,sha256=RZxhAsVkYYdDQcUx-wBITE1n7RYNSeILdoVJ_UQfu58,668672
+Snoopy/DLLs/_WaveKinematic.cp311-win_amd64.pyd,sha256=IcVjZmdhKocrjcgfnd1rof1wJUyS4CniDFEPR4eHpxk,587776
 Snoopy/Dataset/__init__.py,sha256=mZwDosRvDknP06JtIbUB28bwXIHczCriGqpOsy36yps,6915
+Snoopy/Dataset/rec34_rev2.csv,sha256=DiV-wuXCUKdbe7f51PY1r47CYicyjph7fatO1nNLTD0,1419
 Snoopy/Fatigue/__init__.py,sha256=SLDUUZZdC7qHc_9esnu6Xf84ig-jZusG2Syt63Gh_p4,197
 Snoopy/Fatigue/rainflow.py,sha256=twz9_AF6hLEqDfmz_IRuimT95co53v2jDzcYdvLnMQE,4922
 Snoopy/Fatigue/sn_curve.py,sha256=eaKOzUsrUsubUshBSgJhWCGWZRaRYxSTiqpEX8omEu4,15472
 Snoopy/Geometry/__init__.py,sha256=PKQh2mKvsZ8rDbs3uz0ZRbVC2rDujiFrnLSX8CFq0s4,11379
 Snoopy/Geometry/sx3Manipulation.py,sha256=6dKhTtuOk9JDzXeYaJ3YTyzDK9oDD7StSTmEwym-Wm8,1835
-Snoopy/Math/Functions.py,sha256=-aYhxtduk9jp1kFYuhGmtwlgb2XjsoP1Ts9Gw907h94,8977
+Snoopy/Math/Functions.py,sha256=QYqlbEe2OTaj_eLEqGCRMhdaT2EKM86sAQrjG1ehvcs,9248
 Snoopy/Math/_HLCL.py,sha256=VtAvBsU13ufHJwCPsBj8a5Zq-cff8VrgMpEGr7HzVNI,2777
 Snoopy/Math/_MHLGA.py,sha256=wxFwprPSWjkUNXV-kHvPPVa981J_Z5cJQ3ptAAjei40,4795
 Snoopy/Math/__init__.py,sha256=gAUkVk-yAJQlLFZNAygzoOGnZnh9xU36UqUO7nFQrA0,469
 Snoopy/Math/cmplxInterp.py,sha256=EwKIgdThKd24u4wKYGUR1-9obEHWx9Dj5L2QlNM1Nxw,3694
 Snoopy/Math/interpolate.py,sha256=P9VaS2bCL8ZA9yLyGJj6DHkpiENs036IJE7xs27GWHs,4436
 Snoopy/Math/iso_contour.py,sha256=rDfFtXWKHI2x2DclORdfP_ufRrs9XEynMHmxbeJ9Wqk,2244
 Snoopy/Math/numerical_jacobian.py,sha256=qW6-tTNbGcxcXBSZKWW6MS2UotfA1yEfwSTGdQC-mBk,1737
 Snoopy/Math/numpy_related.py,sha256=lTK-n2hlMN7ewBoMyWTuMSCFO5heaTe1au8TaUR-p5Q,2353
 Snoopy/Mechanics/ReferenceFrameTools.py,sha256=2PnxSZG-0l1vivPV98ZO0FH0pmuxfbEVaKTRi6jOVWU,2450
-Snoopy/Mechanics/__init__.py,sha256=7YiievIa4i1gtwn99rEvDRKs2z4_qOjvJGXn0Sbn6a8,5497
-Snoopy/Mechanics/hydro_coef.py,sha256=hP_eRMy8ITFwPCZTMm8HrKjxjAShmq-N4QHGfw8nvjE,19575
+Snoopy/Mechanics/__init__.py,sha256=RgKsJ5pXyYCmhlAVBjAxsydWhdH1mnrMWfZVGupmZ5A,5520
+Snoopy/Mechanics/hydro_coef.py,sha256=7_qqHizaLnW31qKeabgF6KAkktIFFQC9USpIatAPBSI,19984
 Snoopy/Mechanics/hydro_coef_io.py,sha256=VMxJoHx1szZQ3AbRacLeltjPXn_uJXA6Qd9xmT2iJrs,3936
-Snoopy/Mechanics/internal_load.py,sha256=NC8DIHwDl7pxaUgs9-FUliUlZlAvuBriTWRadla84R4,16603
+Snoopy/Mechanics/hydro_data.csv,sha256=KCz5jYw5oeOgGaVY8qa8rd8x69k5ciQTXeuA6ruVRbo,2775
+Snoopy/Mechanics/internal_load.py,sha256=C84tTjKGzCjADlpuYmpcmetzRieev-plpPfghciaxs0,16783
 Snoopy/Mechanics/mass_distribution.py,sha256=GFw8Wc6_hSw4Fw1vYsns6MruZD7-vL5NlRNULMVXxWs,52041
 Snoopy/Mechanics/mass_section.py,sha256=4c1qE_q-6XiEH9wI7q3jp0VOoDL32x90HmlcLeSelVE,20043
 Snoopy/Mechanics/matrans.py,sha256=lgn_McTB_XXjhhj9Y8fES9TmIp6_wWiziiCpkbok_I4,3920
-Snoopy/Mechanics/mechanicalsolver.py,sha256=h1f_o7u0BEeq01FpHdxj9_dLBVMpwl-u2g79IXeiw2c,15841
+Snoopy/Mechanics/mechanicalsolver.py,sha256=UE8aSXpNqSz0rrNFw7RAMvGzmLoOeTZA8qYNAQsz2Mc,16016
 Snoopy/Meshing/FreeSurfaceMesher.py,sha256=9sQm7ghdCK3Kam7s9jcMV6pWdPBkzfFd81YBvEqAqC0,3928
 Snoopy/Meshing/__init__.py,sha256=p9BFrqA4Qxtuzy6BiJDvl0rmEB2HJi2H88VytDpnvpk,266
 Snoopy/Meshing/balance.py,sha256=SZnsNvHCPQ-kON56SHe4kVZn-b9jQ1EMJtR4DH5T-oM,11918
 Snoopy/Meshing/hsbln.py,sha256=fOAZXYGOh90poO4SqCQ5f0Isu6ro7L_caxELg6WtEM4,425
 Snoopy/Meshing/hydroStarMesh.py,sha256=NjPXHvCm0EtlHSIgwU0_36r__p24q0jxOCG7mUSBY7M,8516
 Snoopy/Meshing/hydro_names.py,sha256=m6bsYkrOal6PUXAOVjn6ZTmIiYb88MF9165lwY_xee4,1590
-Snoopy/Meshing/mesh.py,sha256=AzkZWAasFh0hN-psHIUjpfvfIP6KMC2KXOo1yVmgRI4,42068
-Snoopy/Meshing/mesh_io.py,sha256=BG3SDVUz0EPzEZKq_wHUhtRFm8HokkkMAd25upR3lYc,5016
+Snoopy/Meshing/mesh.py,sha256=drNC_IROFsoZ_iuRpWWkV98LHh80lXAmUG_we180EMY,46330
+Snoopy/Meshing/mesh_io.py,sha256=uDkRtj9b6iyYE5ARUVRroRf4SQQqpx__e_X1WsGEvko,5724
 Snoopy/Meshing/structuredGrid.py,sha256=OmmedniSQdhuWrAj7L1KjD9HzubiEVnePKxVCT_LD2o,1006
 Snoopy/Meshing/vtkTools.py,sha256=W9iasdJ8UlZbTM2dEfDSLa3mqO2s4krK6g7mMJ53e7s,9171
 Snoopy/Meshing/vtkView.py,sha256=YRqfDSu7GRREBnSQ27ERs_ifWF48Xwi0nyRGadecZjo,3488
 Snoopy/Meshing/waterline.py,sha256=wjFkviLbLRjWgMaV_ovr2BJw87vBmBo8TrwPFq51UoY,7714
 Snoopy/PyplotTools/__init__.py,sha256=yA-RPJCLQioUbtHHHyHo-oteZ1-1sutL1i8InbiLWPs,1192
 Snoopy/PyplotTools/_scatterPlot.py,sha256=HEbasqFOUWr-xTwRlwtIlf3IEjzzftNbrZe-Ja2dzp4,5845
 Snoopy/PyplotTools/addScale.py,sha256=FFngjVsv2JYCTjL74ewe2pM5fXZKfMOODaGCI33Q5i0,1808
@@ -56,15 +70,15 @@
 Snoopy/PyplotTools/misc.py,sha256=xzMNMkAtZju3xNckfk8H25df6bspSJeNmCFA8uqr7TE,8396
 Snoopy/PyplotTools/mplZoom.py,sha256=4SkzujHYza4iyLejbHLSmjqYL1H24CsmCB6c53aFFPw,2669
 Snoopy/PyplotTools/snoopy.mplstyle,sha256=BK7tPsFzYDNVaviD_Gt0osCAcvWRVXrF_u8p0h0Nx7c,202
 Snoopy/PyplotTools/statPlots.py,sha256=3CIvo2ubc88ZdYRilh4Q5ESdU80I6CWyFHQCc3fd9gk,12986
 Snoopy/PyplotTools/surfacePlot.py,sha256=MD9d9ZkZLc5Gb2J2UyWWyhLaVHnWmXFolyA2SsfXMHw,2475
 Snoopy/PyplotTools/vtkLUT.py,sha256=TzIjdGZNiAVgFXPVG1QmL8nJU1rIKx6rIIOc3qpcCDU,621
 Snoopy/Reader/OperaH5Reader.py,sha256=xYpSlnX73MOFhbmdqa9HZWAK_AG6ep8kb6i9PAWZHE4,2599
-Snoopy/Reader/__init__.py,sha256=6UAASfLJwvIWg5IUs34rrTt9JwzfyVxI5usm4srbTbs,2905
+Snoopy/Reader/__init__.py,sha256=WBJaEijBqyeckmwUxoh6NFAD70__iTzJquKuxh3LEUk,2946
 Snoopy/Reader/arianeReader.py,sha256=0Sb-bUcmt6H7StE5EOgqJNtYHEY-dyPxXFC1yM8_O1U,1964
 Snoopy/Reader/bvFormat.py,sha256=USdUjLGKCI4AkombI5LHf8yD8t5m_1UprNf0yr6RBTw,2484
 Snoopy/Reader/bvHdf5.py,sha256=PlSnZyi7Ql9edCva5u_LvOi74w26ykhWOgwNIqt_htE,2772
 Snoopy/Reader/donFormat.py,sha256=tUgeRh8mAZRjT9xlcs4YA7sIDIie7WD_FxFKaCYL_2I,6238
 Snoopy/Reader/dynProbeReader.py,sha256=2PM3Vh8O0zM-iVJEKokbtAwXd-cxZFWU0I-I9PkQK4o,12509
 Snoopy/Reader/hydrostar.py,sha256=bML2eRT93FDhmyIreaOArKP2NP7BwRCRgttf7-chpxA,6613
 Snoopy/Reader/hydrostar_v.py,sha256=YzU_0VOwaKT4NoO4wEDjCVMaaedpNN3y06mMBUFkWFs,10243
@@ -76,38 +90,38 @@
 Snoopy/Reader/simpleReader.py,sha256=DdaXSVt2kPJbK_wFtMIV2RueOR2LeoH9KOXwcEJBQFI,1057
 Snoopy/Reader/starspec.py,sha256=aJYyrLBNjjbnmuzGcZqYcdMBWXdePytycNr6cogQBzQ,7632
 Snoopy/Reader/tecplot.py,sha256=PypX5SFbQ0StGNyk0lypZEOSRzNxiSKBU0K4dVrl6xs,2571
 Snoopy/Spectral/Qtf_class.py,sha256=HOgHMRzFiTd12jCVTAOG32C8ie41V6j7iW9Qm5_qGv8,6586
 Snoopy/Spectral/__init__.py,sha256=26HN5BNhjxtSrQ8LAtwn5ohAtIPGiMCNyGoueBYBKmc,1566
 Snoopy/Spectral/dampingLinearization.py,sha256=jzqEZ8fjLeLMb4Zi0MQAP8nuzhmzpoxzitU-2a_F4NE,8228
 Snoopy/Spectral/dispersion.py,sha256=ixEK0ACta0D8fkI-CRddI2qEbRIV7Mr5Lt7Plj0YiEM,7098
-Snoopy/Spectral/edw.py,sha256=FGS8nSXV0fNCYO45_9VhISwt5DwIOS0wEVWgttF1Gwc,12107
+Snoopy/Spectral/edw.py,sha256=PztF5gdQG7uj58fvjYDJ8lelyG-dKwWk_W-U2MNSAQg,12731
 Snoopy/Spectral/enc_freq.py,sha256=FpQeYd9LUxXIjMMUJm4Vknp3JQn0hYTuWVocBpxPTcA,2036
 Snoopy/Spectral/headingConvention.py,sha256=UVFAFshpxcJr824qVf61JuMfWhBPe3Viw5MiFZBFE4Y,9159
 Snoopy/Spectral/linearize_and_match.py,sha256=72dAAG6_w9_HMl3IO0ZvIhiuK4rHRpknkEIrB1fp5nY,11375
 Snoopy/Spectral/misc.py,sha256=xJFc5wGTCUJjcD4nEVQP71zdCudVi2P5HST9Xd011f4,6522
 Snoopy/Spectral/mqtf.py,sha256=MW4JQ1ibKyBjIhA5BtPV48mLkaUObn5KeHV4JEwdoIE,23093
-Snoopy/Spectral/qtf.py,sha256=7k327matLyvc6CJRMtuCFkzZVRBBof0Nnh_gkz3WILA,23922
-Snoopy/Spectral/rao.py,sha256=EgP-B3l2OYC0rPY7lWUAh1FjWWESQJUE4VTsbumlX0w,55462
+Snoopy/Spectral/qtf.py,sha256=XMQWoiFeujvbApe_hkeCkWCDV80aiBtar4D3Mw6wNr8,26483
+Snoopy/Spectral/rao.py,sha256=6tTfZDtiGNahnTSLSc7H5pVwYMs6gTewU6lSNT0tMw8,56570
 Snoopy/Spectral/responseSpectrum.py,sha256=8LYPmjuz-xa4ym9ZbKYOaJHKVcKtCiwhT1O5H_7t7fY,4748
 Snoopy/Spectral/seaStateList.py,sha256=0u2WHv9GqYA9oOEKxvPZjKrnBYBvhvjsRFLhlMy988Q,15185
 Snoopy/Spectral/seastate.py,sha256=pQBsycpoGbFMM_VO9jMew4tJAMEhBpdwdeSNRwwJvbs,51177
 Snoopy/Spectral/spectralMoments.py,sha256=9yTKggEIO2W51fNniY-UZFgYZqHXubxSm0QxJBi5rGs,417
-Snoopy/Spectral/spectralStats.py,sha256=Tos4Kvi8u23pXphlP01T7knVSdYZkpMs6q4vVosJ5u4,17181
+Snoopy/Spectral/spectralStats.py,sha256=ZBfbo9uG4qZebP57ND8Z9Zewq1SKzMuIHLpDm6RgtiY,17912
 Snoopy/Spectral/spectrum.py,sha256=WVhuK7xI_f5qAlq5otbRWkdDG9rhv-vM3TbppaO1eIY,19732
 Snoopy/Spectral/spreading.py,sha256=DUIx0S6hzT6lsUhqHEh318PMRYMvyif4dfizKRdWmZo,1255
 Snoopy/Spectral/waveMaker.py,sha256=gt6tXcXVqJQNYtZ4xt4eBoTk65UFtOWPVrNmY9lo5dQ,4922
 Snoopy/Spectral/wib.py,sha256=Sos8j6EUstPlALz-PNzUC1_RYcfnvTPv5pPcIqz08FE,5798
-Snoopy/Spectral/wif.py,sha256=Kgec9E1jLC6sodYn3UNDXBmQ97Ahnob7AnZtGAHgugE,25853
+Snoopy/Spectral/wif.py,sha256=8Gz-KrkCBtmxE19kH6HACYOCEs7dG9dLWbGPzp6NDzA,26046
 Snoopy/Spectral/wifm.py,sha256=sr6TjU837Rnyd50opCj7_4-iliuQIrAKWCL6KQPk8aU,4535
 Snoopy/Statistics/__init__.py,sha256=ghfRSIqrdZ-nz2h3GusjBNYIuXiT2DyXLA4fhaz_lAA,1084
 Snoopy/Statistics/_blockMaxima.py,sha256=GItCDcHudIKWKhd5HXrgXdxt7yz7elvRHebmAWuEFqI,22279
 Snoopy/Statistics/_diform.py,sha256=PA-0yQBkQllGaJwhqRtj2-B7nDkQ0xox2uNOOj2xFNk,24386
 Snoopy/Statistics/_impact_velocity.py,sha256=5L3u519klMXU9AbNTFgso0If7ONO0qppLjaSEWax5OE,3259
-Snoopy/Statistics/_longTerm.py,sha256=HpYapp45OwDwKvuYZMa7QnS5UQHB-bOFPnM1MMX1O1Y,21015
+Snoopy/Statistics/_longTerm.py,sha256=hZvH-gKE2b1nWXfaHnENr-FNMRPXlRyGozcK6ZSUxrE,21298
 Snoopy/Statistics/_longTermSD.py,sha256=wSfwDsc9Mosamz6MKC_FnmFiz4BnbKy7j28zkWawCGc,10049
 Snoopy/Statistics/_pot.py,sha256=QAJflCjUEW4Rwynn5CNSTdGMY1BubeX9HifnOW6aDj8,26149
 Snoopy/Statistics/discreteSD.py,sha256=A7SDkg8cbrAfv8ouylIH2-zVHU2BmoH9K5iybLOPSVI,16281
 Snoopy/Statistics/dist.py,sha256=lcvhr3NJEu243I55pko8a63-PTQgvSHzPTWhB7F79YA,7951
 Snoopy/Statistics/distribution_cpp.py,sha256=Y2G3Cel-nQFDNXZn1OYcctFk0it0TYGXJp88Mdslu8o,2671
 Snoopy/Statistics/distribution_jitted.py,sha256=VTDhicSHdQxoTz8ARikLZ8GV6jHmRCGcxKBBcU3yymQ,905
 Snoopy/Statistics/empirical_quantiles.py,sha256=PI225HyzjLsQjDJ4jXv-W3MC95sMiEzlKzUkZz2CV6E,3394
@@ -132,19 +146,19 @@
 Snoopy/TimeDomain/slammingVelocity.py,sha256=PhlQCzt5NARcr_5p_C75ryQ88AQI10v8Gq-Czv_Evmw,1754
 Snoopy/TimeDomain/srs.py,sha256=VO1DLr4resFX0yjsSxlcm874wKZEF0L6wEiuSa36ezQ,7877
 Snoopy/TimeDomain/upCross.py,sha256=J5gmIeCHi2CzDsKGrkLz8vTCwgEuPX6EWPQwOReg1_s,13164
 Snoopy/Tools/__init__.py,sha256=OtRgRhSzTq6AK_MRCcnMF7yucr9JueSAS_ddpxnCyv4,216
 Snoopy/Tools/_deprecated.py,sha256=gJyJJW-rAoH6W1oPRMaBP8AgGtFNXN5pEvQZ6pNzs4Y,5510
 Snoopy/Tools/callCounter.py,sha256=8-2VqvfTy2VJdrSYNp9xYkmLXlMAdxfQIJJiSZ9IayQ,453
 Snoopy/Tools/logTimerFormatter.py,sha256=Knp6RQcqU4hc_QBCXaSxJ65LZHsW6OQ2uXpDkSV0VbU,1729
-Snoopy/Tools/print_format.py,sha256=GTkO7_ANpHcHhMm6-qzpYMgrVqmH7r3KMhy6fGZ1b70,1465
+Snoopy/Tools/print_format.py,sha256=PvcFVqIf2Hzl6jFpv7crvfcVT8blXTdYeHZsZMPLIB0,1570
 Snoopy/Tools/string_tools.py,sha256=lnkCiG5tr3u_HobqN0G2c3WKjaWlA2SJU2NrElMkchg,546
 Snoopy/Tools/timeout.py,sha256=MiPzoOL7z55kl6jX4qsl-8DtobzfWJvRt_M6DSKd8m4,1313
 Snoopy/WaveKinematic/__init__.py,sha256=KyGhSSVLyNKuXNX9FX1bM36kW9VVB8M2a9pwR_R-Fw0,354
 Snoopy/WaveKinematic/bathymetry_utils.py,sha256=xDYz7eRaEcEshgPovQCutmYhPxa8YtY_1eB11BjbYbY,2862
 Snoopy/WaveKinematic/variableBathymetry.py,sha256=h5X95Nx2MVNlNJLrTnjtZgcXixLoEgWrK_dBDa_MITk,34878
 Snoopy/WaveKinematic/waveKinematic.py,sha256=qkHQ6fa_uxUjDEpuJDwGMmCK8f3PlYkOy8VX2vx9Z84,9008
-snoopy_bv-2.0.1.dist-info/LICENSE,sha256=ay5wyANQSkvrGByj8r-vUbrAezsmjGR890VDLFcQsKo,33803
-snoopy_bv-2.0.1.dist-info/METADATA,sha256=Jkur-3zwG8abRSjOTSQEZ3XdMpcfY5JGnXIzTQl0msw,2797
-snoopy_bv-2.0.1.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
-snoopy_bv-2.0.1.dist-info/top_level.txt,sha256=JSYAFtxnp2JZ8AdIfIIZCb1CizWWpP-y5qjTi7FdDfA,7
-snoopy_bv-2.0.1.dist-info/RECORD,,
+snoopy_bv-2.0.2.dist-info/LICENSE,sha256=ay5wyANQSkvrGByj8r-vUbrAezsmjGR890VDLFcQsKo,33803
+snoopy_bv-2.0.2.dist-info/METADATA,sha256=6Rj1Ans02GOQ43Pw2be3XSZY_fJCZB7WcB0TEvmMJ6E,2683
+snoopy_bv-2.0.2.dist-info/WHEEL,sha256=TxwUeV-3HEbjjXVQ7qnUZIKQ4IinhZYV_rmkwq84M_Y,102
+snoopy_bv-2.0.2.dist-info/top_level.txt,sha256=JSYAFtxnp2JZ8AdIfIIZCb1CizWWpP-y5qjTi7FdDfA,7
+snoopy_bv-2.0.2.dist-info/RECORD,,
```

