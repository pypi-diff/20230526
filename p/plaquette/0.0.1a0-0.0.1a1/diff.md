# Comparing `tmp/plaquette-0.0.1a0-py3-none-any.whl.zip` & `tmp/plaquette-0.0.1a1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,34 @@
-Zip file size: 124399 bytes, number of entries: 30
--rw-r--r--  2.0 unx     1610 b- defN 23-May-25 14:17 plaquette/__init__.py
--rw-r--r--  2.0 unx      225 b- defN 23-May-25 14:18 plaquette/__main__.py
--rw-r--r--  2.0 unx    54561 b- defN 23-May-25 14:18 plaquette/pauli.py
--rw-r--r--  2.0 unx    11302 b- defN 23-May-25 14:18 plaquette/circuit/__init__.py
--rw-r--r--  2.0 unx    17558 b- defN 23-May-25 14:18 plaquette/circuit/generator.py
--rw-r--r--  2.0 unx     3572 b- defN 23-May-25 14:18 plaquette/circuit/openqasm.py
--rw-r--r--  2.0 unx    13863 b- defN 23-May-25 14:18 plaquette/codes/__init__.py
--rw-r--r--  2.0 unx    36704 b- defN 23-May-25 14:18 plaquette/codes/latticebase.py
--rw-r--r--  2.0 unx    10509 b- defN 23-May-25 14:18 plaquette/codes/latticeinstances.py
--rw-r--r--  2.0 unx     3563 b- defN 23-May-25 14:18 plaquette/decoders/__init__.py
--rw-r--r--  2.0 unx    16338 b- defN 23-May-25 14:18 plaquette/decoders/decoderbase.py
--rw-r--r--  2.0 unx     4267 b- defN 23-May-25 14:18 plaquette/decoders/fusionblossom.py
--rw-r--r--  2.0 unx     1788 b- defN 23-May-25 14:18 plaquette/decoders/interfaces.py
--rw-r--r--  2.0 unx     4336 b- defN 23-May-25 14:18 plaquette/decoders/matching.py
--rw-r--r--  2.0 unx    28683 b- defN 23-May-25 14:18 plaquette/decoders/unionfind_decoder.py
--rw-r--r--  2.0 unx    20750 b- defN 23-May-25 14:18 plaquette/decoders/unionfind_erasure.py
--rw-r--r--  2.0 unx     4102 b- defN 23-May-25 14:18 plaquette/decoders/unionfind_interfaces.py
--rw-r--r--  2.0 unx    53727 b- defN 23-May-25 14:18 plaquette/errors/__init__.py
--rw-r--r--  2.0 unx    85438 b- defN 23-May-25 14:18 plaquette/frontend/__init__.py
--rw-r--r--  2.0 unx    11219 b- defN 23-May-26 06:07 plaquette/frontend/schemas.py
--rw-r--r--  2.0 unx    12486 b- defN 23-May-25 14:18 plaquette/simulator/__init__.py
--rw-r--r--  2.0 unx     9531 b- defN 23-May-25 14:18 plaquette/simulator/circuitsim.py
--rw-r--r--  2.0 unx     6922 b- defN 23-May-25 14:18 plaquette/simulator/stimsim.py
--rw-r--r--  2.0 unx    46285 b- defN 23-May-25 14:18 plaquette/syngraph/__init__.py
--rw-r--r--  2.0 unx     8397 b- defN 23-May-25 14:18 plaquette/syngraph/weights.py
--rw-r--r--  2.0 unx    17643 b- defN 23-May-25 14:18 plaquette/visualizer/__init__.py
--rw-r--r--  2.0 unx     3683 b- defN 23-May-26 07:03 plaquette-0.0.1a0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-26 07:03 plaquette-0.0.1a0.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-May-26 07:03 plaquette-0.0.1a0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2602 b- defN 23-May-26 07:03 plaquette-0.0.1a0.dist-info/RECORD
-30 files, 491766 bytes uncompressed, 120225 bytes compressed:  75.6%
+Zip file size: 130681 bytes, number of entries: 32
+-rw-r--r--  2.0 unx     1659 b- defN 23-May-26 16:59 plaquette/__init__.py
+-rw-r--r--  2.0 unx      225 b- defN 23-May-26 16:59 plaquette/__main__.py
+-rw-r--r--  2.0 unx    54561 b- defN 23-May-26 16:59 plaquette/pauli.py
+-rw-r--r--  2.0 unx    11292 b- defN 23-May-26 16:59 plaquette/circuit/__init__.py
+-rw-r--r--  2.0 unx    17656 b- defN 23-May-26 16:59 plaquette/circuit/generator.py
+-rw-r--r--  2.0 unx     3572 b- defN 23-May-26 16:59 plaquette/circuit/openqasm.py
+-rw-r--r--  2.0 unx    13863 b- defN 23-May-26 16:59 plaquette/codes/__init__.py
+-rw-r--r--  2.0 unx    36704 b- defN 23-May-26 16:59 plaquette/codes/latticebase.py
+-rw-r--r--  2.0 unx    10509 b- defN 23-May-26 16:59 plaquette/codes/latticeinstances.py
+-rw-r--r--  2.0 unx     3563 b- defN 23-May-26 16:59 plaquette/decoders/__init__.py
+-rw-r--r--  2.0 unx    16391 b- defN 23-May-26 16:59 plaquette/decoders/decoderbase.py
+-rw-r--r--  2.0 unx     4267 b- defN 23-May-26 16:59 plaquette/decoders/fusionblossom.py
+-rw-r--r--  2.0 unx     1788 b- defN 23-May-26 16:59 plaquette/decoders/interfaces.py
+-rw-r--r--  2.0 unx     4336 b- defN 23-May-26 16:59 plaquette/decoders/matching.py
+-rw-r--r--  2.0 unx    28683 b- defN 23-May-26 16:59 plaquette/decoders/unionfind_decoder.py
+-rw-r--r--  2.0 unx    20750 b- defN 23-May-26 16:59 plaquette/decoders/unionfind_erasure.py
+-rw-r--r--  2.0 unx     4102 b- defN 23-May-26 16:59 plaquette/decoders/unionfind_interfaces.py
+-rw-r--r--  2.0 unx    19499 b- defN 23-May-26 16:59 plaquette/device/__init__.py
+-rw-r--r--  2.0 unx     9128 b- defN 23-May-26 16:59 plaquette/device/_circuitsim.py
+-rw-r--r--  2.0 unx     7232 b- defN 23-May-26 16:59 plaquette/device/_stimsim.py
+-rw-r--r--  2.0 unx    53727 b- defN 23-May-26 16:59 plaquette/errors/__init__.py
+-rw-r--r--  2.0 unx    84819 b- defN 23-May-26 16:59 plaquette/frontend/__init__.py
+-rw-r--r--  2.0 unx    11199 b- defN 23-May-26 16:59 plaquette/frontend/schemas.py
+-rw-r--r--  2.0 unx    46285 b- defN 23-May-26 16:59 plaquette/syngraph/__init__.py
+-rw-r--r--  2.0 unx     8397 b- defN 23-May-26 16:59 plaquette/syngraph/weights.py
+-rw-r--r--  2.0 unx    17643 b- defN 23-May-26 16:59 plaquette/visualizer/__init__.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3774 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/WHEEL
+-rw-r--r--  2.0 unx      123 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2788 b- defN 23-May-26 16:59 plaquette-0.0.1a1.dist-info/RECORD
+32 files, 509994 bytes uncompressed, 126211 bytes compressed:  75.3%
```

## zipnote {}

```diff
@@ -45,47 +45,53 @@
 
 Filename: plaquette/decoders/unionfind_erasure.py
 Comment: 
 
 Filename: plaquette/decoders/unionfind_interfaces.py
 Comment: 
 
-Filename: plaquette/errors/__init__.py
+Filename: plaquette/device/__init__.py
 Comment: 
 
-Filename: plaquette/frontend/__init__.py
+Filename: plaquette/device/_circuitsim.py
 Comment: 
 
-Filename: plaquette/frontend/schemas.py
+Filename: plaquette/device/_stimsim.py
 Comment: 
 
-Filename: plaquette/simulator/__init__.py
+Filename: plaquette/errors/__init__.py
 Comment: 
 
-Filename: plaquette/simulator/circuitsim.py
+Filename: plaquette/frontend/__init__.py
 Comment: 
 
-Filename: plaquette/simulator/stimsim.py
+Filename: plaquette/frontend/schemas.py
 Comment: 
 
 Filename: plaquette/syngraph/__init__.py
 Comment: 
 
 Filename: plaquette/syngraph/weights.py
 Comment: 
 
 Filename: plaquette/visualizer/__init__.py
 Comment: 
 
-Filename: plaquette-0.0.1a0.dist-info/METADATA
+Filename: plaquette-0.0.1a1.dist-info/LICENSE
+Comment: 
+
+Filename: plaquette-0.0.1a1.dist-info/METADATA
+Comment: 
+
+Filename: plaquette-0.0.1a1.dist-info/WHEEL
 Comment: 
 
-Filename: plaquette-0.0.1a0.dist-info/WHEEL
+Filename: plaquette-0.0.1a1.dist-info/entry_points.txt
 Comment: 
 
-Filename: plaquette-0.0.1a0.dist-info/top_level.txt
+Filename: plaquette-0.0.1a1.dist-info/top_level.txt
 Comment: 
 
-Filename: plaquette-0.0.1a0.dist-info/RECORD
+Filename: plaquette-0.0.1a1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## plaquette/__init__.py

```diff
@@ -8,27 +8,29 @@
 
 For a quick walk-through of the most important parts of the API, see
 :doc:`/quickstart`.
 
 The frontend comprises :mod:`plaquette.codes` and :mod:`plaquette.circuit`, which allow
 designing new error correction codes or specifying built-in ones,
 and :mod:`plaquette.errors` which provides a fine-grained interface for specifying
-hardware imperfections. The quantum device is mimicked by :mod:`plaquette.simulator`
+hardware imperfections. The quantum device is mimicked by :mod:`plaquette.device`
 and the classical control for finding and correcting errors is provided by
 :mod:`plaquette.decoders`, which internally uses :mod:`plaquette.syngraph`. A
 set of helper tools for visualising codes and simulation results can be found
 in :mod:`plaquette.visualizer`. Finally, the underlying
 "tableau-representation" is implemented by the :mod:`plaquette.pauli`.
 """
 
 import sys
 
 import numpy as np
 
-__version__ = "0.0.1a"
+from plaquette.device import Device  # noqa: F401
+
+__version__ = "0.0.1a1"
 
 #: Random number generator (specifically :func:`numpy.random.Generator.default_rng`)
 #:
 #: To use your own, or to make your simulations deterministic (by using a fixed
 #: seed), you can replace this module variable **before** calling any other function
 #: or class in the package.
 rng = np.random.default_rng()
```

## plaquette/circuit/__init__.py

```diff
@@ -50,20 +50,21 @@
     E_ERASE 0.0 4
     E_ERASE 1.0 5
     R 5
     M 0 1 2 3 4 5
 
     In order to build circuits step-by-step, :class:`CircuitBuilder` can be useful.
 
-    The circuit can be simulated using :mod:`plaquette.simulator` module to obtain the
+    The circuit can be simulated using :mod:`plaquette.device` module to obtain the
     measurement outcomes along with information about errors as follows:
 
-    >>> from plaquette.simulator import circuitsim
-    >>> sim = circuitsim.CircuitSimulator(circ)
-    >>> measurements, erasure = sim.get_sample()
+    >>> from plaquette import Device
+    >>> dev = Device("clifford")
+    >>> dev.run(circ)
+    >>> measurements, erasure = dev.get_sample()
     >>> measurements
     array([0, 0, 0, 1, 1, 0], dtype=uint8)
     >>> erasure
     array([False,  True])
 
     .. todo::
```

## plaquette/circuit/generator.py

```diff
@@ -13,15 +13,15 @@
     ErrorData,
     ErrorDataDict,
     GateErrorsDict,
     QubitErrorsDict,
 )
 from plaquette.pauli import commutator_sign
 
-# TODO: The code here is closer in functionality and concept to simulator.circuitsim
+# TODO: The code here is closer in functionality and concept to simulator._circuitsim
 
 
 class QECCircuitGenerator:
     """Generate Clifford circuit for QEC simulations.
 
     This class can be used to generate a circuit which performs quantum error
     correction. For this purpose, it needs information about the code, the errors
@@ -323,32 +323,32 @@
                 self.apply_measurement_error(op)
             self.apply_gate_and_error("M", ancilla, None, with_errors)
 
     def get_circuit(self, logical_ops: str | Sequence[int]) -> circuit.Circuit:
         """Build circuit for simulating QEC on the given error model.
 
         This function returns a circuit which can be simulated (see
-        :mod:`plaquette.simulator`). If the circuit is simulated, it returns the
+        :mod:`plaquette.device`). If the circuit is simulated, it returns the
         sequence of measurement outcomes described in
-        :meth:`plaquette.simulator.AbstractSimulator.get_sample`.
+        :meth:`plaquette.device.AbstractSimulator.get_sample`.
 
         Args:
             logical_ops: Specifies which logical operators should be measured before
                 and after the QEC simulation.
 
                 * E.g. ``XZ`` specifies logical ``X`` on the first and logical ``Z``
                   on the second logical qubit.
                 * ``[0, 3]`` specifies the same as ``XZ`` because indices refer to
                   ``logical_ops`` in :attr:`stabcode`.
 
                 For details, see
                 :meth:`plaquette.codes.StabilizerCode.logical_ops_to_indices`.
 
         Returns:
-            A Clifford circuit (to be simulated with :mod:`plaquette.simulator`)
+            A Clifford circuit (to be simulated with :mod:`plaquette.device`)
         """
         logop_indices = self.stabcode.logical_ops_to_indices(logical_ops)
         # Check that different logical operators commute (if there is more than one).
         # (Measuring e.g. X_1 and Z_2 is fine, but we want to prevent e.g.
         # measuring X_1 and X_2.)
         logical_ops_op = [self.stabcode.logical_ops[i] for i in logop_indices]
         lcomm = commutator_sign(logical_ops_op, logical_ops_op)
@@ -380,18 +380,20 @@
     logical_ancilla: bool = False,
 ) -> circuit.Circuit:
     """Shorthand for generating a circuit for QEC simulations.
 
     This function takes as input: An error correction code, information about errors
     and information about the logical operators of interest. Using this information,
     this function generates a circuit (as described in :ref:`circuits-ref`). This
-    circuit can then be simulated by :mod:`plaquette.simulator`.
+    circuit can then be simulated by :mod:`plaquette.device`.
 
     .. important:: This function doesn't actually simulate the circuit! That's
-       the simulator's job, e.g. :class:`.CircuitSimulator`.
+       the job of the device that uses an underlying backend to perform the
+       simulation, e.g. :class:`.CircuitSimulator` when choosing the
+       ``"clifford"`` backend.
 
     Args:
         code: Definition of the error correction code
         qubit_errordata: Defintion of the qubit errors
         gate_errordata: Definition of the gate errors
         logical_ops: Specifies which logical operators should be measured before
             and after the QEC simulation.
@@ -403,15 +405,15 @@
             * ``[0, 3]`` specifies the same as ``XZ`` because indices refer to
               :attr:`~plaquette.codes.StabilizerCode.logical_ops`.
 
             For details, see
             :meth:`plaquette.codes.StabilizerCode.logical_ops_to_indices`.
 
     Returns:
-        A Clifford circuit (to be simulated with :mod:`plaquette.simulator`)
+        A Clifford circuit (to be simulated with :mod:`plaquette.device`)
 
     This function is a shorthand for::
 
        QECCircuitGenerator(code, errordata).get_circuit(logical_ops)
 
     See :attr:`QECCircuitGenerator.get_circuit` for a description of the measurement
     outcomes obtained if the circuit returned by this function is simulated.
@@ -424,15 +426,15 @@
         >>> ged = errors.GateErrorsDict()
         >>> # The planar code has one logical qubit. We choose logical X.
         >>> log_ops = "X"
         >>> circ = generate_qec_circuit(c, qed, ged, log_ops)
         >>> print(type(circ))
         <class 'plaquette.circuit.Circuit'>
 
-        The resulting circuit can be simulated using :mod:`plaquette.simulator`. The
+        The resulting circuit can be simulated using :mod:`plaquette.device`. The
         example above does not define any errors, see :mod:`plaquette.errors` for that
         matter.
     """
     circ_gen = QECCircuitGenerator(
         code, qubit_errordata, gate_errordata, logical_ancilla
     )
     return circ_gen.get_circuit(logical_ops)
```

## plaquette/decoders/decoderbase.py

```diff
@@ -105,22 +105,24 @@
     * Measurement results from circuit simulation (``k`` logical ops. simulated)
     * Measurement results from code space simulation (``2*k`` logical ops. simulated)
 
     Example:
         .. code::
 
             from plaquette import codes, circuit, decoders, errors, simulator, utils
+            from plaquette import Device
 
             code = codes.PlanarCode(n_rounds=1, size=3)
             errordata = errors.ErrorData()
             errordata.update_all(code, {"pauli_1": {"p_x": 0.01, "p_z": 0.08}})
 
             circ = circuit.generate_qec_circuit(code, errordata, logical_ops="Z")
-            sim = simulator.CircuitSimulator(circ)
-            sample = sim.get_sample()
+            dev = Device("clifford")
+            dev.run(circ)
+            sample = dev.get_sample()
 
             results = utils.split_measurement_results(code, sample)
 
             dec = decoders.UnionFindDecoder.from_code(code, errordata, weighted=False)
             correction = dec.decode(results.qubits_erased, results.syndrome)
             success = decoders.check_success(
                 code, correction, results.logical_op_toggle, logical_ops="Z"
```

## plaquette/frontend/__init__.py

```diff
@@ -12,24 +12,22 @@
 
 import numpy as np
 import toml  # type: ignore
 from jsonschema import validate
 from tqdm import tqdm
 
 import plaquette
-from plaquette import decoders, visualizer
+from plaquette import Device, decoders, visualizer
 from plaquette.circuit import Circuit, generator
 from plaquette.codes import LatticeCode
 from plaquette.codes.latticebase import CodeLattice
 from plaquette.decoders.decoderbase import check_success
+from plaquette.device import AbstractSimulator, MeasurementSample
 from plaquette.errors import ErrorData, generate_empty_qubit_errors_csv
 from plaquette.frontend import schemas
-from plaquette.simulator import AbstractSimulator, SimulatorSample
-from plaquette.simulator.circuitsim import CircuitSimulator
-from plaquette.simulator.stimsim import StimSimulator
 
 
 def _validate_filepath(filepath: str, load_file: bool) -> bool:
     """Validate given filepath by checking if file exists or can be created there.
 
     Args:
         filepath: The path to the file
@@ -1559,54 +1557,53 @@
                 errors.gate_errors_dict,
                 logop_indices,
             )
         return ret_val
 
 
 @dataclass(kw_only=True)
-class SimulatorConfig:
-    """Class to store the configurations for the simulator.
+class DeviceConfig:
+    """Class to store the configurations for the device.
 
     Raises:
-        ValueError: The simulator name not one of the supported ones.
+        ValueError: The device name not one of the supported ones.
         ValueError: Shots is not a positive integer.
 
     Examples:
-        >>> conf = SimulatorConfig(name = "CircuitSimulator", shots =1024)
+        >>> conf = DeviceConfig(name = "clifford", shots =1024)
         >>> print(conf)
-        SimulatorConfig(name='CircuitSimulator', shots=1024)
+        DeviceConfig(name='clifford', shots=1024)
     """
 
-    name: str = field(default="CircuitSimulator")
-    """ The name of the simulator.
+    name: str = field(default="clifford")
+    """ The name of the backend to use with the device.
 
-    Valid names are :class:`.CircuitSimulator` and :class:`.StimSimulator`.
-    Defaults to :class:`~.CircuitSimulator`.
+    Valid names for local simulators are ``"clifford"`` and ``"stim"``.
+    Defaults to ``"clifford"`` that uses :class:`~.CircuitSimulator`.
     """
 
     shots: int = field(default=1024)
     """Number of shots for the simulation.
 
     Must be a positive integer. Defaults to 1024.
     """
 
-    VALID_SIMULATORS: ClassVar[tuple[str, ...]] = (
-        "CircuitSimulator",
-        "StimSimulator",
+    VALID_SIMULATORS: ClassVar[tuple[str, ...]] = tuple(
+        plaquette.device.recognized_devices
     )
     """
     :meta private:
     """
 
     def __post_init__(self):
-        """Make sure we are not using an unsupported simulator."""
+        """Make sure we are not using an unsupported device."""
         if self.name not in self.VALID_SIMULATORS:
-            raise ValueError(f"{self.name} is not a valid simulator name")
+            raise ValueError(f"{self.name} is not a valid device name")
         if not (isinstance(self.shots, int) and self.shots > 0):
-            raise ValueError(f"simulator.shots = {self.shots} must be an integer")
+            raise ValueError(f"device.shots = {self.shots} must be an integer")
 
     def __str__(self):  # noqa: D105
         return pformat(self)
 
     def update(self, **kwargs):
         """Update class attributes with given ``**kwargs``.
 
@@ -1617,60 +1614,50 @@
             None, updates in-place.
         """
         for key, value in kwargs.items():
             if hasattr(self, key):
                 setattr(self, key, value)
 
     @classmethod
-    def from_dict(cls, config_dict: dict) -> SimulatorConfig:
-        """Instantiate :class:`~SimulatorConfig` object from config dictionary.
+    def from_dict(cls, config_dict: dict) -> DeviceConfig:
+        """Instantiate :class:`~DeviceConfig` object from config dictionary.
 
         Args:
             config_dict: Any class attribute.
 
         Returns:
-            A :class:`~SimulatorConfig` object.
+            A :class:`~DeviceConfig` object.
         """
-        config_dict.setdefault("name", "CircuitSimulator")
+        config_dict.setdefault("name", "clifford")
         config_dict.setdefault("shots", 1024)
         return cls(
             name=cast(str, config_dict.get("name")),
             shots=cast(int, config_dict.get("shots")),
         )
 
     def as_dict(self) -> dict[str, str]:
         """Return class attributes as dictionary.
 
         Returns:
             A dictionary of the configuration for the code.
         """
         return asdict(self)
 
-    def instantiate(
-        self, circuit: Circuit, **kwargs
-    ) -> Union[StimSimulator, CircuitSimulator]:
-        """Instantiate a ``Simulator`` object with the objects' config.
+    def instantiate(self, **kwargs) -> Device:
+        """Instantiate a ``Device`` with the chosen backend using the objects' config.
 
         Args:
-            circuit : The circuit to simulate
-            kwargs: Passed on to :class:`~StimSimulator`.
+            kwargs: Passed on when the backend is ``"stim"``.
 
         Returns:
-            A :class:`~StimSimulator` or :class:`~.CircuitSimulator` object.
+            A :class:`~Device` object.
         """
-        ret_val: Union[StimSimulator, CircuitSimulator]
-        match self.name:
-            case "StimSimulator":
-                ret_val = StimSimulator(circuit, **kwargs)
-            case "CircuitSimulator":
-                ret_val = CircuitSimulator(circuit)
-            case _:
-                raise AttributeError(f"{self.name} is an invalid simulator!")
-
-        return ret_val
+        if self.name in tuple(plaquette.device.recognized_devices):
+            return Device(self.name, **kwargs)
+        raise AttributeError(f"{self.name} is an invalid device!")
 
 
 @dataclass(kw_only=True)
 class DecoderConfig:
     """Class to store the config of the decoder.
 
     Raises:
@@ -1816,18 +1803,18 @@
     general_conf: GeneralConfig = field(
         default_factory=lambda: GeneralConfig(
             logical_op="X", qec_property=["logical_error_rate"], seed=12345
         )
     )
     """Generic configurations for the experiment of the :class:`~GeneralConfig`."""
 
-    simulator_conf: SimulatorConfig = field(default_factory=lambda: SimulatorConfig())
-    """Configuration of the simulator in the experiment.
+    device_conf: DeviceConfig = field(default_factory=lambda: DeviceConfig())
+    """Configuration of the device in the experiment.
 
-    Defaults to a :class:`~SimulatorConfig` object with default values.
+    Defaults to a :class:`~DeviceConfig` object with default values.
     """
 
     circuit_conf: CircuitConfig = field(default_factory=lambda: CircuitConfig())
     """Configuration of the circuit in the experiment.
 
     Defaults to a :class:`~CircuitConfig` object with default values.
     """
@@ -1836,15 +1823,15 @@
     """Configuration of the decoder in the experiment.
 
     Defaults to an :class:`~DecoderConfig` object with default values.
     """
 
     _code: LatticeCode | None = None
     _errors: ErrorData | None = None
-    _simulator: Type[AbstractSimulator] | None = None
+    _device: Type[AbstractSimulator] | None = None
     _circuit: Circuit | None = None
     _decoder: Type[decoders.DecoderInterface] | None = None
 
     def update_rng(self):  # noqa: D102
         plaquette.rng = np.random.default_rng(seed=self.general_conf["seed"])
 
     @property
@@ -1871,22 +1858,22 @@
             raise ValueError(
                 "Circuit has not been instantiated yet, use build() or "
                 + "build_circuit() method to do so!"
             )
         return cast(Circuit, self._circuit)
 
     @property
-    def simulator(self):
+    def device(self):
         """The built :class:`~.AbstractSimulator` object in the experiment."""
         if self._circuit is None:
             raise ValueError(
                 "Simulator has not been instantiated yet, use build() or "
-                + "build_simulator() method to do so!"
+                + "build_device() method to do so!"
             )
-        return self._simulator
+        return self._device
 
     @property
     def decoder(self):
         """The built ``Decoder`` object in the experiment."""
         if self._decoder is None:
             raise ValueError(
                 "Decoder has not been instantiated yet, use build() or "
@@ -1912,17 +1899,17 @@
 
             [general]
             logical_op = "Z" # the logical operator to measure
             qec_property = ["logical_error_rate"] # The QEC property to measure, now
                                                   # only logical_error_rate is possible
             seed = 123124 # the seed for the random number generator
 
-            [simulator]
-            name = "StimSimulator" # The simulator to use,
-            shots = 10000 # the number of shots to run the simulator for
+            [device]
+            name = "stim" # The device to use,
+            shots = 10000 # the number of shots to run the device for
 
             [code]
             name = "RotatedPlanarCode" # The code to use.
             size = 3 # The size of the code
             rounds = 10 # The number rounds of syndrome measurement per QEC cycle
 
             [circuit]
@@ -2096,27 +2083,25 @@
                     }
                 },
                 'general': {
                     'logical_op': 'Z',
                     'qec_property': ['logical_error_rate'],
                     'seed': 123124
                 },
-                'simulator': {'name': 'StimSimulator', 'shots': 10000}
+                'device': {'name': 'stim', 'shots': 10000}
             }
         """  # noqa
-        config_dict.setdefault("simulator", {})
+        config_dict.setdefault("device", {})
         config_dict.setdefault("errors", {})
         config_dict.setdefault("decoder", {})
         config_dict.setdefault("circuit", {})
         config_dict.setdefault("code", {})
         return cls(
             general_conf=cast(GeneralConfig, config_dict.get("general")),
-            simulator_conf=SimulatorConfig.from_dict(
-                cast(dict, config_dict.get("simulator"))
-            ),
+            device_conf=DeviceConfig.from_dict(cast(dict, config_dict.get("device"))),
             circuit_conf=CircuitConfig.from_dict(
                 cast(dict, config_dict.get("circuit"))
             ),
             code_conf=CodeConfig.from_dict(cast(dict, config_dict.get("code"))),
             errors_conf=ErrorsConfig.from_dict(cast(dict, config_dict.get("errors"))),
             decoder_conf=DecoderConfig.from_dict(
                 cast(dict, config_dict.get("decoder"))
@@ -2162,15 +2147,15 @@
         This method will call the relevant classes from :mod:`plaquette` and generate
         the different objects required for performing the simulation.
         """
         self.update_rng()
         self.build_code()
         self.build_errors()
         self.build_circuit()
-        self.build_simulator()
+        self.build_device()
         self.build_decoder()
 
     def build_code(self) -> None:
         """Build the :class:`.LatticeCode` object.
 
         Built object is accessible through :class:`ExperimentConfig.code`
 
@@ -2201,29 +2186,27 @@
         """
         self._circuit = self.circuit_conf.instantiate(
             self._code,
             self._errors,
             self.general_conf["logical_op"],
         )
 
-    def build_simulator(self, **kwargs) -> None:
+    def build_device(self, **kwargs) -> None:
         """Build the `Circuit` object.
 
         Built object is accessible through :class:`~ExperimentConfig.circuit`
 
         Keyword Args:
-            batch_size: if using StimSimulator, defaults to 1024.
-            kwargs: keyword arguments to :meth:`.SimulatorConfig.instantiate`.
+            batch_size: if using Stim as the backend, defaults to 1024.
+            kwargs: keyword arguments to :meth:`.DeviceConfig.instantiate`.
 
         Returns:
             None, updates :attr:`~ExperimentConfig.circuit`.
         """
-        self._simulator = self.simulator_conf.instantiate(
-            cast(Circuit, self._circuit), **kwargs
-        )  # type: ignore
+        self._device = self.device_conf.instantiate(**kwargs)  # type: ignore
 
     def build_decoder(self) -> None:
         """Build the `Decoder` object.
 
         Built object is accessible through :class:`~ExperimentConfig.decoder`
 
         Returns:
@@ -2269,22 +2252,20 @@
         """Run an experiment to get a logical error rate.
 
         In a threshold plot, a single :class:`ExperimentConfig` gives a single data
         point on the plot. See :ref:`declarative-guide` for an example.
         """
         match self.general_conf["qec_property"]:
             case ["logical_error_rate"]:
-                if isinstance(
-                    self._simulator,
-                    (CircuitSimulator, StimSimulator),
-                ):
-                    test_success = np.zeros([self.simulator_conf.shots], dtype=bool)
-                    for i in tqdm(range(self.simulator_conf.shots)):
-                        raw, erasure = self._simulator.get_sample()
-                        results = SimulatorSample.from_code_and_raw_results(
+                if self._device._backend_class in plaquette.device.local_simulators:
+                    test_success = np.zeros([self.device_conf.shots], dtype=bool)
+                    for i in tqdm(range(self.device_conf.shots)):
+                        self._device.run(cast(Circuit, self._circuit))
+                        raw, erasure = self._device.get_sample()
+                        results = MeasurementSample.from_code_and_raw_results(
                             self._code, raw, erasure
                         )
                         correction = self._decoder.decode(
                             results.erased_qubits, results.syndrome
                         )
                         test_success[i] = check_success(
                             self._code,
```

## plaquette/frontend/schemas.py

```diff
@@ -29,22 +29,22 @@
                     },
                     "seed": {
                         "type": "integer"
                     }
                 },
                 "required": ["logical_op", "qec_property", "seed"]
             },
-            "simulator": {
+            "device": {
                 "type": "object",
                 "properties": {
                     "name": {
                         "type": "string",
                         "enum": [
-                        "StimSimulator",
-                        "CircuitSimulator"
+                        "stim",
+                        "clifford"
                         ]
                     },
                     "shots": {
                         "type": "integer",
                         "minimum": 1,
                         "maximum": 1000000
                     }
```

## Comparing `plaquette/simulator/circuitsim.py` & `plaquette/device/_circuitsim.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 """Convenient QEC simulations based on Clifford circuits."""
 import typing as t
 from collections.abc import Sequence
 
 import numpy as np
 
 import plaquette
-from plaquette import circuit, pauli, simulator
+from plaquette import circuit, device, pauli
 
 
-class CircuitSimulator(simulator.AbstractSimulator):
+class CircuitSimulator(device.AbstractSimulator):
     """QEC simulation based on Clifford circuits.
 
     This class provides a pure-Python tableau-based simulator which uses the
     representation of a stabilizer state introduced in :cite:`aaronson_improved_2004`.
 
     For a faster simulator based on a third-party package, see
-    :class:`~plaquette.simulator.stimsim.StimSimulator`.
+    :class:`~plaquette.device._stimsim.StimSimulator`.
 
     .. automethod:: __init__
     """
 
     def __init__(self, circ: circuit.Circuit | circuit.CircuitBuilder):
         """Create a new simulator.
 
@@ -33,15 +33,15 @@
         elif isinstance(circ, circuit.Circuit):
             self.circ = circ
         else:
             raise TypeError(
                 "Only a Circuit or a CircuitBuilder can be used in a simulator"
             )
         #: State object
-        self.state: simulator.QuantumState = simulator.QuantumState(
+        self.state: device.QuantumState = device.QuantumState(
             self.circ.number_of_qubits
         )
         #: Measurement results collected while running the circuit
         self.meas_results: list[int] = []
         #: Erasure information (one bool for each ``E_ERASE`` instruction).
         self.erasure: list[bool] = []
         #: Specifies whether the last instruction was an error instruction
@@ -195,46 +195,41 @@
         """Run a single gate."""
         if name.startswith("ERROR"):
             self._handle_error(name, args)
         else:
             self.in_error = False
             self._handle_gate(name, args)
 
-    def _run_circuit(self, reset=True):
-        """Run a circuit in the simulator.
+    def run(self, *, after_reset=True):  # noqa: D102
+        if after_reset:
+            self.reset()
+
+        for _ in self:
+            # Go through all instructions
+            pass
 
-        Args:
-            reset: if ``True``, the internal :class:`~simulator.QuantumState` will be
-                reset to the "canonical form" (i.e. the identity matrix + the all-zero
-                column vector for the sign bit).
-        """
-        if reset:
-            # The STATE needs to be linked to the number of qubits OF THE CIRCUIT,
-            # such that then self.n_qubits has the correct info. If we delete qubits
-            # from the state, and then here we call QuantumState(self.n_qubits) this
-            # number is going to be LESS than the necessary amount of qubits, because
-            # self.n_qubits depends on the STATE.
-            #
-            # This can be changed, I don't if it's a problem or source of confusion.
-            self.state = simulator.QuantumState(self.circ.number_of_qubits)
-            self.meas_results = []
-            self.erasure = []
-        for name, args in self.circ.gates:
-            self._run_gate(name, args)
-
-    def get_sample(
-        self, *, after_reset=True
+    def process_results(  # noqa: D102
+        self,
     ) -> tuple[np.ndarray, t.Optional[np.ndarray]]:
-        """Draw a new sample from the given circuit.
-
-        Keyword Args:
-            after_reset: if ``False``, the returned measurement and erasures will still
-                contain any data from previous runs. Otherwise, both these results and
-                the internal state will be reset.
-        """
-        self._run_circuit(after_reset)
-        meas = np.array(self.meas_results, dtype="u1")
         if len(self.erasure) > 0:
             qubits_erased = np.array(self.erasure)
         else:
             qubits_erased = None
-        return meas, qubits_erased
+        return np.array(self.meas_results, dtype="u1"), qubits_erased
+
+    def reset(self):
+        """Reset the internal state of the simulator and its outputs.
+
+        Notes:
+            This will create a completely new :class:`.QuantumState` and clear
+            the attributes :attr:`meas_results` and :attr:`erasure`.
+        """
+        # The STATE needs to be linked to the number of qubits OF THE CIRCUIT,
+        # such that then self.n_qubits has the correct info. If we delete qubits
+        # from the state, and then here we call QuantumState(self.n_qubits) this
+        # number is going to be LESS than the necessary amount of qubits, because
+        # self.n_qubits depends on the STATE.
+        #
+        # This can be changed, I don't know if it's a problem or source of confusion.
+        self.state = device.QuantumState(self.circ.number_of_qubits)
+        self.meas_results = []
+        self.erasure = []
```

## Comparing `plaquette/simulator/stimsim.py` & `plaquette/device/_stimsim.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # Copyright 2023, It'sQ GmbH and the plaquette contributors
 # SPDX-License-Identifier: Apache-2.0
 """Interface to Stim for use as circuit simulator.
 
 Stim is available from https://github.com/quantumlib/Stim (Apache 2.0 license).
 """
 
+import typing as t
 from typing import Optional
 
 import numpy as np
 import stim  # type: ignore
 
 import plaquette
-from plaquette import circuit, simulator
+from plaquette import circuit, device
 
 
 def _append_equiprobable(circ: stim.Circuit, p: float, steps):
     """Helper function for adding equiprobable cases to Stim circuit."""
     for i, step in enumerate(steps):
         gate = ("ELSE_" if i > 0 else "") + "CORRELATED_ERROR"
         p_i = p / (1 - i * p)
@@ -87,15 +88,15 @@
                 else:
                     raise ValueError(f"ERROR ... {name!r} not supported yet")
             case "ERROR_ELSE" | "ERROR_CONTINUE":
                 raise ValueError(f"{name!r} not supported yet")
     return res, meas_is_erasure
 
 
-class StimSimulator(simulator.AbstractSimulator):
+class StimSimulator(device.AbstractSimulator):
     """Circuit simulator using Stim as backend.
 
     .. automethod:: __init__
     """
 
     #: The circuit
     circ: circuit.Circuit
@@ -145,36 +146,46 @@
             )
         self.batch_size = batch_size
         # Convert the circuit to Stim format. A sampler is not built until an RNG
         # is supplied.
         self.stim_circ, is_erasure = circuit_to_stim(self.circ)
         self.meas_is_erasure = np.array(is_erasure)
         if stim_seed is None:
-            stim_seed = plaquette.rng.integers(0, 2**63)
-        self._compile_stim_sampler(stim_seed)
+            self.stim_seed = plaquette.rng.integers(0, 2**63)
+        else:
+            self.stim_seed = stim_seed
+        self.reset()
+
+    def reset(self, new_seed: Optional[int] = None):
+        """Compile a new Stim sampler.
 
-    def _compile_stim_sampler(self, stim_seed: int):
-        """Compile a stim sampler."""
-        self.stim_seed = stim_seed
-        self.stim_sampler = self.stim_circ.compile_sampler(seed=stim_seed)
+        Args:
+            new_seed: if not ``None``, this will be set to :attr:`stim_seed`
+                and used to build the new sampler.
+        """
+        if new_seed is not None:
+            self.stim_seed = new_seed
+        self.stim_sampler = self.stim_circ.compile_sampler(seed=self.stim_seed)
         # Erase current batch (if any)
         self.batch = None
         self.batch_remaining = 0
 
-    def get_sample(  # noqa: D102
-        self, *, after_reset=True
-    ) -> tuple[np.ndarray, np.ndarray]:
+    def run(self, *, after_reset=True):  # noqa: D102
         # Sample a new match if necessary.
         if not after_reset:
             raise ValueError("Stim does not allow sampling without resetting")
         if self.batch_remaining == 0:
             self.batch = self.stim_sampler.sample(shots=self.batch_size)
             self.batch_remaining = self.batch_size
         assert self.batch is not None
-        all_meas = self.batch[-self.batch_remaining]
+        self.all_meas = self.batch[-self.batch_remaining]
         self.batch_remaining -= 1
+
+    def process_results(  # noqa: D102
+        self,
+    ) -> tuple[np.ndarray, t.Optional[np.ndarray]]:
         # Split results into actual measurements and erasure indications
-        meas = all_meas[~self.meas_is_erasure]
-        qubits_erased = all_meas[self.meas_is_erasure]
+        meas = self.all_meas[~self.meas_is_erasure]
+        qubits_erased = self.all_meas[self.meas_is_erasure]
         if len(qubits_erased) == 0:
             qubits_erased = None
         return meas, qubits_erased
```

## Comparing `plaquette-0.0.1a0.dist-info/METADATA` & `plaquette-0.0.1a1.dist-info/METADATA`

 * *Files 16% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 Metadata-Version: 2.1
 Name: plaquette
-Version: 0.0.1a0
+Version: 0.0.1a1
 Summary: An all-encompassing quantum error-correction software package
 Author-email: It'sQ GmbH <software@qc.design>
 Project-URL: Homepage, https://docs.plaquette.design
 Project-URL: Bug Tracker, https://github.com/qc-design/plaquette/issues
 Keywords: Quantum error correction,qec,quantum computing,fault tolerance
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Natural Language :: English
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Requires-Python: >=3.10
 Description-Content-Type: text/x-rst
+License-File: LICENSE
 Requires-Dist: fusion-blossom (>=0.2.2)
 Requires-Dist: jsonschema (>=4.16)
 Requires-Dist: matplotlib (>=3.6.2)
 Requires-Dist: numpy (~=1.24)
 Requires-Dist: pandas (>=1.5.1)
 Requires-Dist: plotly (>=5.11.0)
 Requires-Dist: pymatching (>=2.0.1)
@@ -30,14 +31,18 @@
 Requires-Dist: stim (>=1.10.0)
 Requires-Dist: toml (>=0.10)
 Requires-Dist: tqdm
 
 ``plaquette``: all-encompassing quantum error-correction software
 =================================================================
 
+.. image:: https://readthedocs.org/projects/plaquette-qec/badge/?version=latest
+    :target: https://docs.plaquette.design/en/stable/?badge=stable
+    :alt: Documentation Status
+
 ``plaquette`` is a fully featured and easy-to-use library for studying quantum
 error correction and fault tolerance.
 
 The library features numerous quantum error correction codes, hardware-relevant
 error models and versatile decoders that can be used together seamlessly,
 and it is tailored to  accommodate both newcomers and experienced users alike!
 
@@ -45,45 +50,45 @@
 rough corners in the meantime! This is also why currently the project is
 marked as "alpha" in the version specifier. Stay tuned. :)
 
 Installation
 ------------
 
 ``plaquette`` is a pure Python package, so it can be easily installed via
-``pip`` after you clone the repository::
+``pip``::
 
-   git clone git@github.com:qc-design/plaquette.git && cd plaquette && pip install .
+   pip install plaquette
 
 
 Documentation
 -------------
 
-Live pre-compiled documention is available
+Live pre-compiled documentation is available
 `here <https://docs.plaquette.design/>`_.
 
 Alternatively, the documentation can be built from the ``master`` branch by::
 
    cd docs
    make clean html
 
 and the build files will be available in the ``docs/_build/html`` directory.
 
 Need help? Want to contribute?
 ------------------------------
 
 ``plaquette`` is under heavy development, so it might have some rough corners that need
 polishing. If you encounter something you think (or the docs say) should work but does
-not, just open an `issue <https://github.com/qc-design/plaquette-mirror/issues/new>`_
+not, just open an `issue <https://github.com/qc-design/plaquette/issues/new>`_
 or, if you also want to share a solution, a
-`pull request <https://github.com/qc-design/plaquette-mirror/compare>`_! See
+`pull request <https://github.com/qc-design/plaquette/compare>`_! See
 our `development standard <https://docs.plaquette.design/dev/index.html>`_ to
 have an idea of how to match your suggestions to the codebase.
 
 Want to simply share feedback or you're unsure how to do something? Open a new
-`discussion <https://github.com/qc-design/plaquette-mirror/discussions/new/choose>`_!
+`discussion <https://github.com/qc-design/plaquette/discussions/new/choose>`_!
 
 
 Supporters
 ----------
 
 ``plaquette`` is developed and maintained by `QC Design <https://www.qc.design/>`_.
 ``plaquette`` is also supported by the German Ministry of Education and Research
```

## Comparing `plaquette-0.0.1a0.dist-info/RECORD` & `plaquette-0.0.1a1.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,30 +1,32 @@
-plaquette/__init__.py,sha256=YtNZLyy3VEQIenN4f-oxb9GaHzOIeiv02CY5oC3xhxc,1610
+plaquette/__init__.py,sha256=dbBc430aWQyK81s2t8yXWOpPtIsYGgHScsmtG9R2xVU,1659
 plaquette/__main__.py,sha256=MT11xQk4f1b9khCYuYMKj7GV-iSecYWofYheVahE7Ls,225
 plaquette/pauli.py,sha256=nHfIQzK6_Uw7iN7GNaKc2rxZDxJS4UD0j110HCYTvuI,54561
-plaquette/circuit/__init__.py,sha256=D9_PNoccj__7h_kH9LmOIW8PvdWyTWEoJp3fgCLF4Ss,11302
-plaquette/circuit/generator.py,sha256=LQidoPf8Z0yFl4q44xUP3eWkcSloE468tlUFVn9pnGE,17558
+plaquette/circuit/__init__.py,sha256=7h2PKs-_tJ3if--Tm1BMF_lwmbz5KCJMbDwLvxJtnkA,11292
+plaquette/circuit/generator.py,sha256=yu7e2Xymn1kPcnirD8vNvo7shiOvDAFd1NJnPTUVOq8,17656
 plaquette/circuit/openqasm.py,sha256=93uhPDNf8ni4T6DEB-WybkTi8Z57xWaj7oKkc6MMMCs,3572
 plaquette/codes/__init__.py,sha256=kynVGZKRTPlHxHi2zdTqWOY3M76ftQRNtoY4M2vLXC4,13863
 plaquette/codes/latticebase.py,sha256=jbfwkPa9hQMY39e8WcWCyIRxyxYvpRRxE_nUyTdokak,36704
 plaquette/codes/latticeinstances.py,sha256=t7kBlJsqAcJLPw2-fv4MHTIOXWfJDp88FFWIOypvy54,10509
 plaquette/decoders/__init__.py,sha256=jLcEmhCYzigSc7icmHq1XBUth4PIE_JYneaZ-Vjr7zo,3563
-plaquette/decoders/decoderbase.py,sha256=UY90IhxCzna5Sc6MSdq_bldOlhjteh9lC7bO6Yg-k5k,16338
+plaquette/decoders/decoderbase.py,sha256=dFooQ45gW6U4lavvv3TjuZT6ubJQ9Dq0ifvHS0CoFNo,16391
 plaquette/decoders/fusionblossom.py,sha256=T5OH0X4kbTYqrMBJ7N9Y6lFSKMK4FmPqsRPGpabPTEM,4267
 plaquette/decoders/interfaces.py,sha256=52d9jQkKilQoLC0DEKadra_YPtJyqWrsCD0TCZcnO_k,1788
 plaquette/decoders/matching.py,sha256=loJULUuyljaiYbsCL9RUMVbQoZ0aHfQCM35o7NdLd7c,4336
 plaquette/decoders/unionfind_decoder.py,sha256=sKFklzPmFa7vFGjuvLIMPZeAUWcog5-z9m_ke15Qha4,28683
 plaquette/decoders/unionfind_erasure.py,sha256=o5KNiB0i0Ogutn7-0NdtzJoZS-shK02cNGZ-7ptGwGE,20750
 plaquette/decoders/unionfind_interfaces.py,sha256=q6YGA4GTzxDYoSejEU8iEfGYTp4H6UqZs6brQPGIyyg,4102
+plaquette/device/__init__.py,sha256=VyAatdSr71rwhAX_OMkhhg4XsnlPQJShjHdPPNhFfYA,19499
+plaquette/device/_circuitsim.py,sha256=j677Ks9d6QTJ3zevQGErB7Xv4qqcTNjnabdFmgxwmGg,9128
+plaquette/device/_stimsim.py,sha256=iwNXqqMqXAzBMB84EGmW4xcPkRaTuMP4kDl8NgoLBV4,7232
 plaquette/errors/__init__.py,sha256=IwQGQsU64MvQKlRwEdkq59K-DbWxB4AMFDnzd0XR6yo,53727
-plaquette/frontend/__init__.py,sha256=UmEYM64ViHaCHwsU2eshlBWWKAEsg4tg3wHGla0_HAk,85438
-plaquette/frontend/schemas.py,sha256=0InHmhAAmRBFoPFgK0P-L6H4eSEJsc8UJYtJw8HnJ0A,11219
-plaquette/simulator/__init__.py,sha256=C4YPKaTYRghmxo0pJzgnsveExnvhCs74wHXm7xrn5Ns,12486
-plaquette/simulator/circuitsim.py,sha256=-S2UdyK-YpebL-B9ZaC1_cAAiyNJS3oSJhYk1hHZolE,9531
-plaquette/simulator/stimsim.py,sha256=nboLsUWAH_F7-roFghzy1_H0C7zJOaznVE7ngt0QXOU,6922
+plaquette/frontend/__init__.py,sha256=AnOLMnhCrz1Bth8Qic_r8CEEY2gaeqAe_QaNSv_5gNA,84819
+plaquette/frontend/schemas.py,sha256=C-avdqqgby70WL8YXdmYUwF4qBsiHq27GzRLMwkzdzA,11199
 plaquette/syngraph/__init__.py,sha256=lSVehV1Nwe7hD6BCYaYr_7bcjXMpAXDeHtsxbMDgnAc,46285
 plaquette/syngraph/weights.py,sha256=-p-dn9zlcfCzg8CqdZs8jIkPOPRnr00-9yIt-MBwXmY,8397
 plaquette/visualizer/__init__.py,sha256=1Cbzf-8d2y3v42TtUfchHa7AsXv_mhjrJ_ATAxqfloU,17643
-plaquette-0.0.1a0.dist-info/METADATA,sha256=t81xnuTI8TV1CIS9MszsS2dT_sPpP6-ewe4LK_HAjFo,3683
-plaquette-0.0.1a0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-plaquette-0.0.1a0.dist-info/top_level.txt,sha256=P3AY89vMfAJtZqY-iNmP_S0wd4JqvWb6TjU2I10ja50,10
-plaquette-0.0.1a0.dist-info/RECORD,,
+plaquette-0.0.1a1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+plaquette-0.0.1a1.dist-info/METADATA,sha256=QSc6KdPZvwIt8G_9Ix_I1QcUEjzjKiWMmxcQtLuWGt0,3774
+plaquette-0.0.1a1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+plaquette-0.0.1a1.dist-info/entry_points.txt,sha256=-kgJe_E62Ti2jbP_AXElio0Km8dyA0VEy6G4BrmLtz8,123
+plaquette-0.0.1a1.dist-info/top_level.txt,sha256=P3AY89vMfAJtZqY-iNmP_S0wd4JqvWb6TjU2I10ja50,10
+plaquette-0.0.1a1.dist-info/RECORD,,
```

