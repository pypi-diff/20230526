# Comparing `tmp/quarchCalibration-1.1.3.dev4-py2.py3-none-any.whl.zip` & `tmp/quarchCalibration-1.1.4-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,33 @@
-Zip file size: 113311 bytes, number of entries: 28
--rw-rw-rw-  2.0 fat     2934 b- defN 23-Apr-21 15:19 quarchCalibration/ET2260.py
--rw-rw-rw-  2.0 fat    19974 b- defN 23-Apr-21 15:19 quarchCalibration/PowerModuleCalibration.py
--rw-rw-rw-  2.0 fat    64834 b- defN 23-Apr-21 15:19 quarchCalibration/QTL1944.py
--rw-rw-rw-  2.0 fat    74125 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2347.py
--rw-rw-rw-  2.0 fat    64175 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2525.py
--rw-rw-rw-  2.0 fat    29042 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2582.py
--rw-rw-rw-  2.0 fat    53920 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2621.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2673.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2674.py
--rw-rw-rw-  2.0 fat    64175 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2788.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2887.py
--rw-rw-rw-  2.0 fat    46762 b- defN 23-Apr-21 15:19 quarchCalibration/QTL2888.py
--rw-rw-rw-  2.0 fat      526 b- defN 23-Apr-21 15:19 quarchCalibration/__init__.py
--rw-rw-rw-  2.0 fat       82 b- defN 23-Apr-21 15:19 quarchCalibration/__main__.py
--rw-rw-rw-  2.0 fat       26 b- defN 23-Apr-21 15:33 quarchCalibration/_version.py
--rw-rw-rw-  2.0 fat      713 b- defN 23-Apr-21 15:19 quarchCalibration/calibrationConfig.py
--rw-rw-rw-  2.0 fat    18110 b- defN 23-Apr-21 15:19 quarchCalibration/calibrationUtil.py
--rw-rw-rw-  2.0 fat     4126 b- defN 23-Apr-21 15:19 quarchCalibration/deviceHelpers.py
--rw-rw-rw-  2.0 fat     7562 b- defN 23-Apr-21 15:19 quarchCalibration/elpaSine.py
--rw-rw-rw-  2.0 fat    22184 b- defN 23-Apr-21 15:19 quarchCalibration/keithley_2460_control.py
--rw-rw-rw-  2.0 fat     9380 b- defN 23-Apr-21 15:19 quarchCalibration/noise_test.py
--rw-rw-rw-  2.0 fat    39277 b- defN 23-Apr-21 15:19 quarchCalibration/pamCommon.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-21 15:19 quarchCalibration/docs/__init__.py
--rw-rw-rw-  2.0 fat     2076 b- defN 23-Apr-21 15:19 quarchCalibration/docs/conf.py
--rw-rw-rw-  2.0 fat     1381 b- defN 23-Apr-21 15:34 quarchCalibration-1.1.3.dev4.dist-info/METADATA
--rw-rw-rw-  2.0 fat      110 b- defN 23-Apr-21 15:34 quarchCalibration-1.1.3.dev4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       18 b- defN 23-Apr-21 15:34 quarchCalibration-1.1.3.dev4.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2473 b- defN 23-Apr-21 15:34 quarchCalibration-1.1.3.dev4.dist-info/RECORD
-28 files, 668271 bytes uncompressed, 109303 bytes compressed:  83.6%
+Zip file size: 136801 bytes, number of entries: 31
+-rw-rw-rw-  2.0 fat     7185 b- defN 23-May-25 14:50 quarchCalibration/ET2260.py
+-rw-rw-rw-  2.0 fat    25831 b- defN 23-May-26 11:09 quarchCalibration/PowerModuleCalibration.py
+-rw-rw-rw-  2.0 fat    65176 b- defN 23-May-25 14:50 quarchCalibration/QTL1944.py
+-rw-rw-rw-  2.0 fat    68018 b- defN 23-May-25 14:50 quarchCalibration/QTL1944_06.py
+-rw-rw-rw-  2.0 fat    74754 b- defN 23-May-25 14:50 quarchCalibration/QTL2347.py
+-rw-rw-rw-  2.0 fat    64669 b- defN 23-May-25 14:50 quarchCalibration/QTL2525.py
+-rw-rw-rw-  2.0 fat    44492 b- defN 23-May-25 14:50 quarchCalibration/QTL2582.py
+-rw-rw-rw-  2.0 fat    54288 b- defN 23-May-25 14:50 quarchCalibration/QTL2621.py
+-rw-rw-rw-  2.0 fat    47072 b- defN 23-May-25 14:50 quarchCalibration/QTL2673.py
+-rw-rw-rw-  2.0 fat    46762 b- defN 23-May-25 14:50 quarchCalibration/QTL2674.py
+-rw-rw-rw-  2.0 fat    64669 b- defN 23-May-25 14:50 quarchCalibration/QTL2788.py
+-rw-rw-rw-  2.0 fat    46445 b- defN 23-May-25 14:50 quarchCalibration/QTL2843.py
+-rw-rw-rw-  2.0 fat    46762 b- defN 23-May-25 14:50 quarchCalibration/QTL2887.py
+-rw-rw-rw-  2.0 fat    46762 b- defN 23-May-25 14:50 quarchCalibration/QTL2888.py
+-rw-rw-rw-  2.0 fat      526 b- defN 23-May-25 14:50 quarchCalibration/__init__.py
+-rw-rw-rw-  2.0 fat       82 b- defN 23-May-25 14:50 quarchCalibration/__main__.py
+-rw-rw-rw-  2.0 fat       21 b- defN 23-May-26 14:46 quarchCalibration/_version.py
+-rw-rw-rw-  2.0 fat      713 b- defN 23-May-25 14:50 quarchCalibration/calibrationConfig.py
+-rw-rw-rw-  2.0 fat    19104 b- defN 23-May-26 11:27 quarchCalibration/calibrationUtil.py
+-rw-rw-rw-  2.0 fat     4126 b- defN 23-May-25 14:50 quarchCalibration/deviceHelpers.py
+-rw-rw-rw-  2.0 fat     9926 b- defN 23-May-25 14:50 quarchCalibration/elpaSine.py
+-rw-rw-rw-  2.0 fat    22184 b- defN 23-May-25 14:50 quarchCalibration/keithley_2460_control.py
+-rw-rw-rw-  2.0 fat     9375 b- defN 23-May-25 14:50 quarchCalibration/noise_test.py
+-rw-rw-rw-  2.0 fat    39461 b- defN 23-May-25 14:50 quarchCalibration/pamCommon.py
+-rw-rw-rw-  2.0 fat     7520 b- defN 23-May-25 14:50 quarchCalibration/threePhaseSwitchBox.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-25 14:50 quarchCalibration/docs/__init__.py
+-rw-rw-rw-  2.0 fat     2076 b- defN 23-May-25 14:50 quarchCalibration/docs/conf.py
+-rw-rw-rw-  2.0 fat     1533 b- defN 23-May-26 15:06 quarchCalibration-1.1.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      110 b- defN 23-May-26 15:06 quarchCalibration-1.1.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       18 b- defN 23-May-26 15:06 quarchCalibration-1.1.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2725 b- defN 23-May-26 15:06 quarchCalibration-1.1.4.dist-info/RECORD
+31 files, 822385 bytes uncompressed, 132407 bytes compressed:  83.9%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: quarchCalibration/PowerModuleCalibration.py
 Comment: 
 
 Filename: quarchCalibration/QTL1944.py
 Comment: 
 
+Filename: quarchCalibration/QTL1944_06.py
+Comment: 
+
 Filename: quarchCalibration/QTL2347.py
 Comment: 
 
 Filename: quarchCalibration/QTL2525.py
 Comment: 
 
 Filename: quarchCalibration/QTL2582.py
@@ -24,14 +27,17 @@
 
 Filename: quarchCalibration/QTL2674.py
 Comment: 
 
 Filename: quarchCalibration/QTL2788.py
 Comment: 
 
+Filename: quarchCalibration/QTL2843.py
+Comment: 
+
 Filename: quarchCalibration/QTL2887.py
 Comment: 
 
 Filename: quarchCalibration/QTL2888.py
 Comment: 
 
 Filename: quarchCalibration/__init__.py
@@ -60,26 +66,29 @@
 
 Filename: quarchCalibration/noise_test.py
 Comment: 
 
 Filename: quarchCalibration/pamCommon.py
 Comment: 
 
+Filename: quarchCalibration/threePhaseSwitchBox.py
+Comment: 
+
 Filename: quarchCalibration/docs/__init__.py
 Comment: 
 
 Filename: quarchCalibration/docs/conf.py
 Comment: 
 
-Filename: quarchCalibration-1.1.3.dev4.dist-info/METADATA
+Filename: quarchCalibration-1.1.4.dist-info/METADATA
 Comment: 
 
-Filename: quarchCalibration-1.1.3.dev4.dist-info/WHEEL
+Filename: quarchCalibration-1.1.4.dist-info/WHEEL
 Comment: 
 
-Filename: quarchCalibration-1.1.3.dev4.dist-info/top_level.txt
+Filename: quarchCalibration-1.1.4.dist-info/top_level.txt
 Comment: 
 
-Filename: quarchCalibration-1.1.3.dev4.dist-info/RECORD
+Filename: quarchCalibration-1.1.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quarchCalibration/ET2260.py

```diff
@@ -1,88 +1,209 @@
-import time
-import sys
-from socket import *
-from tkinter import *
-from tkinter.ttk import *
-
-from pyModbusTCP.client import ModbusClient
-
+#import select
+#import time
+#import sys
+#import unittest
+import os
+import logging
+import socket
+
+'''Control class for AC PAM switch box
+
+#http://www.rtautomation.com/technologies/modbus-tcpip/
+
+The static parameter, if used, should be set to the IP address of the switch box being addressed.
+If static is not provided the class will use discovery to find the IP address.
+'''
 class SwitchBoxControl:
     phase_list = ['L1', 'L2', 'L3']
-    def __init__(self, name, mux=True):
-        self.devices = {}
+    def __init__(self, name, addr=""):
         self.name = name
+        self.addr = addr
+        self.port = 502 # Default port is 502
 
-    def discover(self):
-        self.devices = {}
-
-        self.tsock = socket(AF_INET, SOCK_DGRAM)
-        self.tsock.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)
-        self.tsock.sendto('ICPDAS7188E,00'.encode("UTF-8"), ('255.255.255.255', 57188))
-
-        self.rsock = socket(AF_INET, SOCK_DGRAM)
-        self.rsock.bind(('', 54321))
-
-        msgs = self.rsock.recvfrom(1024)
-        self.rsock.close()
-
-        strmsg = msgs[0].decode("utf8").split(",")
-        strdict = {y[0]: y[1] for y in [x.split("=") for x in strmsg[2:]]}
+    def setMux(self,phase):
 
-        self.devices[strdict['ALIAS']] = strdict['IP']
-
-    def connect(self):
-        ip_addr = self.devices[self.name]
-
-        self.client = ModbusClient(ip_addr, auto_open=True, auto_close=True)
-        self.client.write_multiple_coils(0, [0, 0, 0])
+        if phase == "off":
+            coils = 0x00
+        elif phase == "1":
+            coils = 0x01
+        elif phase == "2":
+            coils = 0x02
+        elif phase == "3":
+            coils = 0x04
+        else:
+            raise ValueError("invalid parameter supplied to setMux(): " + str(phase))
+            coils = 0x00
+
+        #self.client = ModbusClient(self.addr, auto_open=True, auto_close=True)
+        #self.client.write_multiple_coils(0, [0, 0, 0])
+        # Set all phases off
+        tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        tsock.settimeout(5)
+        tsock.connect((self.addr,self.port))
+        request = modBusWriteMultipleCoilsRequest(3,coils)
+        logging.debug(os.path.basename(__file__) + ": Sending ModBus Request: " + request)
+        tsock.send(request)
+        while True:
+            try:
+                response = tsock.recv(1024)
+                ogging.debug(os.path.basename(__file__) + ": Received ModBus Response: " + response)
+            except:
+                   break
+        tsock.close()
+        
+        #check response
+        if (response is not None):
+            if response != bytes(modBusWriteMultipleCoilsResponse(3)):
+                raise ConnectionError("unexpected response received")
+        else:
+            raise ConnectionError("no response received from: " + self.name)
 
     def select_phase(self, phase):
         self.client.write_multiple_coils(0, [0, 0, 0])
         if phase in self.phase_list:
             coil_index = self.phase_list.index(phase)
             self.client.write_single_coil(coil_index, 1)
 
     def get_phase(self):
         try:
             active = self.client.read_coils(0, 3)
             return self.phase_list[active.index(True)]
         except ValueError:
             return "None"
 
-class ManualController:
-    phase_sel = ["L1", "L2", "L3", "None"]
-    def __init__(self, target="AC PAM Mux"):
-        self.win = Tk()
-        self.win.geometry("500x250")
-        self.win.title("AC PAM Switchbox Controller")
-        self.rbuttons = {}
-        self.curphase = StringVar(value="None")
-        self.dispphase = StringVar(value="None")
-        inc = 0
-
-        for label in self.phase_sel:
-            self.rbuttons[label] = Radiobutton(self.win, text=label, variable=self.curphase, value=label, command=self.switch).grid(row=inc, column=0)
-            inc += 1
-
-        self.displayPhase = Label(self.win, textvariable=self.dispphase).grid(row=inc, column=0)
-        inc += 1
-        self.exitbutton = Button(self.win, text="Quit", command=self.exit).grid(row=inc, column=0)
-
-        self.sbcon = SwitchBoxControl(target)
-        self.sbcon.discover()
-        self.sbcon.connect()
-
-        Label(self.win, text="Connected to: " + target).grid(row=0, column=1)
-        Label(self.win, text="IP addr:" + self.sbcon.devices[target]).grid(row=1, column=1)
-
-        self.win.mainloop()
-
-    def switch(self):
-        self.sbcon.select_phase(self.curphase.get())
-        self.dispphase.set(self.sbcon.get_phase())
+# Discover ET2260 devices through UDP broadcast
+# returns a dictionary of ALIAS IP pairs, where NAME=ET-2260
+# This function makes a lot of assumptions about the data and certainly could be a lot more robust
+def discover():
+
+    logging.debug(os.path.basename(__file__) + ": Searching for AC switch boxes: ")
+
+    devices = {}
+
+    ipList = socket.gethostbyname_ex(socket.gethostname())
+    logging.debug(os.path.basename(__file__) + ": Discovered the following interfaces: " + ipList)
 
-    def exit(self):
-        sys.exit(0)
+    # broadcast/listen on each interface
+
+    responses = []
+
+    for ip in ipList[2]:
+
+        logging.debug(os.path.basename(__file__) + ": Broadcasting on : " + ip)
+
+        tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
+        tsock.bind((ip,53780))
+        tsock.sendto('ICPDAS7188E,00'.encode("UTF-8"), ('255.255.255.255', 57188))
+        tsock.close()
+
+        rsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        # wait 1 second for a response
+        rsock.settimeout(1)
+        rsock.bind((ip, 54321))
+
+        # Receive messages until timeout.
+        while True:
+            try:
+                responses.append(rsock.recvfrom(1024))
+            except:
+                break
+
+        rsock.close()
+
+
+    logging.debug(os.path.basename(__file__) + ": Received the following responses: " + responses)
+
+    # for each response received
+    for response in responses:
+        try:
+            # we assume each response should have the payload in [0], the senders address in [1], in this case we only look at the payload which we assume is comma delimited, and contain [parameter]=[value] pairs
+            # split the payload at the commas, to get the pairs
+            strmsg = response[0].decode("utf8").split(",")
+            # create a dictionary from each pair
+            strdict = {y[0]: y[1] for y in [x.split("=") for x in strmsg[2:]]}
+        except:
+            # malformed data received
+            break
+
+        # if this is an ET-2260 device
+        if strdict["NAME"] == "ET-2260":
+            # create a dictionary entry from the alias and ip address
+            devices[strdict['ALIAS']] = strdict['IP']
+
+    return devices
+
+def modBusWriteMultipleCoilsRequest(bitCount,bits,transactionID=0,protocolID=0,unitID=1,referenceNumber=0):
+    
+    try:
+        bitCount_bytes=int(bitCount).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus bitCount invalid")
+
+    try:
+        byteCount = int((bitCount+7)/8)
+        byteCount_bytes=int(byteCount).to_bytes(1,'big')
+    except:
+        raise ValueError("ModBus byteCount invalid")
+    
+    try:
+        transactionID_bytes = int(transactionID).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus transactionID invalid")
+
+    try:
+        protocolID_bytes = int(protocolID).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus protocolID invalid")
+
+    try:
+        commandLength_bytes=int(byteCount+7).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus commandLength invalid")
+
+    try:
+        unitID_bytes = int(unitID).to_bytes(1,'big')
+    except:
+        raise ValueError("ModBus unitID invalid")
+
+    try:
+        referenceNumber_bytes = int(referenceNumber).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus referenceNumber invalid")
+
+    try:
+        bits_bytes = int(bits).to_bytes(1,'big')
+    except:
+        raise ValueError("ModBus bits invalid")
+
+    return transactionID_bytes + protocolID_bytes + commandLength_bytes + unitID_bytes + b'\x0f' + referenceNumber_bytes + bitCount_bytes + byteCount_bytes + bits_bytes
+
+def modBusWriteMultipleCoilsResponse(bitCount,transactionID=0,protocolID=0,unitID=1,referenceNumber=0):
+    
+    try:
+        bitCount_bytes=int(bitCount).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus bitCount invalid")
+    
+    try:
+        transactionID_bytes = int(transactionID).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus transactionID invalid")
+
+    try:
+        protocolID_bytes = int(protocolID).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus protocolID invalid")
+
+    try:
+        unitID_bytes = int(unitID).to_bytes(1,'big')
+    except:
+        raise ValueError("ModBus unitID invalid")
+
+    try:
+        referenceNumber_bytes = int(referenceNumber).to_bytes(2,'big')
+    except:
+        raise ValueError("ModBus referenceNumber invalid")
 
-if __name__ == "__main__":
-    gui = ManualController("AC PAM Mux")
+    return transactionID_bytes + protocolID_bytes + b'\x00\x06' + unitID_bytes + b'\x0f' + referenceNumber_bytes + bitCount_bytes
+
```

## quarchCalibration/PowerModuleCalibration.py

```diff
@@ -23,39 +23,41 @@
 from quarchpy.device.device import *
 from quarchpy.qps import isQpsRunning, startLocalQps
 import types
 from time import sleep,time
 from math import ceil
 from quarchpy.user_interface import *
 
+# These functions are dc specific and this is not a good place for them
+# as they are very simple, i'm replacing the call directly in each device file
 
 def load_set_volt(load,value,currentLimit="1e-1"):
-    # set_load_volt uses volts, we convert from mV
-    return load.setReferenceVoltage(value/1000,currentLimit)
+   # set_load_volt uses volts, we convert from mV
+   return load.setReferenceVoltage(value/1000,currentLimit)
 
 def load_get_volt(load):
 
-    # getLoadVoltage returns volts, we convert these to mV and return
-    return load.getLoadVoltage()*1000
+   # getLoadVoltage returns volts, we convert these to mV and return
+   return load.getLoadVoltage()*1000
 
 def load_meas_volt(load):
 
-    # measaureLoadVoltage returns volts, we convert these to mV and return
-    return load.measureLoadVoltage()*1000
+   # measaureLoadVoltage returns volts, we convert these to mV and return
+   return load.measureLoadVoltage()*1000
 
 def load_set_cur(load,value):
 
-    #set load current, parameter is uA, the keithley needs amps
-    response = load.setReferenceCurrent(value/1000000)
-    return response
+   #set load current, parameter is uA, the keithley needs amps
+   response = load.setReferenceCurrent(value/1000000)
+   return response
 
 def load_meas_cur(load):
 
-    #get load current, the keithley returns amps, we use uA
-    return load.measureLoadCurrent()*1000000
+   #get load current, the keithley returns amps, we use uA
+   return load.measureLoadCurrent()*1000000
 
 '''
 Coefficient Class
 
 This class holds a floating point value, and the precision at which it will be stored (in the FPGA)
 
     The constructor will throw an OverFlowError if the integer value overflows the specified integer width
@@ -173,19 +175,158 @@
     '''
     def getResult(self,value):
         return round( ( (float(value)/self.scaling ) * self.multiplier.storedValue() - self.offset.storedValue() ) * self.scaling )
 
     '''
     getStepMultiplier()
 
-        works out the multiplier to apply on each step to get from test_min to test_max in test_steps
+        works out the multiplier to apply on each step to get exponentially from test_min to test_max in test_steps
 
     '''
     def getStepMultiplier(self):
-        return (self.test_max/self.test_min)**(1/(self.test_steps-1))
+        try:
+            return (self.test_max/self.test_min)**(1/(self.test_steps-1))
+        except:
+            raise ValueError("invalid step multiplier requested")
+
+'''
+AC PAM Coefficient Class
+
+This class holds a floating point value, and the precision at which it will be stored (in the FPGA)
+
+    The constructor will throw an OverFlowError if the integer value overflows the specified integer width
+
+    Value() returns the original value
+
+    storedValue() returns the reduced precision value as would be stored in the FPGA
+
+    hexString() returns an appropriate length hex string of the stored Value
+
+'''
+
+class AcPamCoefficient:
+    def __init__(self, value):
+        # set overflow flag if the value is out of the supported range
+        if value < 0.5 or value > 1.5:
+            self.overflow = True
+        else:
+            self.overflow = False
+
+        self.value = value
+
+    def originalValue(self):
+        return self.value
+
+    # This function returns the value at the precision it would be stored in the FPGA flash
+    def storedValue(self):
+        # if number has overflowed, don't return a value
+        if self.overflow == True:
+            return 1
+        # else reduce the value to the precision we can store
+        else:
+            # positive reg value
+            if (self.value-1) >= 0:
+                return 1 + (round(abs(self.value-1) * 2**23) / 2**23)
+            # negative reg value
+            else:
+                return 1 - (round(abs(self.value-1) * 2**23) / 2**23)
+
+    '''
+    hexString(hex_chars)
+
+    returns a hex string begining 0x with the number of hex characters specified
+    '''
+    #def hexString(self,hex_chars):
+    #    #shift left by required number of fractional bits, round it (to nearest integer), then and with 1's to truncate it to required length
+    #    return "{:#0{hex_chars}x}".format(round(self.value*(2**self.frac_width)) & (2**(hex_chars*4)-1),hex_chars=(hex_chars+2))
+
+    def hexString(self,hex_chars):
+        # if number has overflowed, don't return a value
+        if self.overflow == True:
+            return "Overflow Error"
+        else:
+            if (self.storedValue()-1) >= 0:
+                return "{:#0{hex_chars}x}".format( round((self.storedValue()-1)*(2**23)) , hex_chars=(hex_chars+2) )
+            else:
+                return "{:#0{hex_chars}x}".format( (2**(hex_chars*4)) - (round(abs(self.storedValue()-1)*(2**23))) , hex_chars=(hex_chars+2) )
+
+'''
+AC PAM Calibration Class
+
+This class holds a multiplier and offset coefficient as instances of the Coefficient class
+
+    The constructor will generate multiplier and offset from a set of points in the form of a list of coordinates, using the x axis for ADC value and the y axis for reference value
+    shift is an integer providing the size of the shift left that is applied to the result after multiplication and offset are applied
+
+    Calibration(points,shift,abs_error,rel_error)
+
+        shift is the binary left shift that takes place inside the FPGA
+
+
+                LOW_12V = Calibration("uA",init_cmd,read_cmd,multiplier_cmd,offset_cmd,
+                              MULTIPLIER = Coefficient(multiplier_int_width,multiplier_frac_width,multiplier_shift)
+                              OFFSET = Coefficient(offset_int_width,offset_frac_width,offset_shift)
+
+'''
+class AcPamCalibration:
+
+    powerModule = None
+    absErrorLimit = None
+    relErrorLimit = None
+    test_min = None
+    test_max = None
+    test_steps = None
+    units = None
+    scaling = None
+    multiplier_signed = None
+    multiplier_int_width = None
+    multiplier_frac_width  = None
+    offset_signed = None
+    offset_int_width  = None
+    offset_frac_width  = None
+
+    '''
+    generate(points)
+
+        generates a multiplier and offset from a set of coordinates
+
+        points  -   a list of x and y values in form [(x0,y0),(x1,y1),(x2,y2)]
+
+    '''        
+    def generate(self,points):
+        (thisMultiplier,thisOffset) = bestFit(points)
+        # divide the offset by the hardware shift
+        thisOffset /= self.scaling
+        self.multiplier = AcPamCoefficient(thisMultiplier)
+        self.offset = Coefficient(-thisOffset,self.offset_signed,self.offset_int_width,self.offset_frac_width)            # offsets are subtracted in the hw, so we flip the sign of the offset
+        if self.multiplier.overflow == True or self.offset.overflow == True:
+            return False
+        else:
+            return True
+
+    '''
+    getResult(adc_value)
+
+        takes in a value and applies the current calibration to it    
+
+    '''
+    def getResult(self,value):
+        return round( ( (float(value)/self.scaling ) * self.multiplier.storedValue() - self.offset.storedValue() ) * self.scaling )
+
+    '''
+    getStepMultiplier()
+
+        works out the multiplier to apply on each step to get exponentially from test_min to test_max in test_steps
+
+    '''
+    def getStepMultiplier(self):
+        try:
+            return (self.test_max/self.test_min)**(1/(self.test_steps-1))
+        except:
+            raise ValueError("invalid step multiplier requested")
 
 
 '''
 Class PowerModule
 
     Generic Class for a quarch module with measurement channels. The function holds a list of channels, and a channel holds a list of calibrations
 
@@ -334,15 +475,15 @@
                 thisItem.init()
 
                 # step through values and populate table
                 iteration = 1
                 data = []
                 steps = thisItem.test_steps
                 test_value = thisItem.test_min
-                while test_value <= thisItem.test_max:
+                while (test_value <= thisItem.test_max):
 
                     # set reference value
                     thisItem.setRef(int(test_value))
 
                     # get calibrated result
                     reference = thisItem.readRef()
 
@@ -352,16 +493,19 @@
                     #store the results
                     data.append([value,reference])
 
                     # print progress bar
                     progressBar(iteration,steps)
                     iteration += 1
 
-                    # increment the test value
-                    test_value = int(test_value*thisItem.getStepMultiplier())
+                    # increment the test value or finish
+                    if test_value < thisItem.test_max:
+                        test_value = int(test_value*thisItem.getStepMultiplier())
+                    else:
+                        break
 
                 #turn off the module and load
                 thisItem.finish()
 
                 if action == 'calibrate':
 
                     # generate coefficients
@@ -407,24 +551,28 @@
 
         self.dut = myPpmDevice
         myQpsDevice = quarchQPS(myPpmDevice)
         myQpsDevice.openConnection()
         return myQpsDevice
 
     def noiseTest(self):
-        if self.has_noise_test is  None or self.has_noise_test is False:
-            user_interface.logSimpleResult("No noise test available for this module. Continuing.")
+        result=hasattr(self, "has_noise_test")
+        if hasattr(self, "has_noise_test") is False or self.has_noise_test is False:
+            user_interface.logSimpleResult("No noise test available for this module. Continuing.", "pass")
             return
+        oldConString=self.dut.ConString
+        oldConType=self.dut.ConType
         myQpsDevice=self.setupForNoiseTest()
         from .noise_test import test_main
-        stream_path = "C:\\Users\\Public\\Documents"
-        report_path = "C:\\Users\\Public\\Documents"
-        temp=test_main(self ,myQpsDevice, stream_path, report_path)
-        results=[]
+        temp=test_main(self ,myQpsDevice)
 
+        #QPS should be closed by now, so DUT connectiong must be reverted back to whatever it was before the Noise Test.
+        myPpmDevice = quarchDevice(oldConString, oldConType)
+        self.dut = myPpmDevice
+        results=[]
         for row in temp: # Format the returned info
             testPass=None
             if row[1].lower() == "pass":
                 testPass=True
             elif row[1].lower() == "fail":
                 testPass=False
             else:
@@ -450,21 +598,25 @@
         # calculate the mean value of all y coordinates
         AveY = reduce(lambda sum,point : sum+point[1],points,0)/len(points)
         # calculate the sum of (x-x'mean)*(y-y'mean) for all points
         SumXY = reduce(lambda sum,point : sum + (1/point[0])*((point[0]-AveX)*(point[1]-AveY)), points, 0)
         # calculate the sum of (x-x'mean)*(x-x'mean) for all points
         SumX2 = reduce(lambda sum,point : sum + (1/point[0])*((point[0]-AveX)*(point[0]-AveX)), points, 0)
 
-        Slope = SumXY/SumX2
-        Intercept = AveY-(Slope*AveX)
+        if SumX2 == 0:
+            Slope = AveY/AveX
+            Intercept = 0.0;
+        else:
+            Slope = SumXY/SumX2
+            Intercept = AveY-(Slope*AveX)
 
         return Slope,Intercept
     except Exception as e:
         return 1.0,0.0
-        #raise Exception(e)
+        logging.critical(os.path.basename(__file__) + "bestFit algorithm failed to find a solution")
 
 '''
 getError(reference_value,calculated_value,abs_error,rel_error)
 
     takes in a reference value and a calculated value
     returns a tuple with actual error (reference-calculated), absolute error, relative error and result
```

## quarchCalibration/QTL1944.py

```diff
@@ -57,15 +57,15 @@
     CALIBRATION_COMPLETE_ADDR    = '0xF012'  
     # Noise Test Vars
     # Dict of channels and limits
     has_noise_test = True
     channel_dict_max_limits = {"current 5V Max": "3000uA", "current 12V Max": "3000uA", "power Tot Max": "10000uW"}
     channel_dict_min_limits = {}
     test_length = 15  # The time measurements are taken over, aka the distandce between the two annotations.
-    averaging_value = "0"  # 0=4us
+    averaging_value = "16"  # 16=64us
 
     def __init__(self,dut):
 
         # Fixture Information
         self.enclosureSerial = None
         self.enclosurePosition = None
         self.PPMSerial = None
@@ -121,15 +121,15 @@
         else:
             versionStr = "NOT-FOUND"    
         self.Firmware = versionStr.strip()
 
         self.calibrations = {}
         # populate 12V channel with calibrations
         self.calibrations["12V"] = {
-            "Output Offset":self.HD12VOffsetCalibration(self ),
+            "Output Offset":self.HD12VOffsetCalibration(self),
             "Voltage":self.HD12VVoltageCalibration(self),
             "Low Current":self.HD12VLowCurrentCalibration(self),
             "High Current":self.HD12VHighCurrentCalibration(self),
             "Leakage":self.HD12VLeakageCalibration(self)
             }
         # populate 5V channel with calibrations
         self.calibrations["5V"] = {
@@ -569,15 +569,15 @@
 
         def setRef(self,value):
 
             super().set_12v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)-11998   # this is the difference in mV between the current measured voltage and the nominal voltage
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000-11998   # this is the difference in mV between the current measured voltage and the nominal voltage
 
         def readVal(self):
 
             return (int(self.powerModule.dut.sendCommand("read 0x0006"),16)-0xD3F)*self.scaling  # this is the difference in mV between the current set point and the nominal voltage
 
         def setCoefficients(self):
 
@@ -644,15 +644,15 @@
 
         def setRef(self,value):
 
             super().set_12v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def setCoefficients(self):
 
@@ -718,19 +718,19 @@
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V12_LOW_MULTIPLIER_ADDR + " 0x0000")
             #sendAndVerifyCommand(ppm,"write 0xf00b 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V12_LOW_OFFSET_ADDR + " 0x0000")
             #sendAndVerifyCommand(ppm,"write 0xf00c 0x0000")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -793,19 +793,19 @@
             self.powerModule.dut.sendAndVerifyCommand("write 0xf001 0x0102")
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V12_HIGH_MULTIPLIER_ADDR + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V12_HIGH_OFFSET_ADDR + " 0x0000")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -946,15 +946,15 @@
 
         def setRef(self,value):
 
             super().set_5v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)-5000   # this is the difference in mV between the current measured voltage and the nominal voltage
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000-5000   # this is the difference in mV between the current measured voltage and the nominal voltage
 
         def readVal(self):
 
             return (int(self.powerModule.dut.sendCommand("read 0x0005"),16)-0x585)*self.scaling  # this is the difference in DAC levels between the current set point and the nominal voltage
 
         def setCoefficients(self):
 
@@ -1015,15 +1015,15 @@
 
         def setRef(self,value):
 
             super().set_5v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5v_volt()
 
         def setCoefficients(self):
 
@@ -1087,19 +1087,19 @@
             self.powerModule.dut.sendAndVerifyCommand("write 0xf001 0x0101")
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V5_LOW_MULTIPLIER_ADDR + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V5_LOW_OFFSET_ADDR + " 0x0000")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5v_cur()
 
         def setCoefficients(self):
 
@@ -1163,19 +1163,19 @@
             self.powerModule.dut.sendAndVerifyCommand("write 0xf001 0x0102")
             # clear the multiplier and offset registers by setting them to zero
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V5_HIGH_MULTIPLIER_ADDR + " 0x0000")
             self.powerModule.dut.sendAndVerifyCommand("write " + QTL1944.V5_HIGH_OFFSET_ADDR + " 0x0000")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5v_cur()
 
         def setCoefficients(self):
 
@@ -1310,15 +1310,15 @@
 
         def readRef(self):
 
             return super().get_12v_volt()
 
         def readVal(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
@@ -1344,15 +1344,15 @@
 
         def setRef(self,value):
 
             super().set_12v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def finish(self):
 
@@ -1377,19 +1377,19 @@
 
         def init(self):
 
             super().init_cal("12V")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1414,19 +1414,19 @@
 
         def init(self):
 
            super().init_cal("12v")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1462,15 +1462,15 @@
 
         def setRef(self,value):
 
             super().set_12v_volt(value)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1503,15 +1503,15 @@
 
         def readRef(self):
 
             return super().get_5v_volt()
 
         def readVal(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def finish(self):
 
             super().finish_cal()
 
         def report(self,data):
 
@@ -1536,15 +1536,15 @@
 
         def setRef(self,value):
 
             super().set_5v_volt(value)
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5v_volt()
 
         def finish(self):
 
@@ -1569,19 +1569,19 @@
 
         def init(self):
 
            super().init_cal("5v")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5v_cur()
 
         def finish(self):
 
@@ -1606,19 +1606,19 @@
 
         def init(self):
 
            super().init_cal("5v")
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5v_cur()
 
         def finish(self):
 
@@ -1654,15 +1654,15 @@
 
         def setRef(self,value):
 
             super().set_5v_volt(value)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5v_cur()
 
         def finish(self):
```

## quarchCalibration/QTL2347.py

```diff
@@ -501,19 +501,19 @@
             # Check Host Power is not present
             while (super().checkLoadVoltage(500,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def setCoefficients(self):
 
@@ -584,24 +584,24 @@
             while (super().checkLoadVoltage(500,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V",None,reset=True)
 
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             # negate result because in this case the load is providing the power, not sinking it
-            return -load_meas_cur(self.powerModule.calInstrument)
+            return -self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return load_get_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.getLoadVoltage()*1000
 
         def setCoefficients(self):
 
             # we don't apply the leakage calibration here because it provides uA leakage results and the current calibration uses raw ADC values
             # instead we will use it to correct the current calibration and apply it later
             pass
 
@@ -660,22 +660,22 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
             leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument) + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -745,22 +745,22 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
             leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument) + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -832,19 +832,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(500,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("3V3",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_volt()
 
         def setCoefficients(self):
 
@@ -915,24 +915,24 @@
             while (super().checkLoadVoltage(500,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("3V3",None,reset=True)
 
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             # negate result because in this case the load is providing the power, not sinking it
-            return -load_meas_cur(self.powerModule.calInstrument)
+            return -self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return load_get_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.getLoadVoltage()*1000
 
         def setCoefficients(self):
 
             # we don't apply the leakage calibration here because it provides uA leakage results and the current calibration uses raw ADC values
             # instead we will use it to correct the current calibration and apply it later
             pass
 
@@ -991,22 +991,22 @@
             # Check Host Power is present               
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("3V3","3V3",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_volt()
             leakage = voltage*self.powerModule.calibrations["3.3V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument) + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
             return super().meas_3v3_cur()
 
         def setCoefficients(self):
 
@@ -1076,22 +1076,22 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("3V3","3V3",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_volt()
             leakage = voltage*self.powerModule.calibrations["3.3V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument) + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
             return super().meas_3v3_cur()
 
         def setCoefficients(self):
 
@@ -1163,19 +1163,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def setCoefficients(self):
 
@@ -1245,24 +1245,24 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
             # negate result because in this case the load is providing the power, not sinking it
-            return -load_meas_cur(self.powerModule.calInstrument)
+            return -self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
-            return load_get_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.getLoadVoltage()*1000
 
         def setCoefficients(self):
 
             # we don't apply the leakage calibration here because it provides uA leakage results and the current calibration uses raw ADC values
             # instead we will use it to correct the current calibration and apply it later
             pass
 
@@ -1319,22 +1319,22 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_aux_volt()
             leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument) + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000 + leakage
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def setCoefficients(self):
 
@@ -1394,19 +1394,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def finish(self):
 
@@ -1438,19 +1438,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,500) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1481,19 +1481,19 @@
             # Check Host Power is present	    	    
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1525,19 +1525,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_volt()
 
         def finish(self):
 
@@ -1569,19 +1569,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3","3V3",None,reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_cur()
 
         def finish(self):
 
@@ -1613,19 +1613,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3","3V3",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_cur()
 
         def finish(self):
 
@@ -1657,19 +1657,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def finish(self):
 
@@ -1701,19 +1701,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2347.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def finish(self):
```

## quarchCalibration/QTL2525.py

```diff
@@ -501,19 +501,19 @@
             ## Check Host Power is not present        
             #while (super().checkLoadVoltage(500,500) != True):
             #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def setCoefficients(self):
 
@@ -583,22 +583,22 @@
             # Check Host Power is present          
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
             #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -668,21 +668,21 @@
             # Check Host Power is present      
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -750,19 +750,19 @@
             ## Check Host Power is not present            
             #while (super().checkLoadVoltage(500,500) != True):
             #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("5V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5V_volt()
 
         def setCoefficients(self):
 
@@ -833,22 +833,22 @@
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("5V","5V",reset=True)
 
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_5V_volt()
             #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def setCoefficients(self):
 
@@ -918,22 +918,22 @@
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
 
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_5V_volt()
             #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def setCoefficients(self):
 
@@ -1005,19 +1005,19 @@
             #while (super().checkLoadVoltage(500,500) != True):
             #	input("Unexpected voltage detected at load, please check connections")
             #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def setCoefficients(self):
 
@@ -1085,22 +1085,22 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_aux_volt()
             #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def setCoefficients(self):
 
@@ -1160,19 +1160,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def finish(self):
 
@@ -1204,19 +1204,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
             	
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1247,19 +1247,19 @@
             # Check Host Power is present	    	    
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1291,19 +1291,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5V_volt()
 
         def finish(self):
 
@@ -1334,19 +1334,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
   
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def finish(self):
 
@@ -1379,19 +1379,19 @@
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
             	
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def finish(self):
 
@@ -1422,19 +1422,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
             	
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def finish(self):
 
@@ -1465,19 +1465,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2525.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
     
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def finish(self):
```

## quarchCalibration/QTL2582.py

```diff
@@ -7,14 +7,16 @@
 '''
 import quarchpy.user_interface
 
 '''
 Calibration Flow
     Connect to AC PAM Fixture 
     Connect to ELPA-SINE
+    Connect to AC Power Supply
+    Connect to Switch Boxes
     step through each AC phase
       - Read peak voltage value and set voltage multiplier
       - Step through current values and set current multiplier
       - Save neutral current readings
     Calibrate/verify neutral
 
 '''
@@ -27,18 +29,48 @@
 from .PowerModuleCalibration import *
 from .calibrationConfig import *
 from .elpaSine import *
 from quarchpy.device.device import *
 from quarchpy.user_interface import *
 from quarchpy.utilities.BitManipulation import *
 from quarchpy.device import quarchPPM, quarchDevice
+from quarchpy.qis import isQisRunning, startLocalQis
+from quarchpy.connection_specific.connection_QIS import QisInterface as qisInterface
 import csv
-import numpy as np
 from collections import OrderedDict
-from .ET2260 import SwitchBoxControl
+from .threePhaseSwitchBox import ThreePhaseSwitchBox
+from quarchCalibration import Keysight_AC6804B_control
+from quarchCalibration.Keysight_AC6804B_control import KeysightAC6804B
+
+def get_QIS_version():
+	#TODO option var "close_qis_afer_check" to determine if qis is left open or not.
+    global my_close_qis
+    """
+    Returns the version of QIS.  This is the version of QIS currenty running on the local system if one exists.
+    Otherwise the local version within quarchpy will be exectued and its version returned.
+
+    Returns
+    -------
+    version: str
+        String representation of the QIS version number
+
+    """
+
+    qis_version = ""
+    if isQisRunning() == False:
+        my_close_qis = True
+        startLocalQis(headless=True)
+
+    myQis = qisInterface()
+    qis_version = myQis.sendAndReceiveCmd(cmd="$version")
+    if "No Target Device Specified" in qis_version:
+        qis_version = myQis.sendAndReceiveCmd(cmd="$help").split("\r\n")[0]
+    vmatch = re.search("v([0-9]).([0-9]+)", qis_version)
+    if vmatch:
+        return [int(x) for x in vmatch.groups()]
 
 def parseFixtureData(response,start,length):
 
     # split the multiline response into a list
     response = response.splitlines()
     result = ""
     # for each line
@@ -70,463 +102,23 @@
         # else exit loop
         else:
             break
     return bcd
 
 currentPhase = None
 
-
-
-class QTL2582_Calibration:
-    phaseList = ['L1', 'L2', 'L3', 'Neutral']
-    calTypeList = ['I', 'V', 'V2']
-    CALIBRATION_MODE_ADDR = '0xA100'
-    CALIBRATION_CONTROL_ADDR = '0xA101'
-    CALIBRATION_COMPLETE_ADDR = '0xA11C'
-    voltScalingConstant = 1.0
-    currentScalingConstant = 1.0
-    test_steps = None
-    test_min = None
-    test_max = None
-    maxElpaCurrent = 5000.0
-    calMultiplier = 1.0
-    streamMeasureTime = 2.0
-    coeffValid = False
-    worstCase = 0.0
-    relErrorLimit = 1.5
-    phase = None
-    verification = False
-    units = None
-    fullName = None
-    lastMeasurement = None
-    useNumpy = False
-
-    def __init__(self, moduleConnection, calType='I', calPhase='L1', verify=False, neutral=None):
-        self.conn = moduleConnection
-        self.neutral = neutral
-        if moduleConnection is not None:
-            self.powerdev = quarchPPM(moduleConnection)
-            # Don't need to manually create RMS channels any more
-            if not self.useNumpy:
-                for phase in self.phaseList:
-                    self.powerdev.sendCommand("stream create channel chan({0}vRMS, V) rms(40mS, chan({0}, V) ) mV 1.0".format(phase))
-                    self.powerdev.sendCommand("stream create channel chan({0}aRMS, A) rms(40mS, chan({0}, A) ) mA 1.0".format(phase))
-
-        self.streamFilename = None
-        self.elpa = None
-        self.elpaConnected = False
-
-        self.calType = calType
-        self.phase = calPhase
-
-        self.SwitchMux = SwitchBoxControl("AC PAM Mux")
-        self.SwitchMux.discover()
-        self.SwitchMux.connect()
-
-        if calType == 'I':
-            self.absoluteErrorLimit = 0.0
-            self.units = "mA"
-            self.fullName = "Current"
-
-            if self.verification:
-                self.test_steps = 8
-                self.test_min = 200.0
-                self.test_max = 5000.0
-            else:
-                self.test_steps = 5
-                self.test_min = 1000.0
-                self.test_max = 5000.0
-        else:
-            self.absoluteErrorLimit = 0.0
-            self.units = "mV"
-            self.fullName = "Voltage"
-
-            self.test_steps = 1
-            self.test_min = 340000.0
-            self.test_max = 340000.0
-        self.verification = verify
-
-    def init(self):
-        self.SwitchMux.select_phase(self.phase)
-        #global currentPhase
-        #if currentPhase != self.phase:
-        #    quarchpy.user_interface.showDialog(
-        #        "Set power connections to phase " + self.phase + ", verify 240V on ELPA-SINE")
-        #    currentPhase = self.phase
-
-    # This call has no meaning for AC PAM voltage calibration, as reference voltages cannot be set
-    def setRef(self, x):
-        if self.calType == 'I':
-            if x < 0 or x > self.maxElpaCurrent:
-                raise ValueError("ERROR - ELPA max RMS current must be less than " + self.maxElpaCurrent + " mA")
-            self.elpa.setLoadCurrent(x / 1000.0)
-            self.elpa.enable()
-            time.sleep(0.5)
-
-    def readRef(self):
-        if self.calType == 'I':
-            self.lastCurrentReading = self.elpa.getCurrentMeasurement('RMS') * 1000.0
-            return self.lastCurrentReading
-        else:
-            return self.elpa.getVoltageMeasurement('RMS') * 1000.0
-
-    def readVal(self):
-        # Return measurement, normalize all values to Volts and Amps
-        return self.getMeasurement(self.phase, self.calType, typ='RMS', streamTime=self.streamMeasureTime)
-
-    def finish(self):
-        self.elpa.disable()
-
-    # Calculate the correct multiplier coefficients
-    # Since the AC PAM does not have an offset, use a weighted average of the multiplier values rather than
-    # attempting a linear fit
-    def generate(self, points):
-        multiplierList = []
-        multSum = 0.0
-        for p in points:
-            multiplierList.append(p[1] / p[0])
-            multSum += multiplierList[-1]
-
-        mult = multSum / len(points)
-        if mult >= 1.0 and mult <= 2.0:
-            self.calMultiplier = mult
-            self.coeffValid = True
-        else:
-            self.coeffValid = False
-        return self.coeffValid
-
-    def setCoefficients(self):
-        self.setMultiplier(self.phase, self.calType, self.calMultiplier)
-
-    def streamData(self, streamTime=1.0):
-        # Sets for a manual record trigger, so we can start the stream from the script
-        self.powerdev.sendCommand("record:trigger:mode manual")
-        self.powerdev.sendCommand("record:averaging 0")
-
-        # In this example we write to a fixed path
-        self.streamFilename = 'Stream1.csv'
-        self.powerdev.startStream(self.streamFilename, 2000, 'Example stream to file')
-
-        # Delay for a x seconds while the stream is running.  You can also continue
-        # to run your own commands/scripts here while the stream is recording in the background
-        time.sleep(streamTime)
-
-        # Check the stream status, so we know if anything went wrong during the stream
-        streamStatus = self.powerdev.streamRunningStatus()
-        if ("Stopped" in streamStatus):
-            if ("Overrun" in streamStatus):
-                print('Stream interrupted due to internal device buffer has filled up')
-            elif ("User" in streamStatus):
-                print('Stream interrupted due to max file size has being exceeded')
-            else:
-                print("Stopped for unknown reason")
-
-        # Stop the stream.  This function is blocking and will wait until all remaining data has
-        # been downloaded from the module
-        self.powerdev.stopStream()
-
-        # check to ensure stream is fully stopped before continuing script
-        stopStreamCount = 0
-        while not "stopped" in str(self.powerdev.streamRunningStatus()).lower():
-            stopStreamCount += 1
-            if stopStreamCount > 20:
-                raise TimeoutError("Failed to stop stream after {} seconds".format(stopStreamCount))
-            time.sleep(1)
-
-    def getCoeffAddr(self, phase, calType):
-        if phase not in self.phaseList:
-            raise ValueError("Unknown phase " + phase)
-        elif calType not in self.calTypeList:
-            raise ValueError("Unknown calibration type " + calType)
-        else:
-            pnumber = self.phaseList.index(phase) * 3 + self.calTypeList.index(calType)
-            addrLow = 0xA105 + pnumber * 2
-            addrHigh = addrLow + 1
-        return (addrLow, addrHigh)
-
-    def readRawValues(self):
-        rawValues = {}
-        with open(self.streamFilename, 'r') as fh:
-            csvfile = csv.reader(fh)
-            titles = None
-            for row in csvfile:
-                if not titles:
-                    titles = row
-                    for i in range(len(row)):
-                        rawValues[titles[i]] = []
-                else:
-                    for i in range(len(row)):
-                        try:
-                            rawValues[titles[i]].append(int(row[i]))
-                        except ValueError:
-                            rawValues[titles[i]].append(0)
-        return rawValues
-
-    def calcRmsValues(self):
-        rawValues = self.readRawValues()
-        rmsValues = {}
-        for k in rawValues.keys():
-            if self.useNumpy:
-                vec = np.array(rawValues[k][1:-1]).astype(float)
-                if len(vec) > 100:
-                    rmsValues[k] = np.sqrt(vec.dot(vec) / vec.size)
-            else:
-                items = [float(x) for x in rawValues[k][1:-1] if x > 0]
-                if len(items) > 100:
-                    average = sum(items) / float(len(items))
-                    rmsValues[k] = average
-
-        self.lastMeasurement = rmsValues
-        return rmsValues
-
-    def findPeakValues(self):
-        maxvalues = []
-        prevValues = []
-        peakList = []
-        rising = []
-        with open(self.streamFilename, 'r') as fh:
-            csvfile = csv.reader(fh)
-            titles = None
-            for row in csvfile:
-                if not titles:
-                    titles = row
-                    for i in range(len(row)):
-                        maxvalues.append(0)
-                        prevValues.append(0)
-                        peakList.append([])
-                        rising.append(False)
-                else:
-                    for i in range(len(row)):
-                        value = int(row[i])
-                        if value >= maxvalues[i]:
-                            maxvalues[i] = value
-
-                        # If we are in the positive have of the wave, look for the point just when values begin to fall
-                        if value > 0:
-                            if value > prevValues[i]:
-                                rising[i] = True
-                                prevValues[i] = value
-                            else:
-                                if rising[i]:
-                                    peakList[i].append(prevValues[i])
-                                    rising[i] = False
-                        else:
-                            # On the negative half of the wave, reset the values for the next pass
-                            rising[i] = False
-                            prevValues[i] = 0
-
-        mvdict = {}
-        avgPeak = {}
-        for i in range(len(titles)):
-            mvdict[titles[i]] = maxvalues[i]
-
-            # Throw away first and last samples, as they may have been clipped
-            peakVector = np.array(peakList[i][1:-1])
-            avgPeak[titles[i]] = peakVector.mean()
-
-        return avgPeak
-
-    def shutdown(self):
-        self.powerdev.closeConnection()
-
-    def loadToAde(self):
-        self.powerdev.sendCommand("write 0x1000 0x0000")
-        self.powerdev.sendCommand("write 0x1000 0x0002")
-
-    def clear_calibration(self):
-
-        # set unit into calibration mode
-        self.powerdev.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0xaa55")
-        self.powerdev.sendCommand("write " + self.CALIBRATION_MODE_ADDR + " 0x55aa")
-
-        # clear all calibration registers
-        for phase in self.phaseList:
-            for t in ["V", "I", "V2"]:
-                caddr = self.getCoeffAddr(phase, t)
-                self.powerdev.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
-                self.powerdev.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
-
-        self.loadToAde()
-
-        # write 0xaa55 to register to calibration complete register to tell module it is calibrated
-        self.powerdev.sendAndVerifyCommand("write " + self.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
-
-    def getStepMultiplier(self):
-        if self.test_steps > 1:
-            return (self.test_max / self.test_min) ** (1 / self.test_steps)
-        else:
-            return 2.0
-
-    '''Set the AC PAM multiplier value, which is a 23-bit fixed point number
-    '''
-
-    def setMultiplier(self, phase, parm, mult):
-        addrLow, addrHigh = self.getCoeffAddr(phase, parm)
-
-        if ((mult < 1.0) or (mult >= 4.0)):
-            raise ValueError("Multiplier must be between 1 and 2")
-        else:
-            mconst = int((mult - 1.0) * (2 ** 23))
-            mconst_low = mconst & 0xFFFF
-            mconst_high = mconst >> 16
-            # print("Setting phase {0} const to {1:06x}".format(phase, mconst))
-            self.conn.sendCommand("write 0x{0:04x} 0x{1:04x}".format(addrLow, mconst_low))
-            self.conn.sendCommand("write 0x{0:04x} 0x{1:04x}".format(addrHigh, mconst_high))
-
-            # Trigger FPGA to load new values into the ADE7978
-            self.loadToAde()
-
-    def getMeasurement(self, phase, parm, typ='PEAK', streamTime=1.0):
-        self.streamData(streamTime)
-        if typ == 'PEAK':
-            vals = self.findPeakValues()
-        else:
-            vals = self.calcRmsValues()
-
-        if parm == 'V':
-            if self.useNumpy:
-                key = "{0:s} mV".format(phase)
-            else:
-                key = "{0:s}vRMS mV".format(phase)
-        else:
-            if self.useNumpy:
-                key = "{0:s} mA".format(phase)
-            else:
-                key = "{0:s}aRMS mA".format(phase)
-
-        if key in vals:
-            if parm == 'I':
-                if self.useNumpy:
-                    self.neutral.add_measurement(self.lastCurrentReading, vals["N mA"])
-                else:
-                    self.neutral.add_measurement(self.lastCurrentReading, vals["NeutralaRMS mA"])
-            return vals[key]
-        else:
-            return 0
-
-    def report(self, data):
-        report = []
-
-        self.title = "AC PAM Phase {} {} Calibration".format(self.phase, self.fullName)
-
-        report.append("")
-        report.append("{0:>20s} {1:>20s} {2:>20s} {3:>20s}".format("DUT Value", "Inst Value", "Abs Error", "Rel Error"))
-        worstError = 0.0
-        passedVerif = True
-        for d in data:
-            errorTuple = getError(d[0], d[1], self.absoluteErrorLimit, self.relErrorLimit)
-            worstError = max(errorTuple[3], worstError)
-            report.append("{0:17.2f} {5:2s} {1:17.2f} {5:2s} {4:>9s}{2:8.2f} {5:2s} {3:20.2f}%".format(d[0], d[1], errorTuple[0], errorTuple[3], errorTuple[1], self.units))
-            if errorTuple[4] == False:
-                passedVerif = False
-
-        report.append(
-            "==================================================================================================")
-
-        if self.verification:
-            result = passedVerif
-        else:
-            result = self.coeffValid
-        return {"title": self.title, "result": result, "worst case": "{0:4.2f}%".format(worstError),
-                "report": ('\n'.join(report))}
-
-    def write_calibration(self):
-
-        # write the calibration registers
-        # erase the tag memory
-        printText("Erasing TAG memory..")
-        self.powerdev.sendCommand("write 0xa200 0x0020")
-        # TODO: should check for completion here...
-        # wait for 2 seconds for erase to complete
-        # check busy
-        while checkBit(self.powerdev.sendCommand("read 0xa200"), 8):
-            time.sleep(0.1)
-        # write the tag memory
-        printText("Programming TAG memory...")
-        self.powerdev.sendCommand("write 0xa200 0x0040")
-        # check busy
-        while checkBit(self.powerdev.sendCommand("read 0xa200"), 8):
-            time.sleep(0.1)
-
-class Neutral_Calibration (QTL2582_Calibration):
-    def __init__(self, moduleConnection, verify=False):
-        super().__init__(moduleConnection=moduleConnection, calType='I', calPhase='Neutral', verify=verify, neutral=None)
-        self.verification = verify     # Set to False for calibration, True for verification
-        self.measurements = []
-        self.absoluteErrorLimit = 0.0
-        self.relErrorLimit = 1.5
-        self.test_steps = 0
-        self.test_min = 100
-        self.test_max = 1000
-        self.units = "mA"
-
-    def init(self):
-        pass
-
-    def setRef(self, x):
-        pass
-
-    def readRef(self):
-        return self.measurements[0][0]
-
-    def readVal(self):
-        val = self.measurements[0][1]
-        self.measurements.pop(0)
-        return val
-
-    def finish(self):
-        pass
-
-    def shutdown(self):
-        pass
-
-    def add_measurement(self, ref, val):
-        self.measurements.append( (ref, val) )
-        self.test_steps = len(self.measurements)
-        self.test_max = self.test_min * (2 ** (len(self.measurements)-1))
-
-    def getStepMultiplier(self):
-        return 2
-
-    def report(self, data):
-
-        report = []
-
-        self.title = "AC PAM Neutral Calibration"
-
-        report.append("")
-        report.append("{0:>20s} {1:>20s} {2:>20s} {3:>20s}".format("DUT Value", "Inst Value", "Abs Error", "Rel Error"))
-        worstError = 0.0
-        passedVerif = True
-        for d in data:
-            errorTuple = getError(d[0], d[1], self.absoluteErrorLimit, self.relErrorLimit)
-            worstError = max(errorTuple[3], worstError)
-            report.append("{0:17.2f} {5:2s} {1:17.2f} {5:2s} {4:>9s}{2:8.2f} {5:2s} {3:20.2f}%".format(d[0], d[1], errorTuple[0], errorTuple[3], errorTuple[1], self.units))
-            if errorTuple[4] == False:
-                passedVerif = False
-
-        report.append(
-            "==================================================================================================")
-
-        if self.verification:
-            result = passedVerif
-        else:
-            result = self.coeffValid
-        return {"title": self.title, "result": result, "worst case": "{0:4.2f}%".format(worstError),
-                "report": ('\n'.join(report))}
-
 class QTL2582 (PowerModule):
     phaseList = ['L1', 'L2', 'L3', 'Neutral']
     calTypeList = ['I', 'V', 'V2']
 
     # Fixture Register Addresses
     CALIBRATION_MODE_ADDR               = '0xA100'
     CALIBRATION_CONTROL_ADDR            = '0xA101'
 
-    SAVE_VALUE_START_ADDR               = '0xA102'
+    SERIAL_NUMBER_START_ADDR            = '0xA102'
 
     AIGAIN_LOW_ADDR                     = '0xA105'
     AIGAIN_HIGH_ADDR                    = '0xA106'
     AVGAIN_LOW_ADDR                     = '0xA107'
     AVGAIN_HIGH_ADDR                    = '0xA108'
     AV2GAIN_LOW_ADDR                    = '0xA109'
     AV2GAIN_HIGH_ADDR                   = '0xA10A'
@@ -549,15 +141,15 @@
     NIGAIN_HIGH_ADDR                    = '0xA118'
     NVGAIN_LOW_ADDR                     = '0xA119'
     NVGAIN_HIGH_ADDR                    = '0xA11A'
     NV2GAIN_LOW_ADDR                    = '0xA11B'
     NV2GAIN_HIGH_ADDR                   = '0xA11C'
 
     CALIBRATION_COMPLETE_ADDR	        = '0xA11D'
-    LOAD_VOLTAGE                        = 340000
+    LOAD_VOLTAGE                        = 240000
 
     # Fixture Information
     PAMSerial = None
     FixtureSerial = None
     calObjectSerial = None     # The serial number of the device that is being calibrated, i.e QTL1944 in HD PPM, Fixture in PAM
     idnStr = None
     Firmware = None
@@ -575,36 +167,49 @@
     checkedWiring = False
     currentPhase = None
 
     def specific_requirements(self):
 
         reportText=""
 
-        if "elpaSine" in calibrationResources.keys():
-            elpa = elpaSine(calibrationResources["elpaSine"])
+        # select an AC Supply to use for calibration
+        if "acSupply" in calibrationResources.keys():
+            self.acSupply = calibrationResources["acSupply"]
+        else:
+            self.acSupply = self.getAcSupply()
+        calibrationResources["acSupply"] = self.acSupply
+
+        # select an AC Supply Mux to use for calibration
+        if "acSupplyMux" in calibrationResources.keys():
+            self.acSupplyMux = calibrationResources["acSupplyMux"]
         else:
-            # No selection process as of yet, the ELPA-SINE has a static address
-            target = quarchpy.user_interface.listSelection(title="Load Selection", message="Select ELPA-SINE unit to connect to",
-                                                  selectionList="127.0.0.1=localhost,192.168.1.239=static")
-            elpa = elpaSine(target)
-        elpa.openConnection()
-        self.calInstrument = elpa
+            self.acSupplyMux = self.getAcMux("AC Supply Mux")
+        calibrationResources["acSupplyMux"] = self.acSupplyMux
+
+        # select an AC Load Mux to use for calibration
+        if "acLoadMux" in calibrationResources.keys():
+            self.acLoadMux = calibrationResources["acLoadMux"]
+        else:
+            self.acLoadMux = self.getAcMux("AC Load Mux")
+        calibrationResources["acLoadMux"] = self.acLoadMux
+
+        # select an AC Load to use for calibration
+        if "elpasine" in calibrationResources.keys():
+            self.acLoad = calibrationResources["elpasine"]
+        else:
+            self.acLoad = self.getAcLoad()
+        calibrationResources["elpasine"] = self.acLoad
 
         # Check connectivity to the ELPA-SINE
-        elpaIdentity = self.calInstrument.sendCommandQuery("*IDN?")
+        elpaIdentity = self.acLoad.sendCommandQuery("*IDN?")
         if elpaIdentity.find("ELPA-SINE") == -1:
             printText("Unable to communicate with ELPA-SINE")
             raise Exception("Unable to communicate with ELPA-SINE")
         self.calInstrumentId = elpaIdentity
 
-        # Connect the individual calibrations to the ELPA
-        for calPhase in list(self.calibrations.values()) + list(self.verifications.values()):
-            for calItem in calPhase.values():
-                calItem.elpa = self.calInstrument
-
         # Write module specific report header to file
         reportText += "Quarch AC Power Analysis Module: "
         reportText += self.PAMSerial + "\n"
         reportText += "Quarch FW Versions: "
         reportText += "FW:" + self.Firmware + ", FPGA: " + self.Fpga + "\n"
         reportText += "\n"
         reportText += "Calibration Instruments#:\n"
@@ -613,50 +218,113 @@
         # perform uptime check and write to file
         if self.waitComplete != True:
             reportText += self.wait_for_up_time(desired_up_time=600, command="conf:runtime:fix:sec?")
             self.waitComplete = True
 
         return reportText
 
-    def setConnections(self,loadConnection,hostPowerConnection,reset=False):
-        if hostPowerConnection:
-            showDialog("Set source switch to phase {}".format(hostPowerConnection))
-        if loadConnection:
-            showDialog("Set load switch to phase {}".format(loadConnection))
+    def getAcSupply(self,alias=""):
+        #if alias is None or alias == "":
+        alias = "AC Supply"
+        # Find an AC Mux
+        while (True):
+            devices = KeysightAC6804B.discover()
+            selectedDevice = quarchpy.user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    acSupply = KeysightAC6804B(selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+        return acSupply
+
+    def getAcMux(self,alias=""):
+        if alias is None or alias == "":
+            alias = "AC Mux"
+        # Find an AC Mux
+        while (True):
+            devices = ThreePhaseSwitchBox.discover()
+            selectedDevice = user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=devices,additionalOptions = [["rescan","rescan"],["quit","quit"]],nice=True)
+            if str(selectedDevice[1]).lower() == "rescan":
+                pass
+            elif str(selectedDevice[1]).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    acMux = ThreePhaseSwitchBox(alias,selectedDevice[2])
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+        return acMux
+
+
+    def getAcLoad(self,alias=""):
+        if alias is None or alias == "":
+            alias = "AC Load"
+        # Find an AC Mux
+        while (True):
+            devices = ElpaSine.discover()
+            deviceList = []
+            for device in devices:
+                deviceList.append(device["ip"])
+            selectedDevice = user_interface.listSelection(title="Select an " + alias,message="Please select the correct " + alias,selectionList=deviceList,additionalOptions = [["rescan"],["quit"]],nice=True)
+            if str(selectedDevice).lower() == "rescan":
+                pass
+            elif str(selectedDevice).lower() == "quit":
+                printText("User Quit Program")
+                sys.exit(0)
+            else:
+                try:
+                    acLoad = ElpaSine(selectedDevice)
+                    break
+                except:
+                    printText("Unable to communicate with selected device!")
+                    printText("")
+                    raise
+        return acLoad
 
     def getCoeffAddr(self, phase, calType):
         if phase not in self.phaseList:
             raise ValueError("Unknown phase " + phase)
         elif calType not in self.calTypeList:
             raise ValueError("Unknown calibration type " + calType)
         else:
             pnumber = self.phaseList.index(phase) * 3 + self.calTypeList.index(calType)
             addrLow = 0xA105 + pnumber * 2
             addrHigh = addrLow + 1
-            #addrLow = getattr(self, "{0}{1}GAIN_LOW".format(phase, calType))
-            #addrHigh = getattr(self, "{0}{1}GAIN_HIGH".format(phase, calType))
         return (addrLow, addrHigh)
 
-
     def clear_calibration(self):
 
         # set unit into calibration mode
         self.dut.sendCommand("write " + QTL2582.CALIBRATION_MODE_ADDR + " 0xaa55")
         self.dut.sendCommand("write " + QTL2582.CALIBRATION_MODE_ADDR + " 0x55aa")
 
         # clear all calibration registers
         for phase in self.phaseList:
             for t in ["V", "I", "V2"]:
                 caddr = self.getCoeffAddr(phase, t)
                 self.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
                 self.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
 
         # Load calibration values into the ADE7978
-        self.dut.sendCommand("write 0x1000 0x0000")
-        self.dut.sendCommand("write 0x1000 0x0002")
+        self.dut.sendCommand("write 0x1800 0x0000")
+        self.dut.sendCommand("write 0x1800 0x0002")
+
+        #self.loadToAde()
 
         # write 0xaa55 to register to calibration complete register to tell module it is calibrated
         self.dut.sendAndVerifyCommand("write " + QTL2582.CALIBRATION_COMPLETE_ADDR + " 0xaa55")
         
     def write_calibration(self):
 
         # write the calibration registers
@@ -672,43 +340,684 @@
         printText("Programming TAG memory...")
         self.dut.sendCommand("write 0xa200 0x0040")        
         # check busy
         while checkBit(self.dut.sendCommand("read 0xa200"),8):
             sleep(0.1)
 
     def close_module(self):
+
         #close the connection to the calibration instrument
-        self.calInstrument.closeConnection()
+        self.acLoad.closeConnection()
 
     def close_all(self):
 
         #close all attached devices
-        self.calInstrument.setLoadCurrent(0)
-        self.calInstrument.closeConnection()
-        self.powerModule.setConnections(None,None)
+        self.acLoad.setLoadCurrent(0)
+        self.acLoad.closeConnection()
+        self.acSupplyMux.setMux("off")
+        self.acLoadMux.setMux("off")
+
+    class QTL2582_Calibration (AcPamCalibration):
+
+        streamFilename = ''
+        iteration = 0
+        streamMeasureTime = 2.0
+        scaling = 1
+
+        def __init__(self):
+            super().__init__()
+        
+        def init_cal(self):
+
+            self.powerModule.acSupply.setOutputEnable(False)
+            self.powerModule.acSupply.setACSupplyRange("AUTO")
+            self.powerModule.acSupply.setACSupplyFrequency(50)
+            self.powerModule.acSupply.setSupplyCurrentLimit(10)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+        def meas_volt(self,phase):
+
+            return self.getMeasurement(phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def meas_current(self,phase):
+
+            return self.getMeasurement(phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def streamData(self,streamMeasureTime=None):
+            if streamMeasureTime is not None:
+                self.streamMeasureTime = streamMeasureTime
+            # Sets for a manual record trigger, so we can start the stream from the script
+            self.powerModule.dut.sendCommand("record:trigger:mode manual")
+            self.powerModule.dut.sendCommand("record:averaging 0")
 
+            # In this example we write to a fixed path
+            self.streamFilename = calibrationResources["calPath"] + "\\" + self.phase + '_' + '_' + self.units + '_' + str(self.iteration) + '.csv'
+            self.iteration += 1
+            self.powerModule.dut.startStream(self.streamFilename, 2000, 'Example stream to file')
+
+            # Delay for a x seconds while the stream is running.  You can also continue
+            # to run your own commands/scripts here while the stream is recording in the background
+            time.sleep(1)
+
+            # Check the stream status, so we know if anything went wrong during the stream
+            streamStatus = self.powerModule.dut.streamRunningStatus()
+            if ("Stopped" in streamStatus):
+                if ("Overrun" in streamStatus):
+                    print('Stream interrupted due to internal device buffer has filled up')
+                elif ("User" in streamStatus):
+                    print('Stream interrupted due to max file size has being exceeded')
+                else:
+                    print("Stopped for unknown reason")
+
+            # Stop the stream.  This function is blocking and will wait until all remaining data has
+            # been downloaded from the module
+            self.powerModule.dut.stopStream()
+
+            # check to ensure stream is fully stopped before continuing script
+            stopStreamCount = 0
+            while not "stopped" in str(self.powerModule.dut.streamRunningStatus()).lower():
+                stopStreamCount += 1
+                if stopStreamCount > 20:
+                    raise TimeoutError("Failed to stop stream after {} seconds".format(stopStreamCount))
+                time.sleep(1)
+
+        def readRawValues(self):
+            rawValues = {}
+            with open(self.streamFilename, 'r') as fh:
+                csvfile = csv.reader(fh)
+                titles = None
+                for row in csvfile:
+                    if not titles:
+                        titles = row
+                        for i in range(len(row)):
+                            rawValues[titles[i]] = []
+                    else:
+                        for i in range(len(row)):
+                            try:
+                                rawValues[titles[i]].append(int(row[i]))
+                            except ValueError:
+                                rawValues[titles[i]].append(0)
+            return rawValues
+
+        def calcRmsValues(self,samples=800):
+            rawValues = self.readRawValues()
+            rmsValues = {}
+            for k in rawValues.keys():
+                if len(rawValues[k]) >= samples:
+                    items = [float(x**2) for x in rawValues[k][:samples]]
+                    meanSquares = sum(items) / float(len(items))
+                    rmsValues[k] = meanSquares**0.5
+            self.lastMeasurement = rmsValues
+            return rmsValues
+
+        def findPeakValues(self):
+            maxvalues = []
+            prevValues = []
+            peakList = []
+            rising = []
+            with open(self.streamFilename, 'r') as fh:
+                csvfile = csv.reader(fh)
+                titles = None
+                for row in csvfile:
+                    if not titles:
+                        titles = row
+                        for i in range(len(row)):
+                            maxvalues.append(0)
+                            prevValues.append(0)
+                            peakList.append([])
+                            rising.append(False)
+                    else:
+                        for i in range(len(row)):
+                            value = int(row[i])
+                            if value >= maxvalues[i]:
+                                maxvalues[i] = value
+
+                            # If we are in the positive have of the wave, look for the point just when values begin to fall
+                            if value > 0:
+                                if value > prevValues[i]:
+                                    rising[i] = True
+                                    prevValues[i] = value
+                                else:
+                                    if rising[i]:
+                                        peakList[i].append(prevValues[i])
+                                        rising[i] = False
+                            else:
+                                # On the negative half of the wave, reset the values for the next pass
+                                rising[i] = False
+                                prevValues[i] = 0
+
+            mvdict = {}
+            avgPeak = {}
+            for i in range(len(titles)):
+                mvdict[titles[i]] = maxvalues[i]
+
+                # Throw away first and last samples, as they may have been clipped
+                peakVector = np.array(peakList[i][1:-1])
+                avgPeak[titles[i]] = peakVector.mean()
+
+            return avgPeak
+
+        def getMeasurement(self, phase, parm, typ='PEAK', streamTime=1.0):
+            self.streamData(streamTime)
+            if typ == 'PEAK':
+                vals = self.findPeakValues()
+            else:
+                vals = self.calcRmsValues()
+
+            if parm == 'V':
+                key = "{0:s} mV".format(phase)
+            else:
+                key = "{0:s} mA".format(phase)
+
+            if key in vals:
+                return vals[key]
+            else:
+                raise ValueError("requested measurement not found in data")
+        
+        def finish_cal(self):
+
+            #turn off supply
+            self.powerModule.acSupply.setOutputEnable(False)
+
+            #turn off switches
+            self.powerModule.acSupplyMux.setMux("off")
+            self.powerModule.acLoadMux.setMux("off")
+
+            #turn off load
+            self.powerModule.acLoad.setLoadCurrent(0)
+            #self.powerModule.acLoad.setOutputEnable(False)
+
+        def report(self,action,data):
+
+            report = []
+
+            # send to report file
+            report.append("          Pass Level  +/-(" + str(self.absErrorLimit) + str(self.units) +" + " + str(self.relErrorLimit) + "%) \n")
+
+
+            # check errors and generate report
+            report.append('\n')
+
+            if action == "calibrate":
+               report.append("\t" + '{0:>11}'.format('Reference ')+ self.units + '   ' + '{0:>10}'.format('Raw Value ')+ self.units + '   ' + '{0:>10}'.format('Result ')+ self.units + '   ' + '{0:>10}'.format('Error ')+ self.units + '   ' + '{0:>13}'.format('+/-(Abs Error,% Error)') + ' ' + '{0:>10}'.format('Pass'))
+            elif action == "verify":
+                report.append("\t" + '{0:>11}'.format('Reference ')+ self.units + '   ' + '{0:>10}'.format('Result ')+ self.units + '   ' + '{0:>10}'.format('Error ')+ self.units + '   ' + '{0:>13}'.format('+/-(Abs Error,% Error)') + '   ' + '{0:>10}'.format('Pass'))
+
+            report.append("==================================================================================================")
+
+            # zero worst case error vars
+            worstAbsError = 0
+            worstRelError = 0
+            worstRef = None
+            overallResult = True
+
+            # for each calibration reference
+            for thisLine in data:
+                reference = thisLine[1]
+                ppmValue = thisLine[0]
+
+                # for calibration, replace value with calibrated result
+                if action =="calibrate":
+                    calibratedValue = self.getResult(ppmValue)
+                # otherwise just use ppmValue directly
+                else:
+                    calibratedValue = ppmValue
+
+                # work out errors
+                (actError,errorSign,absError,relError,result) = getError(reference,calibratedValue,self.absErrorLimit,self.relErrorLimit)
+
+                # compare/replace with running worst case
+                if absError >= worstAbsError:
+                    if relError >= worstRelError:
+                        worstAbsError = absError
+                        worstRelError = relError
+                        worstCase = errorSign + "(" + str(absError) + self.units + "," + "{:.3f}".format(relError) + "%) @ " + '{:.3f}'.format(reference) + self.units
+
+                # update overall pass/fail
+                if result != True:
+                    overallResult = False
+
+                #generate report
+                passfail = lambda x: "Pass" if x else "Fail"
+                if action == "calibrate":
+                    report.append("\t" + '{:>11.3f}'.format(reference) + '     ' + '{:>10.1f}'.format(ppmValue) + '     ' + '{:>10.1f}'.format(calibratedValue) + '     ' + "{:>10.3f}".format(actError) + '     ' + '{0:>16}'.format(errorSign + "(" + str(absError) + self.units + "," + "{:.3f}".format(relError) + "%)") + '     ' + '{0:>10}'.format(passfail(result)))
+                elif action == "verify":
+                    report.append("\t" + '{:>11.3f}'.format(reference) + '     ' + '{:>10.1f}'.format(ppmValue) + '     ' + "{:>10.3f}".format(actError) + '     ' + '{0:>16}'.format(errorSign + "(" + str(absError) + self.units + "," + "{:.3f}".format(relError) + "%)") + '     ' + '{0:>10}'.format(passfail(result)))
+
+            report.append("==================================================================================================")
+            report.append('\n')
+
+            if action == "calibrate":
+                report.append("Calculated Multiplier: " + str(self.multiplier.originalValue()) + ", Calculated Offset: " + str(self.offset.originalValue()))
+                report.append("Stored Multiplier: " + str(self.multiplier.storedValue()) + ", Stored Offset: " + str(self.offset.storedValue()))
+                report.append("Multiplier Register: " + self.multiplier.hexString(4) + ", Offset Register: " + self.offset.hexString(4))
+
+            report.append("" + '{0:<35}'.format(self.title)+ '     '  +'{0:>10}'.format("Passed : ")+ '  '  + '{0:<5}'.format(str(overallResult))+ '     ' + '{0:>11}'.format( "worst case:")+ '  '  +'{0:>11}'.format(worstCase))
+            report.append("\n\n\n")
+            
+            #Add to Test Summary? Do this here?
+            passfail = lambda x: "Passed" if x else "Failed"
+
+            return {"title":self.title,"result":overallResult,"worst case":worstCase,"report":('\n'.join(report))}
+
+    class QTL2582_Voltage_Calibration (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = phase + " Voltage Calibration"
+            self.phase = phase
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mV
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 50000                   # 50V
+            self.test_max = 280000                  # 280V
+            self.test_steps = 8
+            self.units = "mV"
+            self.scaling = 1
+            self.multiplier_signed = False
+            self.multiplier_int_width = 1
+            self.multiplier_frac_width = 23
+            self.offset_signed = True
+            self.offset_int_width = 10
+            self.offset_frac_width = 6
+
+        def init(self):
+
+            super().init_cal()
+
+            # clear the multiplier and offset registers by setting them to zero
+            caddr = self.powerModule.getCoeffAddr(self.phase, "V")
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux(self.phase)
+            self.powerModule.acLoadMux.setMux(self.phase)
+            
+            #Enable load
+            self.powerModule.acLoad.setLoadCurrent(0)
+            self.powerModule.acLoad.setOutputEnable(True)
+
+            # Check Host Power is present
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
+
+        def setRef(self,value):
+            self.powerModule.acSupply.setACSupplyVoltage(value/1000)
+            sleep(1) # Add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def setCoefficients(self):
+
+            # Get Coefficient Addresses
+            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'V')
+
+            hexString = self.multiplier.hexString(8)
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
+            if result1 and result2:
+                result = True
+            else:
+                result = False
+            logSimpleResult("Set L1 Current Coefficients", result)
+
+            # load calibration values to ADE
+            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
+            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("calibrate",data)
+
+    class QTL2582_Current_Calibration (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = phase + " Current Calibration"
+            self.phase = phase
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 200                     # 0.2A
+            self.test_max = 5000                    # 5A
+            self.test_steps = 8
+            self.units = "mA"
+            self.scaling = 1
+            self.multiplier_signed = False
+            self.multiplier_int_width = 1
+            self.multiplier_frac_width = 23
+            self.offset_signed = True
+            self.offset_int_width = 10
+            self.offset_frac_width = 6
+
+        def init(self):
+
+            super().init_cal()
+
+            # clear the multiplier and offset registers by setting them to zero
+            caddr = self.powerModule.getCoeffAddr(self.phase, "I")
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
+
+            #turn on AC Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux(self.phase)
+            self.powerModule.acLoadMux.setMux(self.phase)
+
+        def setRef(self,value):
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            sleep(1) # Add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def setCoefficients(self):
+
+            # Get Coefficient Addresses
+            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'I')
+
+            hexString = self.multiplier.hexString(8)
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
+            if result1 and result2:
+                result = True
+            else:
+                result = False
+            logSimpleResult("Set " + self.phase + " Current Coefficients", result)
+
+            # load calibration values to ADE
+            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
+            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("calibrate",data)
+
+    # Neutral Calibration is the same as L1 Current Calibration, but we measure and calibrate the neutral current instead of L1
+    class QTL2582_Neutral_Current_Calibration (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = "Neutral Calibration"
+            self.phase = "Neutral"
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 200                     # 0.2A
+            self.test_max = 5000                    # 5A
+            self.test_steps = 8
+            self.units = "mA"
+            self.scaling = 1
+            self.multiplier_signed = False
+            self.multiplier_int_width = 1
+            self.multiplier_frac_width = 23
+            self.offset_signed = True
+            self.offset_int_width = 10
+            self.offset_frac_width = 6
+
+        def init(self):
+
+            super().init_cal()
+
+            # clear the multiplier and offset registers by setting them to zero
+            caddr = self.powerModule.getCoeffAddr(self.phase, "I")
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[0]))
+            self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} 0x0000".format(caddr[1]))
+
+            #turn on AC Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux("L1")
+            
+            # Check Host Power is present
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
+
+        def setRef(self,value):
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            sleep(1) # Add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def setCoefficients(self):
+
+            # Get Coefficient Addresses
+            addrLow, addrHigh = self.powerModule.getCoeffAddr(self.phase, 'I')
+
+            hexString = self.multiplier.hexString(8)
+            result1 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrHigh) + hexString[:6]) 
+            result2 = self.powerModule.dut.sendAndVerifyCommand("write 0x{0:04x} ".format(addrLow) + hexString[:2] + hexString[6:])
+            if result1 and result2:
+                result = True
+            else:
+                result = False
+            logSimpleResult("Set Neutral Current Coefficients", result)
+
+            # load calibration values to ADE
+            self.powerModule.dut.sendCommand("write 0x1800 0x0000")
+            self.powerModule.dut.sendCommand("write 0x1800 0x0002")
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("calibrate",data)
+
+    class QTL2582_Voltage_Verification (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = phase + " Voltage Verification"
+            self.phase = phase
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mV
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 50000                   # 50V
+            self.test_max = 280000                  # 280V
+            self.test_steps = 8
+            self.units = "mV"
+
+        def init(self):
+
+            super().init_cal()
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux(self.phase)
+            self.powerModule.acLoadMux.setMux(self.phase)
+
+            #time.sleep(1) # attempt to sort error in first reading from elpaSine
+            
+            # Check Host Power is present
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
+
+        def setRef(self,value):
+            self.powerModule.acSupply.setACSupplyVoltage(value/1000)
+            sleep(1) # Add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getVoltageMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'V', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("verify",data)
+
+    class QTL2582_Current_Verification (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = phase + " Current Verification"
+            self.phase = phase
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 200                     # 0.2A
+            self.test_max = 5000                    # 5A
+            self.test_steps = 8
+            self.units = "mA"
+
+        def init(self):
+
+            super().init_cal()
+
+            #turn on AC Supply
+            self.powerModule.acSupply.setACSupplyVoltage(240)
+            self.powerModule.acSupply.setOutputEnable(True)
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux(self.phase)
+            self.powerModule.acLoadMux.setMux(self.phase)
+
+        def setRef(self,value):
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            time.sleep(1) # add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("verify",data)
+
+    # Neutral Verification is the same as L1 Current Verification, but we measure the neutral current instead of L1
+    class QTL2582_Neutral_Current_Verification (QTL2582_Calibration):
+
+        def __init__(self,powerModule,phase):
+
+            self.title = "Neutral Verification"
+            self.phase = "Neutral"
+            self.powerModule = powerModule
+            self.absErrorLimit = 0                  # 0mA
+            self.relErrorLimit = 1                  # 1%
+            self.test_min = 200                     # 0.2A
+            self.test_max = 5000                    # 5A
+            self.test_steps = 8
+            self.units = "mA"
+
+        def init(self):
+
+            super().init_cal()
+
+            #set switches
+            self.powerModule.acSupplyMux.setMux("L1")
+            self.powerModule.acLoadMux.setMux("L1")
+            
+            # Check Host Power is present
+#            while (super().checkLoadVoltage(500,500) != True):
+#                input("Unexpected voltage detected at load, please check connections")
+
+        def setRef(self,value):
+            if value < 0 or value > 10000:
+                raise ValueError("ERROR - ELPA max RMS current must be less than 10A")
+            self.powerModule.acLoad.setLoadCurrent(value / 1000.0)
+            self.powerModule.acLoad.setOutputEnable(True)
+            sleep(1) # Add settling time
+
+        def readRef(self):
+            return self.powerModule.acLoad.getCurrentMeasurement('RMS') * 1000.0
+
+        def readVal(self):
+            # Return measurement, normalize all values to Volts and Amps
+            return self.getMeasurement(self.phase, 'I', typ='RMS', streamTime=self.streamMeasureTime)
+
+        def finish(self):
+
+            super().finish_cal()
+
+        def report(self,data):
+
+            return super().report("verify",data)
 
     def __init__(self,dut):
 
+        # We need to use QIS to get RMS etc
+        # close the quarchpy connection
+        dut.closeConnection()
+        # and open a QIS connection
+        isQisRunning()
+        version = get_QIS_version()
+        if not ((version[0] == 1 and version[1] >= 27) or version[0] > 1):
+            raise ValueError("ERROR - Detected QIS {0[0]}.{0[1]}, Requires QIS version 1.27 or greater".format(version))
+
+        dut = quarchDevice(dut.ConString, ConType='QIS')
+        dut = quarchPPM(dut)    #mike hack
+
+        sleep(1)
+
         # set the name of this module
-        self.name = "AC PAM"
+        self.name = "3 Phase AC PAM"
         self.dut = dut
 
         # Serial numbers (ensure QTL at start)
         self.enclosureSerial = self.dut.sendCommand("*ENCLOSURE?")
         if (self.enclosureSerial.find ("QTL") == -1):
             self.enclosureSerial = "QTL" + self.enclosureSerial
         # fetch the enclosure position
         self.PAMSerial = self.dut.sendCommand ("*SERIAL?")
         if (self.PAMSerial.find ("QTL") == -1):
             self.PAMSerial = "QTL" + self.PAMSerial
         # Fixture Serial
         # fixture serial is retrieved as BCD, we need to convert and pad it
-        self.FixtureSerial = None
-
+        self.FixtureSerial = "QTL" + bcdString(dut.sendCommand("read 0xA102"),4) + "-" + bcdString(dut.sendCommand("read 0xA103"),2) + "-" + bcdString(dut.sendCommand("read 0xA104"),3) # TODO: this should be replaced with fix:serial? command when implemented
         # calObjectSerial Serial
         self.calObjectSerial = self.PAMSerial
         # Filename String
         self.filenameString = self.PAMSerial
         # Code version (FPGA)
         self.idnStr = dut.sendCommand ("*IDN?")
         pos = self.idnStr.upper().find ("FPGA 1:")
@@ -732,27 +1041,40 @@
                 versionStr = versionStr[:pos].strip()            
             else:
                 pass
         else:
             versionStr = "NOT-FOUND"    
         self.Firmware = versionStr.strip()
 
-        self.calibrations = OrderedDict()
-        neutCal = Neutral_Calibration(self.dut, verify=False)
-        calPhaseList = ["L1", "L2", "L3"]
-
-        for phase in calPhaseList:
-            self.calibrations[phase] = {
-                "Voltage" : QTL2582_Calibration(self.dut, calType='V', calPhase=phase, neutral=None),
-                "Current" : QTL2582_Calibration(self.dut, calType='I', calPhase=phase, neutral=neutCal)
-            }
-        self.calibrations["Neutral"] = { "Current" : neutCal }
-
-        self.verifications = OrderedDict()
-        neutVerif = Neutral_Calibration(self.dut, verify=True)
-        for phase in calPhaseList:
-            self.verifications[phase] = {
-                "Voltage" : QTL2582_Calibration(self.dut, calType='V', calPhase=phase, verify=True, neutral=None),
-                "Current" : QTL2582_Calibration(self.dut, calType='I', calPhase=phase, verify=True, neutral=neutVerif)
-            }
-        self.verifications["Neutral"] = { "Current" : neutVerif }
-
+        self.calibrations = {}
+        self.calibrations["L1"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L1"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L1")
+        }
+        self.calibrations["L2"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L2"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L2")
+        }
+        self.calibrations["L3"] = {
+            "Voltage" : self.QTL2582_Voltage_Calibration(self,"L3"),
+            "Current" : self.QTL2582_Current_Calibration(self,"L3")
+        }
+        self.calibrations["Neutral"] = {
+            "Current" : self.QTL2582_Neutral_Current_Calibration(self,"Neutral")
+        }
+
+        self.verifications = {}
+        self.verifications["L1"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L1"),
+            "Current" : self.QTL2582_Current_Verification(self,"L1")
+        }
+        self.verifications["L2"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L2"),
+            "Current" : self.QTL2582_Current_Verification(self,"L2")
+        }
+        self.verifications["L3"] = {
+            "Voltage" : self.QTL2582_Voltage_Verification(self,"L3"),
+            "Current" : self.QTL2582_Current_Verification(self,"L3")
+        }
+        self.verifications["Neutral"] = {
+            "Current" : self.QTL2582_Neutral_Current_Verification(self,"Neutral")
+        }
```

## quarchCalibration/QTL2621.py

```diff
@@ -491,19 +491,19 @@
 
             # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
             #    self.powerModule.setConnections("POWER_1",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_1_volt()
 
         def setCoefficients(self):
 
@@ -573,22 +573,22 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_1_volt()
             #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def setCoefficients(self):
 
@@ -657,22 +657,22 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_1_volt()
             #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def setCoefficients(self):
 
@@ -746,19 +746,19 @@
             
             # Check Host Power is not present
             #while (super().checkLoadVoltage(500,500) != True):
             #    self.powerModule.setConnections("POWER_2",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_2_volt()
 
         def setCoefficients(self):
 
@@ -829,22 +829,22 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_2_volt()
             #leakage = voltage*self.powerModule.calibrations["POWER_2"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_2"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def setCoefficients(self):
 
@@ -913,22 +913,22 @@
             self.powerModule.setConnections("POWER_2","POWER_2")
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_2_volt()
             #leakage = voltage*self.powerModule.calibrations["POWER_2"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_2"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def setCoefficients(self):
 
@@ -988,19 +988,19 @@
 
             # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
                 #self.powerModule.setConnections("POWER_2",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_2_volt()
 
         def finish(self):
 
@@ -1031,19 +1031,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def finish(self):
 
@@ -1074,19 +1074,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def finish(self):
 
@@ -1117,19 +1117,19 @@
 
             # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
                 #self.powerModule.setConnections("POWER_1",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_1_volt()
 
         def finish(self):
 
@@ -1160,19 +1160,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def finish(self):
 
@@ -1203,19 +1203,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.LOAD_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def finish(self):
```

## quarchCalibration/QTL2673.py

```diff
@@ -466,19 +466,19 @@
             ## Check Host Power is not present        
             #while (super().checkLoadVoltage(500,500) != True):
             #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def setCoefficients(self):
 
@@ -548,22 +548,22 @@
             # Check Host Power is present          
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
             #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -633,21 +633,21 @@
             # Check Host Power is present      
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -716,19 +716,19 @@
             #while (super().checkLoadVoltage(500,500) != True):
             #	input("Unexpected voltage detected at load, please check connections")
             #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def setCoefficients(self):
 
@@ -796,22 +796,22 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_aux_volt()
             #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def setCoefficients(self):
 
@@ -871,19 +871,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def finish(self):
 
@@ -915,19 +915,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
             	
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -958,19 +958,19 @@
             # Check Host Power is present	    	    
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1001,19 +1001,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
             	
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def finish(self):
 
@@ -1044,19 +1044,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2673.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
     
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def finish(self):
```

## quarchCalibration/QTL2788.py

```diff
@@ -501,19 +501,19 @@
             ## Check Host Power is not present        
             #while (super().checkLoadVoltage(500,500) != True):
             #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def setCoefficients(self):
 
@@ -583,22 +583,22 @@
             # Check Host Power is present          
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
             #leakage = voltage*self.powerModule.calibrations["12V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["12V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -668,21 +668,21 @@
             # Check Host Power is present      
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_12v_volt()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def setCoefficients(self):
 
@@ -750,19 +750,19 @@
             ## Check Host Power is not present            
             #while (super().checkLoadVoltage(500,500) != True):
             #    input("Unexpected voltage detected at load, please check connections")
             #    self.powerModule.setConnections("5V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5V_volt()
 
         def setCoefficients(self):
 
@@ -833,22 +833,22 @@
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
                 input("Unexpected voltage detected at load, please check connections")
                 self.powerModule.setConnections("5V","5V",reset=True)
 
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_5V_volt()
             #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def setCoefficients(self):
 
@@ -918,22 +918,22 @@
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
 
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_5V_volt()
             #leakage = voltage*self.powerModule.calibrations["5V"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["5V"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def setCoefficients(self):
 
@@ -1005,19 +1005,19 @@
             #while (super().checkLoadVoltage(500,500) != True):
             #	input("Unexpected voltage detected at load, please check connections")
             #	self.powerModule.setConnections("3V3_AUX",None,reset=True)
 
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def setCoefficients(self):
 
@@ -1085,22 +1085,22 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_3v3_aux_volt()
             #leakage = voltage*self.powerModule.calibrations["3.3V Aux"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["3.3V Aux"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def setCoefficients(self):
 
@@ -1160,19 +1160,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_12v_volt()
 
         def finish(self):
 
@@ -1204,19 +1204,19 @@
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
             	
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1247,19 +1247,19 @@
             # Check Host Power is present	    	    
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("12V","12V",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_12v_cur()
 
         def finish(self):
 
@@ -1291,19 +1291,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_5V_volt()
 
         def finish(self):
 
@@ -1334,19 +1334,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
   
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def finish(self):
 
@@ -1379,19 +1379,19 @@
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("5V","5V",reset=True)
             	
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_5V_cur()
 
         def finish(self):
 
@@ -1422,19 +1422,19 @@
             # Check Host Power is not present	    
             while (super().checkLoadVoltage(500,500) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX",None,reset=True)
             	
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_3v3_aux_volt()
 
         def finish(self):
 
@@ -1465,19 +1465,19 @@
             # Check Host Power is present	    
             while (super().checkLoadVoltage(QTL2788.LOAD_VOLTAGE,1000) != True):
             	input("Unexpected voltage detected at load, please check connections")
             	self.powerModule.setConnections("3V3_AUX","3V3_AUX",reset=True)
     
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_3v3_aux_cur()
 
         def finish(self):
```

## quarchCalibration/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.1.3.dev4"
+__version__ = "1.1.4"
```

## quarchCalibration/calibrationUtil.py

```diff
@@ -26,38 +26,39 @@
 # Quarch device control
 from quarchpy import *
 from quarchpy.device import *
 
 # Calibration control
 from quarchCalibration import calCodeVersion
 from quarchCalibration.QTL1944 import *
+from quarchCalibration.QTL1944_06 import *
 from quarchCalibration.QTL2347 import *
 from quarchCalibration.QTL2525 import *
 from quarchCalibration.QTL2788 import *
 from quarchCalibration.QTL2887 import *
 from quarchCalibration.QTL2888 import *
 from quarchCalibration.QTL2621 import *
 from quarchCalibration.QTL2673 import *
 from quarchCalibration.QTL2674 import *
-from quarchCalibration.QTL2582 import *
+#from quarchCalibration.QTL2582 import *
+#from quarchCalibration.QTL2843 import *
 from quarchCalibration.PowerModuleCalibration import*
 from quarchCalibration.calibrationConfig import*
 # UI functions
 from quarchpy.user_interface import *
 # TestCenter functions
 from quarchpy.utilities import TestCenter
 from quarchpy.debug.SystemTest import get_quarchpy_version
 from quarchCalibration.noise_test import test_main as noise_test_main
 from quarchpy.qps import isQpsRunning, startLocalQps
 import time
 # Devices that will show up in the module scan dialog
-scanFilterStr = ["QTL1999", "QTL1995", "QTL1944", "QTL2312", "QTL2098", "QTL2582"]
+scanFilterStr = ["QTL1999", "QTL1995", "QTL1944", "QTL2312", "QTL2098", "QTL2582", "QTL2751", "QTL2789", "QTL2843"]
 my_close_qis = False
 
-
 # Performs a standard calibration of the PPM
 def runCalibration (loadAddress=None, calPath=None, moduleAddress=None, logLevel="warning", calAction=None, extra_args=None, streamPath=None):
 
     myPpmDevice = None
     listOfFailures = []
     try:
         # Display the app title to the user
@@ -89,17 +90,21 @@
                     # Clear the list of failures as we are starting a new action
                     listOfFailures = []
                     calAction = show_action_menu(calAction)
             if (calAction == 'quit'):
                 sys.exit(0)
             elif(calAction == "noise_test"):
                 listOfTestResults = dut.noiseTest()
-                for testResult in listOfTestResults:
-                    if testResult["result"] is False:
-                        listOfFailures.append(testResult)
+                if listOfTestResults !=None:
+                    for testResult in listOfTestResults:
+                        if testResult["result"] is False:
+                            listOfFailures.append(testResult)
+                else:# Only reached if the DUT has no noise test.
+                    skippedNoiseTestResult={'title': 'noise test skipped', 'result': False, 'worst case': 'NA', 'report': 'noise test skipped due to module not having one'}
+                    listOfFailures.append(skippedNoiseTestResult)
                 calAction=None
             elif (calAction == 'calibrate') or (calAction == 'verify'):
                 # Perform the Calibration or Verification
                 # get CalibrationTime
                 calTime = datetime.datetime.now()
                 # open report for writing and write system header
                 fileName = calPath + "\\" + dut.filenameString + "_" + calTime.strftime("%d-%m-%y_%H-%M") + "-" + calAction + ".txt"
@@ -203,18 +208,28 @@
         except:
             printText("Failed to connect to " + str(calibrationResources["moduleString"]))
             calibrationResources["moduleString"] = None
     serialNumber = myPpmDevice.sendCommand("*SERIAL?")
     success = False
     fixtureId = None
     # Identify and create a power module object
+    # If this is an HD PPM
     if ('1944' in serialNumber):
-        # create HD Power Module Object
-        dut = QTL1944(myPpmDevice)
-        success = True
+        # is this ppm original or plus version
+        # get the FPGA
+        FPGAPart = myPpmDevice.sendCommand("read 0xfffe")
+        if ('2899' in FPGAPart):
+            # create HD Plus Power Module Object
+            dut = QTL1944_06(myPpmDevice)
+            success = True
+        else:
+            # create HD Power Module Object
+            dut = QTL1944(myPpmDevice)
+            success = True
+    # Else if this is a Power Analysis Module
     elif ('2098' in serialNumber):
         # this is a Power Analysis Module, we need to detect the fixture
         fixtureId = myPpmDevice.sendCommand("read 0xA102")
         # PCIe x16 AIC Fixture
         if ('2347' in fixtureId):
             dut = QTL2347(myPpmDevice)
             success = True
@@ -242,22 +257,22 @@
         if ('2888' in fixtureId):
             dut = QTL2888(myPpmDevice)
             success = True
         # 2-Channel PAM Mezzanine
         if ('2621' in fixtureId):
             dut = QTL2621(myPpmDevice)
             success = True
+    # Else if this is a 3 phase AC PAM
     elif ('2582' in serialNumber) or ('2751' in serialNumber) or ('2789' in serialNumber):
-        # myPpmDevice.resetDevice(timeout=1.0)
-        myPpmDevice.closeConnection()
-        isQisRunning()
-        version = get_QIS_version()
-        if not ((version[0] == 1 and version[1] >= 27) or version[0] > 1):
-            raise ValueError("ERROR - Detected QIS {0[0]}.{0[1]}, Requires QIS version 1.27 or greater".format(version))
-
+        dut = QTL2582(myPpmDevice)
+        success = True
+    # Else if this is an IEC PAM
+    elif ('2843' in serialNumber):
+        dut = QTL2843(myPpmDevice)
+        success = True
         connectionType = deviceString.split(':')
         connectionName = 'QTL' + serialNumber
         connStr = connectionType[0] + "::" + connectionName
         # myPpmDevice = quarchDevice(calibrationResources["moduleString"], ConType='QIS')
         myPpmDevice = quarchDevice(connStr, ConType='QIS')
         # version = myPpmDevice.sendCommand("$version")
         # spversion = version.split('.')
@@ -366,24 +381,25 @@
     parser = argparse.ArgumentParser(description='Calibration utility parameters')
     parser.add_argument('-a', '--action', help='Calibration action to perform', choices=['calibrate', 'verify', 'noise_test'], type=str.lower)
     parser.add_argument('-m', '--module', help='IP Address or netBIOS name of power module to calibrate', type=str.lower)
     parser.add_argument('-i', '--instr', help='IP Address or netBIOS name of calibration instrument', type=str.lower)
     parser.add_argument('-p', '--path', help='Path to store calibration logs', type=str.lower)
     parser.add_argument('-l', '--logging', help='Level of logging to report', choices=['warning', 'error', 'debug'], type=str.lower,default='warning')
     parser.add_argument('-u', '--userMode',  help=argparse.SUPPRESS,choices=['console','testcenter'], type=str.lower,default='console') #Passes the output to testcenter instead of the console Internal Use
+    parser.add_argument('-s', '--streamPath', help='Path to store QPS stream', type=str)
+
     args, extra_args = parser.parse_known_args(argstring)
-    
     # Create a user interface object
     thisInterface = User_interface(args.userMode)
-
+    if extra_args != []:
+        printText("failed to Parse the following ARG/s: "+str(extra_args))
     # Call the main calibration function, passing the provided arguments
-    return runCalibration(loadAddress=args.instr, calPath=args.path, moduleAddress=args.module, logLevel=args.logging, calAction=args.action, extra_args=extra_args)
+    return runCalibration(loadAddress=args.instr, calPath=args.path, moduleAddress=args.module, logLevel=args.logging, calAction=args.action, streamPath=args.streamPath)
 
 #Command to run from terminal.
 #python -m quarchCalibration -mUSB:QTL1999-01-002 -acalibrate -i192.168.1.210 -pC:\\Users\\sboon\\Desktop\\CalTesting
 if __name__ == "__main__":
     main (sys.argv[1:])
-
-    #main(["-anoise_test", "-mUSB:QTL2312-01-035",  "-pC:\\Users\\Public\\Documents\\calibrationReports"])
+    #main(["-anoise_test", "-mUSB:QTL2312-01-035",  "-pC:\\Users\\Public\\Documents\\calibrationReports", "-sQ:\\Production\\Calibration\\NoiseTestStreams"])
     #Example or args parsing
     #The argument do the following, set the action to calibrate, define the IP address of the module, defignt he IP saddress of the calibration instument, set the save location of the calibration report file, and set the logging level to warning. 
     #main (["-acalibrate", "-mTCP:192.168.1.170", "--instrREST:192.168.1.205",  "-pC:\\Users\\Public\\Document\\QuarchPythonCalibration", "-lwarning"])
```

## quarchCalibration/elpaSine.py

```diff
@@ -1,59 +1,40 @@
-
 import socket
 import unittest
 import time
 import logging
 import os
 import re
 
-class elpaSine:
-    def __init__(self, addr="192.168.1.239"): # uses fixed IP address. Might not support DHCP
+class ElpaSine:
+    def __init__(self, addr):
         self.TIMEOUT = 10
         self.BUFFER_SIZE = 4096
         self.connection = None
         self.addr = addr
         self.numeric = re.compile("(\+|-)([0-9\.]+)")
         self.measurementType = "RMS"
         self.measurementTypeList = ["PEAK", "RMS"]
         self.maxCurrentLimit = 8.0
         self.isOpen = False
         self.commandDelay = 0.05 # It errors on back to back comms, delay needed.
         self.lastResult = None
 
-    def discover(self):
-        self.devices = {}
-
-        self.tsock = socket(AF_INET, SOCK_DGRAM)
-        self.tsock.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)
-        self.tsock.sendto(b'C!09               \n', ('255.255.255.255', 36))
-
-        self.rsock = socket(AF_INET, SOCK_DGRAM)
-
-        msgs = self.rsock.recvfrom(256)
-        self.rsock.close()
-
-        strmsg = msgs[0].decode("utf8").split(",")
-        strdict = {y[0]: y[1] for y in [x.split("=") for x in strmsg[2:]]}
-
-        self.devices[strdict['ALIAS']] = strdict['IP']
-
     def openConnection (self, connectionString = None):
         #print("DEBUG: openConnection")
         if (connectionString is not None):
             self.conString = connectionString
         else:
             self.conString = self.addr
         self.connection = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
         self.connection.settimeout(self.TIMEOUT)
         self.connection.connect((self.conString,4001))
         self.isOpen = True
 
         # ELPA-SINE ignores first command, so send a dummy command to wake it up
-        #self.connection.send(("*IDN?\r\n").encode('latin-1'))
         self.sendCommandQuery("MEAS:TYPE "+self.measurementType, response=False)
 
 
     def closeConnection (self):
         #print("DEBUG: closeConnection")
         self.connection.close()
         self.isOpen = False
@@ -109,38 +90,120 @@
                 return - float(mobj.group(2))
             else:
                 return float(mobj.group(2))
         else:
             raise ValueError(os.path.basename(__file__) + ": unable to parse numeric value {} from ELPA-SINE".format(result.strip()))
 
     def getVoltageMeasurement(self, measType="RMS"):
+        self.sendCommandQuery("PRES:AVG 16", response=False)
         return self.getMeasurement("MEAS:VOLT?", measType=measType)
 
     def getCurrentMeasurement(self, measType="RMS"):
+        self.sendCommandQuery("PRES:AVG 16", response=False)
         rv = self.getMeasurement("MEAS:CURR?", measType=measType)
         if rv == 0.0:
             print("Warning: ELPA returned measurement of {0:4.2f} from response of {1:s}".format(rv, self.lastResult))
         return rv
 
+    def getPowerMeasurement(self, measType="Active"):
+        self.sendCommandQuery("PRES:AVG 16", response=False)
+        rv = self.getMeasurement("MEAS:POW?")
+        if rv == 0.0:
+            print("Warning: ELPA returned measurement of {0:4.2f} from response of {1:s}".format(rv, self.lastResult))
+        return rv
+
     def setLoadCurrent(self, value):
-        self.sendCommandQuery("STAT:MODE:LIN", response=False)
         if value > self.maxCurrentLimit:
             raise ValueError("ERROR - ELPA-SINE should not be set to more than {} A".format(self.maxCurrentLimit))
-        self.sendCommandQuery("PRES:LIN:A {0:3.1f}".format(value), response=False)
-
-    def enable(self):
-        self.sendCommandQuery("STAT:LOAD ON", response=False)
-
-    def disable(self):
-        self.sendCommandQuery("STAT:LOAD OFF", response=False)
+        else:
+            self.sendCommandQuery("STAT:MODE:CC", response=False)
+            self.sendCommandQuery("PRES:FREQ AUTO", response=False)       
+            self.sendCommandQuery("PRES:CC:A {0:3.1f}".format(value), response=False)
+
+    '''
+    Enable/disable the outputs
+    '''
+    def setOutputEnable (self, enableState):
+        if (enableState == True):
+            result = self.sendCommandQuery("STAT:LOAD ON", response=False)
+        else:
+            result = self.sendCommandQuery("STAT:LOAD OFF", response=False)
+            
+        return result
+        
+    '''
+    Return the output enable state as a boolean
+    '''
+    def getOutputEnable (self):
+        result = self.sendCommandQuery ("OUTP?")
+        if (int(result) == 1):
+            return True
+        else:
+            return False
 
-    # Added for compatability with Keithly
+    # Added for compatability with Keithley
     def reset(self):
         pass
 
+    # Discover Elpa-sine devices through UDP broadcast
+    # returns ???
+    # This function makes a lot of assumptions about the data and certainly could be a lot more robust
+    @staticmethod
+    def discover():
+
+        logging.debug(os.path.basename(__file__) + ": Searching for Elpa-Sine AC loads: ")
+
+        devices = []
+
+        ipList = socket.gethostbyname_ex(socket.gethostname())
+        logging.debug(os.path.basename(__file__) + ": Discovered the following interfaces: " + str(ipList))
+
+        # broadcast/listen on each interface
+
+        responses = []
+
+        for ip in ipList[2]:
+
+            logging.debug(os.path.basename(__file__) + ": Broadcasting on : " + ip)
+
+            tsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+            tsock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
+            # wait 1 second for a response
+            tsock.settimeout(1)
+            tsock.bind((ip,56732))
+            tsock.sendto(b'C!09               \n', ('255.255.255.255', 36))
+
+            # Receive messages until timeout.
+            while True:
+                try:
+                    responses.append(tsock.recvfrom(1024))
+                except:
+                    break
+
+            tsock.close()
+
+
+        logging.debug(os.path.basename(__file__) + ": Received the following responses: " + str(responses))
+
+        # for each response received
+        for response in responses:
+            try:
+                prefix = response[0][0:4]
+                ip_addr = ".".join([str(x) for x in response[0][4:8]])
+                mask = ".".join([str(x) for x in response[0][8:12]])
+                mac = ":".join([format(x,'02X') for x in response[0][12:18]])
+                device = int(response[0][18])<<8 + int(response[0][19])
+                if prefix == b'C!09':
+                    devices.append({"prefix":prefix,"ip":ip_addr,"mask":mask,"mac":mac,"device":device})
+            except:
+                # malformed data received
+                break
+
+        return devices
+
 class testElpaSine(unittest.TestCase):
     def test_connect(self):
         elpa = elpaSine()
 
         elpa.openConnection(self.addr)
         response = elpa.sendCommandQuery ("*IDN?")
         self.assertEqual("ELPA-SINE 3750", response)
```

## quarchCalibration/noise_test.py

```diff
@@ -18,32 +18,29 @@
 # TestCenter functions
 from quarchpy.utilities import TestCenter
 from quarchCalibration.calibrationConfig import *
 
 current_milli_time = lambda: int(round(time.time() * 1000))
 
 
-def test_main(powerModule, myQpsDevice, stream_path="",report_path="", close_QPS=False):
+def test_main(powerModule, myQpsDevice, close_QPS=False):
     ###HardcoddedVals### TODO Delete these and have all vals passed in.
     # #These now come from dut
     # module_address ="USB:QTL2312-01-035"
     # channel_dict_max_limits={"current +3.3V Max":"250uA", "current +12V Max":"250uA", "current +3.3Vaux Max":"250uA"}
     # test_length = 2 #10
     # averaging_value="4" # 4=16us
 
-    # #these come from the user input at the start of the calibrationUtil
-    # stream_path ="C:\\Users\\sboon\\Desktop\\deleteme\\noiseTest\\noiseTestStreams"
-    # report_path = "C:\\Users\\sboon\\Desktop\\deleteme\\noiseTest\\noiseTestReports"
     testName = "NoiseTest"
-
+    startTestBlock(testName)
     ###EndHardcoddedVals###
     stream_path = calibrationResources["streamPath"]
     report_path = calibrationResources["calPath"]
-    # stream_path = get_check_valid_calPath(calibrationResources["streamPath"]) # Should have been done before this stage
-    # report_path = get_check_valid_calPath(calibrationResources["calPath"])
+    stream_path = get_check_valid_calPath(calibrationResources["streamPath"]) # Should have been checked at start of calUtil but needs checked again incase of changes during script execution such as "change stream dir"
+    report_path = get_check_valid_calPath(calibrationResources["calPath"])
 
     if not isQpsRunning():
         raise Exception("QPS Should be started and device connected before this point.")
 
     # Record contype, change con type to QPS then at the end of the script change contype back to original.
     DUTserialNumber = powerModule.dut.ConString.split(":")[-1]
     #module_set_up(myQpsDevice, DUTserialNumber) # TODO Module set up is needed for HD to turn power on and set volt to 0.
@@ -109,29 +106,31 @@
             passed = False
             all_tests_passed = False
             time.sleep(0.1)
         else:
             result = "PASS"
             passed = True
             time.sleep(0.1)
-        logSimpleResult(channel_name, passed)
+        startTestBlock(channel_name)
+        logSimpleResult(channel_name+" Channel Value:"+str(channel_value)+channel_unit+"  Max Value:"+ str(max_value)+max_value_unit, passed)
+        endTestBlock()
         test_overview.append([channel_name, result, channel_value, max_value])
     # TODO do the same for min linits if any for channel_name, max_value in channel_dict_min_limits.items():
     printToConsole = True if(User_interface.instance.selectedInterface == "console") else False
     resultsTable = displayTable(tableData=test_overview, tableHeaders=("Test Name", "Result", "Value", "Limit"), printToConsole=printToConsole)
     reportFile.write(resultsTable)
     reportFile.flush()
     reportFile.close()
+    endTestBlock()
     #Comment this out if you don't want to view recordings of failed tests
-    if all_tests_passed == False: close_QPS =False #This should take a screenshot and save it to the same dir as the report file.
+    if all_tests_passed == True: close_QPS =True #This should take a screenshot and save it to the same dir as the report file.
     if close_QPS == False:
         showDialog(title="Quit QPS?", message="Continue when you are you ready to close QPS.")
         close_QPS=True
-    if close_QPS:
-        qps.closeQps()
+    qps.closeQps()
     return test_overview
 
 def metric_prefix_converter(input_str):
     """
     Convert a value to it's base unit
 
     :param input_str: String, value to change (E.g.  1.5432kW)
```

## quarchCalibration/pamCommon.py

```diff
@@ -501,19 +501,19 @@
 
             # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
             #    self.powerModule.setConnections("POWER_1",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_1_volt()
 
         def setCoefficients(self):
 
@@ -583,21 +583,21 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.HOST_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_1_volt()
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def setCoefficients(self):
 
@@ -666,22 +666,22 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.HOST_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_1","POWER_1",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
             # read device voltage and add leakage current to the reference
             voltage =  super().meas_POWER_1_volt()
             #leakage = voltage*self.powerModule.calibrations["POWER_1"]["Leakage"].multiplier.originalValue() + self.powerModule.calibrations["POWER_1"]["Leakage"].offset.originalValue()
-            return load_meas_cur(self.powerModule.calInstrument)# + leakage
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000# + leakage
 
         def readVal(self):
 
             return super().meas_POWER_1_cur()
 
         def setCoefficients(self):
 
@@ -741,19 +741,19 @@
 
             # Check Host Power is present
             #while (super().checkLoadVoltage(500,500) != True):
                 #self.powerModule.setConnections("POWER_2",None,reset=True)
 
         def setRef(self,value):
 
-            return load_set_volt(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceVoltage(value/1000,currentLimit="1e-1")
 
         def readRef(self):
 
-            return load_meas_volt(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadVoltage()*1000
 
         def readVal(self):
 
             return super().meas_POWER_2_volt()
 
         def finish(self):
 
@@ -784,19 +784,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.HOST_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def finish(self):
 
@@ -827,19 +827,19 @@
 
             # Check Host Power is present
             while (super().checkLoadVoltage(QTL2621.HOST_VOLTAGE,1000) != True):
                 self.powerModule.setConnections("POWER_2","POWER_2",reset=True)
 
         def setRef(self,value):
 
-            load_set_cur(self.powerModule.calInstrument,value)
+            self.powerModule.calInstrument.setReferenceCurrent(value/1000000)
 
         def readRef(self):
 
-            return load_meas_cur(self.powerModule.calInstrument)
+            return self.powerModule.calInstrument.measureLoadCurrent()*1000000
 
         def readVal(self):
 
             return super().meas_POWER_2_cur()
 
         def finish(self):
```

## Comparing `quarchCalibration-1.1.3.dev4.dist-info/RECORD` & `quarchCalibration-1.1.4.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,28 +1,31 @@
-quarchCalibration/ET2260.py,sha256=PlM1igqKQbY5ewG0Eu72HSFkU0_B5Cubpswi6WikyOg,2934
-quarchCalibration/PowerModuleCalibration.py,sha256=Sc3hxcRxzMBqFzoIOQM95BZJkhg089yf5uESOt-gCV0,19974
-quarchCalibration/QTL1944.py,sha256=6b0YtxYZgDSzn7MQF7MZQG_lrgx9p8Vd38Bha7PArhA,64834
-quarchCalibration/QTL2347.py,sha256=a06UgBC3nOSHBxOug41QyCFyVYZTlIzWt_IovwaoZms,74125
-quarchCalibration/QTL2525.py,sha256=BEyumcqwXvKTgQtPia-b99rbualnCZLdon0O2jnSpmQ,64175
-quarchCalibration/QTL2582.py,sha256=FuI36F4QiLNEfpkt20TLX1wKIs4ZVur9CC-QpwAC7AI,29042
-quarchCalibration/QTL2621.py,sha256=jXwiYcSQCs5rzK0o2YChbTOWfF3VpkBwRiY2U6y_Qno,53920
-quarchCalibration/QTL2673.py,sha256=3rJufGgWtitm1gPmuAkFnaKzDlOAK2USX660GykpFbc,46762
+quarchCalibration/ET2260.py,sha256=9nt9CfIbqz8kcGSBQnLsyScxPU3e7oNBlGg3TvWfkKQ,7185
+quarchCalibration/PowerModuleCalibration.py,sha256=BOHF-p_SHJYAI9uqn5Jh4RHaYAyhCODAzX-_AssWRG4,25831
+quarchCalibration/QTL1944.py,sha256=ePH3WLO6ci8uE3APnGZmVuu-5RAsJ117IZOnN4DJXkQ,65176
+quarchCalibration/QTL1944_06.py,sha256=ii6p30imagmHZq9A6jtQi5P8CfDL1sudkjZle9JZtZY,68018
+quarchCalibration/QTL2347.py,sha256=BSp27ILGeve2o9n0VoB0CROcQxBSP22P_aVSUiatu10,74754
+quarchCalibration/QTL2525.py,sha256=byyxnxllbLmCUhNqKZljbOwh6TOJvnq2mGs3Ri85XZc,64669
+quarchCalibration/QTL2582.py,sha256=-zAmaP_Wcem71VhuNleCQoT4UvZ6aPz9hgdFVpLP5DY,44492
+quarchCalibration/QTL2621.py,sha256=xE0bH2lxLAgUVCEekDyWxGj0nvipwmZrqjiNSz0ijy8,54288
+quarchCalibration/QTL2673.py,sha256=g9JFrrNusqr_9wBU80OdkYCOzdUOEI2P7rnSbYU790o,47072
 quarchCalibration/QTL2674.py,sha256=5Qxr9vOx-A6spwox6VqFnc6EEJM1m-ejf9lvyajS41U,46762
-quarchCalibration/QTL2788.py,sha256=eLLbhrpN-bsZ2DX6pu6HOnvruoKKZPMiekI6nRooOJ8,64175
+quarchCalibration/QTL2788.py,sha256=pWlfDiItKUWiVdx1NBwxr8icjtBXOsG1Ok9x3TiTDKk,64669
+quarchCalibration/QTL2843.py,sha256=1S6mR0HXyLsiOc_giooM4t2ZG2ckN9HnamsF9glbuWg,46445
 quarchCalibration/QTL2887.py,sha256=zJi_jjis4S7P3wbQHY40doKExYoVAGC1UrtVBGB2I0Y,46762
 quarchCalibration/QTL2888.py,sha256=AKlSBO3-U75J78URiLqVsXmtv1PMSOQUpdJFPCpXd-Q,46762
 quarchCalibration/__init__.py,sha256=mbzK24iscOr7nwFCEupkdLEp-M2Vs2W7mCR76GZz20Q,526
 quarchCalibration/__main__.py,sha256=gZxkbC5-1lzb_PZnjMW68hExuCWkFevjP5ED39w1KSo,82
-quarchCalibration/_version.py,sha256=v4SQUv5IgHPSQh7-foSOgp1QdwPk41W51dV6VZLg448,26
+quarchCalibration/_version.py,sha256=PDawFA4JZ6VmetYHnwoA5t79JrblMQ6S08w36AKgCB8,21
 quarchCalibration/calibrationConfig.py,sha256=kfyTEUJFHFh9WHiudgXIA2gmW53IB1cc76523YWsOQM,713
-quarchCalibration/calibrationUtil.py,sha256=tgBipAKpSE9sXxJGByt0gN_koT5JbYEdHd_XjjGX-F0,18110
+quarchCalibration/calibrationUtil.py,sha256=mFt2qm_lvfJ0LcrMnvrcSwkIkaYQbR2GuF3P9QNkZ-g,19104
 quarchCalibration/deviceHelpers.py,sha256=O4K3JnldZjFoCPcrBqhDgrdSeDEiA-eR5_wM5IHzKPw,4126
-quarchCalibration/elpaSine.py,sha256=5Qhej6LxMdePnt6OuEhmQdgIIfYe6h3WFRBCyDpCrO0,7562
+quarchCalibration/elpaSine.py,sha256=zxpEgHTJI3tm6P2V5gUsi4th6KzOb7ORjYrHVnL6Ev4,9926
 quarchCalibration/keithley_2460_control.py,sha256=8BjRY7R1mViFcqOOIUUyqcIltUDnz1DkZwUSm44heZU,22184
-quarchCalibration/noise_test.py,sha256=Vj5-cQnh3YjbcTVGVWuztQglYZ_rYy1DZF452gb2YmA,9380
-quarchCalibration/pamCommon.py,sha256=8nNemOCIIp9afys89QB8_hAk9jYmx3CfQqYNp94Ysy4,39277
+quarchCalibration/noise_test.py,sha256=4kkI4Nt9HR-2ACBjD8PcGA3j7b0s30kUczOFgoxhKM4,9375
+quarchCalibration/pamCommon.py,sha256=Miji_Ewuiyq-92EGb1YzWttWM_zNwxag4KpCXrR895E,39461
+quarchCalibration/threePhaseSwitchBox.py,sha256=gsSx86WyXwnOMR9vSZUvEI50fmfLfjzBOhLpejMlUJE,7520
 quarchCalibration/docs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 quarchCalibration/docs/conf.py,sha256=QQjLji6g2mzCksnfluxXWHGgxpV5mrtGiTkH5kMCRWo,2076
-quarchCalibration-1.1.3.dev4.dist-info/METADATA,sha256=7KZEA5OUFea5VPP-ZGH_fqF_a2157UMpHPHDQMAOQDA,1381
-quarchCalibration-1.1.3.dev4.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
-quarchCalibration-1.1.3.dev4.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
-quarchCalibration-1.1.3.dev4.dist-info/RECORD,,
+quarchCalibration-1.1.4.dist-info/METADATA,sha256=tYmEmRA-I2QlfHeoFcAcUVnBSNc-GOvx8haVa__xvUY,1533
+quarchCalibration-1.1.4.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+quarchCalibration-1.1.4.dist-info/top_level.txt,sha256=4sTt-nDiODeU-FUOWSdIZfUEK8olrtX1wbjExcJ-_3M,18
+quarchCalibration-1.1.4.dist-info/RECORD,,
```

