# Comparing `tmp/azure-mgmt-databox-2.0.0.zip` & `tmp/azure-mgmt-databox-2.0.0b1.zip`

## zipinfo {}

```diff
@@ -1,410 +1,410 @@
-Zip file size: 939599 bytes, number of entries: 408
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/tests/
--rw-rw-r--  2.0 unx      622 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/_meta.json
--rw-rw-r--  2.0 unx      213 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/MANIFEST.in
--rw-rw-r--  2.0 unx    12883 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/CHANGELOG.md
--rw-rw-r--  2.0 unx     2829 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/setup.py
--rw-rw-r--  2.0 unx     2146 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/README.md
--rw-rw-r--  2.0 unx     1074 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/LICENSE
--rw-rw-r--  2.0 unx       38 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/setup.cfg
--rw-rw-r--  2.0 unx    15917 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx      124 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/requires.txt
--rw-rw-r--  2.0 unx    15917 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx    18613 b- defN 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/SOURCES.txt
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/
--rw-rw-r--  2.0 unx     3161 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/_configuration.py
--rw-rw-r--  2.0 unx    78854 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/_serialization.py
--rw-rw-r--  2.0 unx    16224 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/_data_box_management_client.py
--rw-rw-r--  2.0 unx      360 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/models.py
--rw-rw-r--  2.0 unx      726 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/__init__.py
--rw-rw-r--  2.0 unx       26 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/py.typed
--rw-rw-r--  2.0 unx      345 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/_version.py
--rw-rw-r--  2.0 unx     3829 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/_operations_mixin.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_patch.py
--rw-rw-r--  2.0 unx    12699 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/__init__.py
--rw-rw-r--  2.0 unx    15602 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   276538 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80017 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66227 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_patch.py
--rw-rw-r--  2.0 unx    13173 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/__init__.py
--rw-rw-r--  2.0 unx    16909 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   291959 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80391 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66601 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_patch.py
--rw-rw-r--  2.0 unx     4497 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_patch.py
--rw-rw-r--  2.0 unx    10297 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/__init__.py
--rw-rw-r--  2.0 unx    11199 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   197003 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49669 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    71909 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6448 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4641 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41206 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    59640 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5757 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_patch.py
--rw-rw-r--  2.0 unx     4497 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_patch.py
--rw-rw-r--  2.0 unx    10737 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/__init__.py
--rw-rw-r--  2.0 unx    11494 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   205666 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49669 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    71909 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6448 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4641 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41206 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    59640 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5757 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     3225 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_configuration.py
--rw-rw-r--  2.0 unx    16650 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      571 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/__init__.py
--rw-rw-r--  2.0 unx     3883 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_operations_mixin.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_patch.py
--rw-rw-r--  2.0 unx    10991 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/__init__.py
--rw-rw-r--  2.0 unx    12223 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   211627 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    71942 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    59694 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_patch.py
--rw-rw-r--  2.0 unx     4497 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_patch.py
--rw-rw-r--  2.0 unx     8889 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/__init__.py
--rw-rw-r--  2.0 unx     9583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   161598 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49165 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    70911 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6335 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4641 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    40987 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    58642 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5644 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_patch.py
--rw-rw-r--  2.0 unx    13081 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/__init__.py
--rw-rw-r--  2.0 unx    16627 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   289245 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80391 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66601 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_patch.py
--rw-rw-r--  2.0 unx    10991 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/__init__.py
--rw-rw-r--  2.0 unx    11793 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   211513 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    71942 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    59694 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_patch.py
--rw-rw-r--  2.0 unx     4497 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_patch.py
--rw-rw-r--  2.0 unx     5523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/__init__.py
--rw-rw-r--  2.0 unx     6468 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   104233 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/__init__.py
--rw-rw-r--  2.0 unx    17659 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    70546 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6335 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4641 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      904 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    15109 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    58642 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5644 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_patch.py
--rw-rw-r--  2.0 unx    12625 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/__init__.py
--rw-rw-r--  2.0 unx    15570 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   272923 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80017 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66227 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     3491 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_patch.py
--rw-rw-r--  2.0 unx     4615 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx    12277 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx    15186 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   260696 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py
--rw-rw-r--  2.0 unx     9289 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx    50100 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80483 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6513 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py
--rw-rw-r--  2.0 unx     3539 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx     4759 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7742 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66595 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/
--rw-rw-r--  2.0 unx     1835 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_vendor.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_patch.py
--rw-rw-r--  2.0 unx     4583 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py
--rw-rw-r--  2.0 unx      910 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_version.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_patch.py
--rw-rw-r--  2.0 unx    13081 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/__init__.py
--rw-rw-r--  2.0 unx    16627 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py
--rw-rw-r--  2.0 unx   287025 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_patch.py
--rw-rw-r--  2.0 unx     9248 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/__init__.py
--rw-rw-r--  2.0 unx    49702 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py
--rw-rw-r--  2.0 unx    80391 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     6481 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-26 03:18 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/
--rw-rw-r--  2.0 unx     1070 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_patch.py
--rw-rw-r--  2.0 unx     4727 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py
--rw-rw-r--  2.0 unx      857 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     7709 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py
--rw-rw-r--  2.0 unx     1041 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41260 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py
--rw-rw-r--  2.0 unx    66601 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py
--rw-rw-r--  2.0 unx     5811 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     9515 b- defN 23-May-26 03:17 azure-mgmt-databox-2.0.0/tests/disable_test_cli_mgmt_databox.py
-408 files, 6567700 bytes uncompressed, 846711 bytes compressed:  87.1%
+Zip file size: 948529 bytes, number of entries: 408
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/tests/
+-rw-rw-r--  2.0 unx     2117 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/README.md
+-rw-rw-r--  2.0 unx       38 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/setup.cfg
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/LICENSE
+-rw-rw-r--  2.0 unx      622 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/_meta.json
+-rw-rw-r--  2.0 unx      213 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx     8634 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2821 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/setup.py
+-rw-rw-r--  2.0 unx    11641 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/PKG-INFO
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_version.py
+-rw-rw-r--  2.0 unx     3161 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_configuration.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/py.typed
+-rw-rw-r--  2.0 unx    78842 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_serialization.py
+-rw-rw-r--  2.0 unx    16224 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      360 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/models.py
+-rw-rw-r--  2.0 unx      726 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/__init__.py
+-rw-rw-r--  2.0 unx     3829 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_operations_mixin.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_patch.py
+-rw-rw-r--  2.0 unx    15602 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    12699 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/__init__.py
+-rw-rw-r--  2.0 unx   276538 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    80389 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    66419 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_patch.py
+-rw-rw-r--  2.0 unx    15570 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    12625 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/__init__.py
+-rw-rw-r--  2.0 unx   272923 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    80389 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    66419 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_patch.py
+-rw-rw-r--  2.0 unx    12223 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    10991 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/__init__.py
+-rw-rw-r--  2.0 unx   211627 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    72304 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    59894 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_patch.py
+-rw-rw-r--  2.0 unx    16627 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    13081 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/__init__.py
+-rw-rw-r--  2.0 unx   287025 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    80763 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    66793 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_configuration.py
+-rw-rw-r--  2.0 unx     4478 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_patch.py
+-rw-rw-r--  2.0 unx    11494 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    10737 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/__init__.py
+-rw-rw-r--  2.0 unx   205666 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49856 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    72271 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6684 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4617 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41384 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    59840 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5975 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3748 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_configuration.py
+-rw-rw-r--  2.0 unx     4596 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx    15186 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    12277 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx   260696 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    50599 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9581 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    81465 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx     6801 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3796 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4735 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41941 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7994 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    67177 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6083 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_patch.py
+-rw-rw-r--  2.0 unx    11793 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    10991 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/__init__.py
+-rw-rw-r--  2.0 unx   211513 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    72304 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    59894 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_patch.py
+-rw-rw-r--  2.0 unx    16627 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    13081 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/__init__.py
+-rw-rw-r--  2.0 unx   287784 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    80763 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    66793 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_configuration.py
+-rw-rw-r--  2.0 unx     4478 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_patch.py
+-rw-rw-r--  2.0 unx    11199 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    10297 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/__init__.py
+-rw-rw-r--  2.0 unx   197003 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49856 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    72271 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6684 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4617 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41384 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    59840 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5975 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_configuration.py
+-rw-rw-r--  2.0 unx     4478 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_patch.py
+-rw-rw-r--  2.0 unx     6468 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx     5523 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/__init__.py
+-rw-rw-r--  2.0 unx   104233 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    17905 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    70908 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6571 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4617 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    15319 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    58842 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5862 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_configuration.py
+-rw-rw-r--  2.0 unx     4478 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_patch.py
+-rw-rw-r--  2.0 unx     9583 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx     8889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/__init__.py
+-rw-rw-r--  2.0 unx   161598 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49381 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    71273 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6571 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4617 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41161 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx    58842 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx      904 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5862 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     3225 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_configuration.py
+-rw-rw-r--  2.0 unx    16650 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      571 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/__init__.py
+-rw-rw-r--  2.0 unx     3883 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_operations_mixin.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_patch.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_version.py
+-rw-rw-r--  2.0 unx     1835 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_vendor.py
+-rw-rw-r--  2.0 unx     3724 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_configuration.py
+-rw-rw-r--  2.0 unx     4564 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      910 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_patch.py
+-rw-rw-r--  2.0 unx    16627 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py
+-rw-rw-r--  2.0 unx    13081 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/__init__.py
+-rw-rw-r--  2.0 unx   287784 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    49889 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     9488 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    80763 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6717 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx     3772 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py
+-rw-rw-r--  2.0 unx      857 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    41438 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py
+-rw-rw-r--  2.0 unx     7931 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py
+-rw-rw-r--  2.0 unx    66793 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py
+-rw-rw-r--  2.0 unx     1041 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6029 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx      116 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    18613 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx    11641 b- defN 23-Feb-13 05:57 azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx     9515 b- defN 23-Feb-13 05:56 azure-mgmt-databox-2.0.0b1/tests/disable_test_cli_mgmt_databox.py
+408 files, 6576527 bytes uncompressed, 854009 bytes compressed:  87.0%
```

## zipnote {}

```diff
@@ -1,1225 +1,1225 @@
-Filename: azure-mgmt-databox-2.0.0/
+Filename: azure-mgmt-databox-2.0.0b1/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/
+Filename: azure-mgmt-databox-2.0.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/tests/
+Filename: azure-mgmt-databox-2.0.0b1/tests/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/_meta.json
+Filename: azure-mgmt-databox-2.0.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/MANIFEST.in
+Filename: azure-mgmt-databox-2.0.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/CHANGELOG.md
+Filename: azure-mgmt-databox-2.0.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/setup.py
+Filename: azure-mgmt-databox-2.0.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/README.md
+Filename: azure-mgmt-databox-2.0.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/LICENSE
+Filename: azure-mgmt-databox-2.0.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/setup.cfg
+Filename: azure-mgmt-databox-2.0.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/PKG-INFO
+Filename: azure-mgmt-databox-2.0.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/dependency_links.txt
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/top_level.txt
+Filename: azure-mgmt-databox-2.0.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/not-zip-safe
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/requires.txt
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/PKG-INFO
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/SOURCES.txt
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/py.typed
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/models.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/_serialization.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_operations_mixin.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/models.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/py.typed
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/_operations_mixin.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_operations_mixin.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_operations_mixin.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_version.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_models_py3.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_vendor.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_configuration.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py
+Filename: azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-databox-2.0.0/tests/disable_test_cli_mgmt_databox.py
+Filename: azure-mgmt-databox-2.0.0b1/tests/disable_test_cli_mgmt_databox.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-databox-2.0.0/_meta.json` & `azure-mgmt-databox-2.0.0b1/_meta.json`

 * *Files 24% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/databox/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.4.0 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'c4eb7d4facbb9312f435df8c8ffe5061bfb02890'",*

 * * "'use'": "{insert: []*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/databox/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.8 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "6e70667577cfb7bc194785683ca591b95abd524c",
+    "autorest_command": "autorest specification/databox/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "c4eb7d4facbb9312f435df8c8ffe5061bfb02890",
     "readme": "specification/databox/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.8",
+        "@autorest/python@6.4.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-databox-2.0.0/CHANGELOG.md` & `azure-mgmt-databox-2.0.0b1/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,74 +1,96 @@
-# Release History
+Metadata-Version: 2.1
+Name: azure-mgmt-databox
+Version: 2.0.0b1
+Summary: Microsoft Azure Data Box Management Client Library for Python
+Home-page: https://github.com/Azure/azure-sdk-for-python
+Author: Microsoft Corporation
+Author-email: azpysdkhelp@microsoft.com
+License: MIT License
+Keywords: azure,azure sdk
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: MIT License
+Requires-Python: >=3.7
+Description-Content-Type: text/markdown
+License-File: LICENSE
 
-## 2.0.0 (2023-05-22)
+# Microsoft Azure SDK for Python
 
-### Features Added
+This is the Microsoft Azure Data Box Management Client Library.
+This package has been tested with Python 3.7+.
+For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
-  - Added operation JobsOperations.mark_devices_shipped
-  - Added operation group DataBoxManagementClientOperationsMixin
-  - Model CopyProgress has a new parameter actions
-  - Model CopyProgress has a new parameter error
-  - Model DataBoxDiskCopyProgress has a new parameter actions
-  - Model DataBoxDiskCopyProgress has a new parameter error
-  - Model DataBoxDiskJobDetails has a new parameter actions
-  - Model DataBoxDiskJobDetails has a new parameter data_center_code
-  - Model DataBoxDiskJobDetails has a new parameter datacenter_address
-  - Model DataBoxDiskJobDetails has a new parameter device_erasure_details
-  - Model DataBoxDiskJobDetails has a new parameter expected_data_size_in_tera_bytes
-  - Model DataBoxDiskJobDetails has a new parameter granular_copy_log_details
-  - Model DataBoxDiskJobDetails has a new parameter granular_copy_progress
-  - Model DataBoxDiskJobDetails has a new parameter last_mitigation_action_on_job
-  - Model DataBoxDiskJobDetails has a new parameter reverse_shipping_details
-  - Model DataBoxHeavyJobDetails has a new parameter actions
-  - Model DataBoxHeavyJobDetails has a new parameter data_center_code
-  - Model DataBoxHeavyJobDetails has a new parameter datacenter_address
-  - Model DataBoxHeavyJobDetails has a new parameter device_erasure_details
-  - Model DataBoxHeavyJobDetails has a new parameter expected_data_size_in_tera_bytes
-  - Model DataBoxHeavyJobDetails has a new parameter last_mitigation_action_on_job
-  - Model DataBoxHeavyJobDetails has a new parameter reverse_shipping_details
-  - Model DataBoxJobDetails has a new parameter actions
-  - Model DataBoxJobDetails has a new parameter data_center_code
-  - Model DataBoxJobDetails has a new parameter datacenter_address
-  - Model DataBoxJobDetails has a new parameter device_erasure_details
-  - Model DataBoxJobDetails has a new parameter expected_data_size_in_tera_bytes
-  - Model DataBoxJobDetails has a new parameter last_mitigation_action_on_job
-  - Model DataBoxJobDetails has a new parameter reverse_shipping_details
-  - Model DataImportDetails has a new parameter log_collection_level
-  - Model EncryptionPreferences has a new parameter hardware_encryption
-  - Model JobDetails has a new parameter actions
-  - Model JobDetails has a new parameter data_center_code
-  - Model JobDetails has a new parameter datacenter_address
-  - Model JobDetails has a new parameter device_erasure_details
-  - Model JobDetails has a new parameter expected_data_size_in_tera_bytes
-  - Model JobDetails has a new parameter last_mitigation_action_on_job
-  - Model JobDetails has a new parameter reverse_shipping_details
-  - Model JobResource has a new parameter reverse_shipping_details_update
-  - Model JobResource has a new parameter reverse_transport_preference_update
-  - Model JobResource has a new parameter system_data
-  - Model Preferences has a new parameter reverse_transport_preferences
-  - Model Preferences has a new parameter storage_account_access_tier_preferences
-  - Model RegionConfigurationRequest has a new parameter datacenter_address_request
-  - Model RegionConfigurationResponse has a new parameter datacenter_address_response
-  - Model ShippingAddress has a new parameter skip_address_validation
-  - Model ShippingAddress has a new parameter tax_identification_number
-  - Model SkuInformation has a new parameter countries_within_commerce_boundary
-  - Model TransportPreferences has a new parameter is_updated
-  - Model UpdateJobDetails has a new parameter preferences
-  - Model UpdateJobDetails has a new parameter return_to_customer_package_details
-  - Model UpdateJobDetails has a new parameter reverse_shipping_details
-
-### Breaking Changes
-
-  - Model DataBoxDiskJobDetails no longer has parameter expected_data_size_in_terabytes
-  - Model DataBoxHeavyJobDetails no longer has parameter expected_data_size_in_terabytes
-  - Model DataBoxJobDetails no longer has parameter expected_data_size_in_terabytes
-  - Model DiskScheduleAvailabilityRequest has a new required parameter expected_data_size_in_tera_bytes
-  - Model DiskScheduleAvailabilityRequest no longer has parameter expected_data_size_in_terabytes
-  - Model JobDetails no longer has parameter expected_data_size_in_terabytes
+## _Disclaimer_
+
+_Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
+
+## Getting started
+
+### Prerequisites
+
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
+
+### Install the package
+
+```bash
+pip install azure-mgmt-databox
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.databox import DataBoxManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = DataBoxManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+
+Code samples for this package can be found at [Data Box Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
+
+If you encounter any bugs or have suggestions, please file an issue in the
+[Issues](https://github.com/Azure/azure-sdk-for-python/issues)
+section of the project. 
+
+
+![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-databox%2FREADME.png)
+
+
+# Release History
 
 ## 2.0.0b1 (2023-02-10)
 
 ### Features Added
 
   - Added operation JobsOperations.mark_devices_shipped
   - Added operation group DataBoxManagementClientOperationsMixin
```

## Comparing `azure-mgmt-databox-2.0.0/setup.py` & `azure-mgmt-databox-2.0.0b1/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -66,14 +66,14 @@
         'azure.mgmt',
     ]),
     include_package_data=True,
     package_data={
         'pytyped': ['py.typed'],
     },
     install_requires=[
-        "isodate<1.0.0,>=0.6.1",
+        "msrest>=0.7.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
     python_requires=">=3.7"
 )
```

## Comparing `azure-mgmt-databox-2.0.0/README.md` & `azure-mgmt-databox-2.0.0b1/README.md`

 * *Files 6% similar despite different names*

```diff
@@ -41,17 +41,16 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = DataBoxManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-Code samples for this package can be found at:
-- [Search Data Box Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+Code samples for this package can be found at [Data Box Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
```

## Comparing `azure-mgmt-databox-2.0.0/LICENSE` & `azure-mgmt-databox-2.0.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure_mgmt_databox.egg-info/SOURCES.txt` & `azure-mgmt-databox-2.0.0b1/azure_mgmt_databox.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/_serialization.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -627,15 +627,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+                                xml_name = "{}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -1269,15 +1269,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1293,15 +1293,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_data_box_management_client.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/_operations_mixin.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/_operations_mixin.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-02-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2020-11-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-02-01")
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", "2020-11-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_data_box_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +105,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +137,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +168,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +200,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +231,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +267,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +299,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +333,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -387,15 +392,15 @@
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -440,17 +445,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -555,15 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -582,17 +586,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -620,15 +623,15 @@
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -674,17 +677,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -724,15 +726,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -740,17 +742,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -777,15 +778,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -804,17 +805,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -940,15 +940,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -999,32 +999,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1058,15 +1057,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1117,15 +1116,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1145,17 +1144,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1296,15 +1294,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1439,15 +1437,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1466,17 +1464,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1585,15 +1582,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1612,17 +1609,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1653,15 +1649,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1707,17 +1703,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -23,28 +24,32 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import DataBoxManagementClientMixinABC, _convert_request
+from .._vendor import _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_02_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2019_09_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,23 +138,21 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-02-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2020-11-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-02-01")
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", "2020-11-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -145,15 +150,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -305,15 +309,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -444,15 +447,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -567,15 +569,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -696,15 +697,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -842,15 +842,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,14 +41,18 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -79,15 +84,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +137,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -247,15 +251,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +278,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -313,15 +316,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +370,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -417,15 +419,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +435,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +498,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,15 +633,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -692,32 +692,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -751,15 +750,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -810,15 +809,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -838,17 +837,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -989,15 +987,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_02_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1132,15 +1130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1159,17 +1157,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1278,15 +1275,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1305,17 +1302,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1346,15 +1342,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1400,17 +1396,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,27 +25,30 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
-from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_02_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_11_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -56,21 +60,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +117,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-12-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-12-01")
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", "2021-03-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 from ._models_py3 import AvailableSkuRequest
 from ._models_py3 import AvailableSkusResult
 from ._models_py3 import AzureFileFilterDetails
 from ._models_py3 import BlobFilterDetails
 from ._models_py3 import CancellationReason
 from ._models_py3 import CloudError
 from ._models_py3 import ContactDetails
-from ._models_py3 import ContactInfo
 from ._models_py3 import CopyLogDetails
 from ._models_py3 import CopyProgress
 from ._models_py3 import CreateJobValidations
 from ._models_py3 import CreateOrderLimitForSubscriptionValidationRequest
 from ._models_py3 import CreateOrderLimitForSubscriptionValidationResponseProperties
 from ._models_py3 import CustomerDiskJobSecrets
 from ._models_py3 import DataAccountDetails
@@ -53,15 +52,14 @@
 from ._models_py3 import DataboxJobSecrets
 from ._models_py3 import DatacenterAddressInstructionResponse
 from ._models_py3 import DatacenterAddressLocationResponse
 from ._models_py3 import DatacenterAddressRequest
 from ._models_py3 import DatacenterAddressResponse
 from ._models_py3 import DcAccessSecurityCode
 from ._models_py3 import Details
-from ._models_py3 import DeviceErasureDetails
 from ._models_py3 import DiskScheduleAvailabilityRequest
 from ._models_py3 import DiskSecret
 from ._models_py3 import EncryptionPreferences
 from ._models_py3 import ErrorDetail
 from ._models_py3 import ExportDiskDetails
 from ._models_py3 import FilterFileDetails
 from ._models_py3 import GranularCopyLogDetails
@@ -91,15 +89,14 @@
 from ._models_py3 import Preferences
 from ._models_py3 import PreferencesValidationRequest
 from ._models_py3 import PreferencesValidationResponseProperties
 from ._models_py3 import RegionConfigurationRequest
 from ._models_py3 import RegionConfigurationResponse
 from ._models_py3 import Resource
 from ._models_py3 import ResourceIdentity
-from ._models_py3 import ReverseShippingDetails
 from ._models_py3 import ScheduleAvailabilityRequest
 from ._models_py3 import ScheduleAvailabilityResponse
 from ._models_py3 import ShareCredentialDetails
 from ._models_py3 import ShipmentPickUpRequest
 from ._models_py3 import ShipmentPickUpResponse
 from ._models_py3 import ShippingAddress
 from ._models_py3 import Sku
@@ -139,22 +136,19 @@
 from ._data_box_management_client_enums import CopyStatus
 from ._data_box_management_client_enums import CustomerResolutionCode
 from ._data_box_management_client_enums import DataAccountType
 from ._data_box_management_client_enums import DataCenterCode
 from ._data_box_management_client_enums import DatacenterAddressType
 from ._data_box_management_client_enums import DoubleEncryption
 from ._data_box_management_client_enums import FilterFileType
-from ._data_box_management_client_enums import HardwareEncryption
 from ._data_box_management_client_enums import JobDeliveryType
 from ._data_box_management_client_enums import KekType
 from ._data_box_management_client_enums import LogCollectionLevel
 from ._data_box_management_client_enums import NotificationStageName
 from ._data_box_management_client_enums import OverallValidationStatus
-from ._data_box_management_client_enums import ReverseShippingDetailsEditStatus
-from ._data_box_management_client_enums import ReverseTransportPreferenceEditStatus
 from ._data_box_management_client_enums import ShareDestinationFormatType
 from ._data_box_management_client_enums import SkuDisabledReason
 from ._data_box_management_client_enums import SkuName
 from ._data_box_management_client_enums import StageName
 from ._data_box_management_client_enums import StageStatus
 from ._data_box_management_client_enums import TransferConfigurationType
 from ._data_box_management_client_enums import TransferType
@@ -176,15 +170,14 @@
     "AvailableSkuRequest",
     "AvailableSkusResult",
     "AzureFileFilterDetails",
     "BlobFilterDetails",
     "CancellationReason",
     "CloudError",
     "ContactDetails",
-    "ContactInfo",
     "CopyLogDetails",
     "CopyProgress",
     "CreateJobValidations",
     "CreateOrderLimitForSubscriptionValidationRequest",
     "CreateOrderLimitForSubscriptionValidationResponseProperties",
     "CustomerDiskJobSecrets",
     "DataAccountDetails",
@@ -213,15 +206,14 @@
     "DataboxJobSecrets",
     "DatacenterAddressInstructionResponse",
     "DatacenterAddressLocationResponse",
     "DatacenterAddressRequest",
     "DatacenterAddressResponse",
     "DcAccessSecurityCode",
     "Details",
-    "DeviceErasureDetails",
     "DiskScheduleAvailabilityRequest",
     "DiskSecret",
     "EncryptionPreferences",
     "ErrorDetail",
     "ExportDiskDetails",
     "FilterFileDetails",
     "GranularCopyLogDetails",
@@ -251,15 +243,14 @@
     "Preferences",
     "PreferencesValidationRequest",
     "PreferencesValidationResponseProperties",
     "RegionConfigurationRequest",
     "RegionConfigurationResponse",
     "Resource",
     "ResourceIdentity",
-    "ReverseShippingDetails",
     "ScheduleAvailabilityRequest",
     "ScheduleAvailabilityResponse",
     "ShareCredentialDetails",
     "ShipmentPickUpRequest",
     "ShipmentPickUpResponse",
     "ShippingAddress",
     "Sku",
@@ -298,22 +289,19 @@
     "CopyStatus",
     "CustomerResolutionCode",
     "DataAccountType",
     "DataCenterCode",
     "DatacenterAddressType",
     "DoubleEncryption",
     "FilterFileType",
-    "HardwareEncryption",
     "JobDeliveryType",
     "KekType",
     "LogCollectionLevel",
     "NotificationStageName",
     "OverallValidationStatus",
-    "ReverseShippingDetailsEditStatus",
-    "ReverseTransportPreferenceEditStatus",
     "ShareDestinationFormatType",
     "SkuDisabledReason",
     "SkuName",
     "StageName",
     "StageStatus",
     "TransferConfigurationType",
     "TransferType",
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -206,23 +206,14 @@
 
     AZURE_BLOB = "AzureBlob"
     """Filter file is of the type AzureBlob."""
     AZURE_FILE = "AzureFile"
     """Filter file is of the type AzureFiles."""
 
 
-class HardwareEncryption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Defines Hardware level encryption (Only for disk)."""
-
-    ENABLED = "Enabled"
-    """Hardware-based encryption is enabled."""
-    DISABLED = "Disabled"
-    """Hardware-based encryption is enabled."""
-
-
 class JobDeliveryType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Delivery type of Job."""
 
     NON_SCHEDULED = "NonScheduled"
     """Non Scheduled job."""
     SCHEDULED = "Scheduled"
     """Scheduled job."""
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_models_py3.py`

 * *Files 1% similar despite different names*

```diff
@@ -762,18 +762,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_12_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_12_01.models.CustomerResolutionCode]
     """
 
     _validation = {
         "storage_account_name": {"readonly": True},
         "transfer_type": {"readonly": True},
         "data_account_type": {"readonly": True},
         "account_id": {"readonly": True},
@@ -784,16 +780,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
         "data_account_type": {"key": "dataAccountType", "type": "str"},
         "account_id": {"key": "accountId", "type": "str"},
@@ -804,16 +798,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.storage_account_name = None
         self.transfer_type = None
@@ -826,16 +818,14 @@
         self.invalid_files_processed = None
         self.invalid_file_bytes_uploaded = None
         self.renamed_container_count = None
         self.files_errored_out = None
         self.directories_errored_out = None
         self.invalid_directories_processed = None
         self.is_enumeration_in_progress = None
-        self.error = None
-        self.actions = None
 
 
 class ValidationRequest(_serialization.Model):
     """Minimum request requirement of any validation category.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     CreateJobValidations
@@ -1289,18 +1279,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_12_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_12_01.models.CustomerResolutionCode]
     :ivar serial_number: Disk Serial Number.
     :vartype serial_number: str
     :ivar copy_status: The Status of the copy. Known values are: "NotStarted", "InProgress",
      "Completed", "CompletedWithErrors", "Failed", "NotReturned", "HardwareError",
      "DeviceFormatted", "DeviceMetadataModified", "StorageAccountNotAccessible", "UnsupportedData",
      "DriveNotReceived", "UnsupportedDrive", "OtherServiceError", "OtherUserError",
      "DriveNotDetected", "DriveCorrupted", and "MetadataFilesModifiedOrRemoved".
@@ -1319,16 +1305,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
         "serial_number": {"readonly": True},
         "copy_status": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
@@ -1341,16 +1325,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
         "serial_number": {"key": "serialNumber", "type": "str"},
         "copy_status": {"key": "copyStatus", "type": "str"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
@@ -1778,47 +1760,37 @@
     :vartype percent_complete: int
     :ivar status: The Status of the copy. Known values are: "NotStarted", "InProgress",
      "Completed", "CompletedWithErrors", "Failed", "NotReturned", "HardwareError",
      "DeviceFormatted", "DeviceMetadataModified", "StorageAccountNotAccessible", "UnsupportedData",
      "DriveNotReceived", "UnsupportedDrive", "OtherServiceError", "OtherUserError",
      "DriveNotDetected", "DriveCorrupted", and "MetadataFilesModifiedOrRemoved".
     :vartype status: str or ~azure.mgmt.databox.v2022_12_01.models.CopyStatus
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_12_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_12_01.models.CustomerResolutionCode]
     """
 
     _validation = {
         "serial_number": {"readonly": True},
         "bytes_copied": {"readonly": True},
         "percent_complete": {"readonly": True},
         "status": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
     }
 
     _attribute_map = {
         "serial_number": {"key": "serialNumber", "type": "str"},
         "bytes_copied": {"key": "bytesCopied", "type": "int"},
         "percent_complete": {"key": "percentComplete", "type": "int"},
         "status": {"key": "status", "type": "str"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.serial_number = None
         self.bytes_copied = None
         self.percent_complete = None
         self.status = None
-        self.error = None
-        self.actions = None
 
 
 class GranularCopyLogDetails(_serialization.Model):
     """Granular Details for log generated during copy.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     DataBoxDiskGranularCopyLogDetails
@@ -1932,18 +1904,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_12_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_12_01.models.CustomerResolutionCode]
     """
 
     _validation = {
         "storage_account_name": {"readonly": True},
         "transfer_type": {"readonly": True},
         "data_account_type": {"readonly": True},
         "account_id": {"readonly": True},
@@ -1954,16 +1922,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
         "data_account_type": {"key": "dataAccountType", "type": "str"},
         "account_id": {"key": "accountId", "type": "str"},
@@ -1974,16 +1940,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.storage_account_name = None
         self.transfer_type = None
@@ -1996,16 +1960,14 @@
         self.invalid_files_processed = None
         self.invalid_file_bytes_uploaded = None
         self.renamed_container_count = None
         self.files_errored_out = None
         self.directories_errored_out = None
         self.invalid_directories_processed = None
         self.is_enumeration_in_progress = None
-        self.error = None
-        self.actions = None
 
 
 class DataBoxDiskGranularCopyProgress(GranularCopyProgress):  # pylint: disable=too-many-instance-attributes
     """DataBox Disk Granular Copy Progress.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -2042,18 +2004,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_12_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_12_01.models.CustomerResolutionCode]
     :ivar serial_number: Disk Serial Number.
     :vartype serial_number: str
     :ivar copy_status: The Status of the copy. Known values are: "NotStarted", "InProgress",
      "Completed", "CompletedWithErrors", "Failed", "NotReturned", "HardwareError",
      "DeviceFormatted", "DeviceMetadataModified", "StorageAccountNotAccessible", "UnsupportedData",
      "DriveNotReceived", "UnsupportedDrive", "OtherServiceError", "OtherUserError",
      "DriveNotDetected", "DriveCorrupted", and "MetadataFilesModifiedOrRemoved".
@@ -2072,16 +2030,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
         "serial_number": {"readonly": True},
         "copy_status": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
@@ -2094,16 +2050,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
         "serial_number": {"key": "serialNumber", "type": "str"},
         "copy_status": {"key": "copyStatus", "type": "str"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
@@ -3625,43 +3579,30 @@
 
 class EncryptionPreferences(_serialization.Model):
     """Preferences related to the Encryption.
 
     :ivar double_encryption: Defines secondary layer of software-based encryption enablement. Known
      values are: "Enabled" and "Disabled".
     :vartype double_encryption: str or ~azure.mgmt.databox.v2022_12_01.models.DoubleEncryption
-    :ivar hardware_encryption: Defines Hardware level encryption (Only for disk). Known values are:
-     "Enabled" and "Disabled".
-    :vartype hardware_encryption: str or ~azure.mgmt.databox.v2022_12_01.models.HardwareEncryption
     """
 
     _attribute_map = {
         "double_encryption": {"key": "doubleEncryption", "type": "str"},
-        "hardware_encryption": {"key": "hardwareEncryption", "type": "str"},
     }
 
     def __init__(
-        self,
-        *,
-        double_encryption: Union[str, "_models.DoubleEncryption"] = "Disabled",
-        hardware_encryption: Optional[Union[str, "_models.HardwareEncryption"]] = None,
-        **kwargs: Any
+        self, *, double_encryption: Union[str, "_models.DoubleEncryption"] = "Disabled", **kwargs: Any
     ) -> None:
         """
         :keyword double_encryption: Defines secondary layer of software-based encryption enablement.
          Known values are: "Enabled" and "Disabled".
         :paramtype double_encryption: str or ~azure.mgmt.databox.v2022_12_01.models.DoubleEncryption
-        :keyword hardware_encryption: Defines Hardware level encryption (Only for disk). Known values
-         are: "Enabled" and "Disabled".
-        :paramtype hardware_encryption: str or
-         ~azure.mgmt.databox.v2022_12_01.models.HardwareEncryption
         """
         super().__init__(**kwargs)
         self.double_encryption = double_encryption
-        self.hardware_encryption = hardware_encryption
 
 
 class ErrorDetail(_serialization.Model):
     """ErrorDetail.
 
     All required parameters must be populated in order to send to Azure.
 
@@ -5244,15 +5185,15 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.confirmation_number = None
         self.ready_by_time = None
 
 
-class ShippingAddress(_serialization.Model):  # pylint: disable=too-many-instance-attributes
+class ShippingAddress(_serialization.Model):
     """Shipping address where customer wishes to receive the device.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar street_address1: Street Address line 1. Required.
     :vartype street_address1: str
     :ivar street_address2: Street Address line 2.
@@ -5269,19 +5210,14 @@
     :vartype postal_code: str
     :ivar zip_extended_code: Extended Zip Code.
     :vartype zip_extended_code: str
     :ivar company_name: Name of the company.
     :vartype company_name: str
     :ivar address_type: Type of address. Known values are: "None", "Residential", and "Commercial".
     :vartype address_type: str or ~azure.mgmt.databox.v2022_12_01.models.AddressType
-    :ivar skip_address_validation: Flag to indicate if customer has chosen to skip default address
-     validation.
-    :vartype skip_address_validation: bool
-    :ivar tax_identification_number: Tax Identification Number.
-    :vartype tax_identification_number: str
     """
 
     _validation = {
         "street_address1": {"required": True},
         "country": {"required": True},
     }
 
@@ -5292,16 +5228,14 @@
         "city": {"key": "city", "type": "str"},
         "state_or_province": {"key": "stateOrProvince", "type": "str"},
         "country": {"key": "country", "type": "str"},
         "postal_code": {"key": "postalCode", "type": "str"},
         "zip_extended_code": {"key": "zipExtendedCode", "type": "str"},
         "company_name": {"key": "companyName", "type": "str"},
         "address_type": {"key": "addressType", "type": "str"},
-        "skip_address_validation": {"key": "skipAddressValidation", "type": "bool"},
-        "tax_identification_number": {"key": "taxIdentificationNumber", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         street_address1: str,
         country: str,
@@ -5309,16 +5243,14 @@
         street_address3: Optional[str] = None,
         city: Optional[str] = None,
         state_or_province: Optional[str] = None,
         postal_code: Optional[str] = None,
         zip_extended_code: Optional[str] = None,
         company_name: Optional[str] = None,
         address_type: Union[str, "_models.AddressType"] = "None",
-        skip_address_validation: Optional[bool] = None,
-        tax_identification_number: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword street_address1: Street Address line 1. Required.
         :paramtype street_address1: str
         :keyword street_address2: Street Address line 2.
         :paramtype street_address2: str
@@ -5335,33 +5267,26 @@
         :keyword zip_extended_code: Extended Zip Code.
         :paramtype zip_extended_code: str
         :keyword company_name: Name of the company.
         :paramtype company_name: str
         :keyword address_type: Type of address. Known values are: "None", "Residential", and
          "Commercial".
         :paramtype address_type: str or ~azure.mgmt.databox.v2022_12_01.models.AddressType
-        :keyword skip_address_validation: Flag to indicate if customer has chosen to skip default
-         address validation.
-        :paramtype skip_address_validation: bool
-        :keyword tax_identification_number: Tax Identification Number.
-        :paramtype tax_identification_number: str
         """
         super().__init__(**kwargs)
         self.street_address1 = street_address1
         self.street_address2 = street_address2
         self.street_address3 = street_address3
         self.city = city
         self.state_or_province = state_or_province
         self.country = country
         self.postal_code = postal_code
         self.zip_extended_code = zip_extended_code
         self.company_name = company_name
         self.address_type = address_type
-        self.skip_address_validation = skip_address_validation
-        self.tax_identification_number = tax_identification_number
 
 
 class Sku(_serialization.Model):
     """The Sku.
 
     All required parameters must be populated in order to send to Azure.
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -82,15 +87,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -139,15 +144,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +105,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +137,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +168,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +200,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +231,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +267,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +299,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +333,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -359,15 +364,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_12_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_12_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -381,21 +386,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -440,17 +445,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -477,15 +481,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2021_12_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -535,15 +539,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2021_12_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -555,15 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -582,17 +586,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -614,21 +617,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -674,17 +677,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -710,29 +712,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -740,17 +742,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -777,15 +778,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -804,17 +805,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -849,29 +849,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2021_12_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -901,15 +901,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -920,35 +920,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2021_12_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -999,47 +999,42 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
 
     @distributed_trace
     def begin_delete(self, resource_group_name: str, job_name: str, **kwargs: Any) -> LROPoller[None]:
@@ -1062,15 +1057,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1121,15 +1116,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1149,36 +1144,31 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
 
@@ -1199,15 +1189,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2021_12_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1216,15 +1206,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1257,15 +1247,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1281,15 +1271,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2021_12_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1298,21 +1288,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1369,21 +1359,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1404,15 +1394,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1426,36 +1416,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1474,17 +1464,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1516,15 +1505,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_12_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1573,15 +1562,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_12_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1593,15 +1582,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1620,17 +1609,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1655,21 +1643,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1715,17 +1703,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,95 +2,80 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import sys
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import DataBoxManagementClientMixinABC, _convert_request
-
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._operations import build_list_request
+from .._vendor import DataBoxManagementClientMixinABC
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_request(**kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_12_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_02_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.Operation]
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_02_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -123,33 +108,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-12-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2018-01-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-12-01")
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", "2018-01-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -48,15 +53,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -105,15 +110,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -145,15 +150,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -305,15 +309,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -444,15 +447,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -567,15 +569,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -696,15 +697,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -842,15 +842,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,25 +41,29 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_12_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -73,21 +78,21 @@
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +137,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -169,15 +173,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -227,15 +231,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -247,15 +251,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +278,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -307,21 +310,21 @@
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +370,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -403,29 +405,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +435,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +498,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -542,29 +542,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
@@ -594,15 +594,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> AsyncLROPoller[_models.JobResource]:
@@ -613,35 +613,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -692,32 +692,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -755,15 +754,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -814,15 +813,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -842,17 +841,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -892,15 +890,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -909,15 +907,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
@@ -950,15 +948,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
@@ -974,15 +972,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -991,21 +989,21 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1062,21 +1060,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1097,15 +1095,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1119,36 +1117,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1167,17 +1165,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1209,15 +1206,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1266,15 +1263,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1286,15 +1283,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1313,17 +1310,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1348,21 +1344,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.UnencryptedCredentials]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1408,17 +1404,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,25 +27,29 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_12_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_12_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -56,21 +61,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +118,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -32,15 +38,15 @@
     :keyword api_version: Api Version. Default value is "2020-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-04-01")
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", "2020-04-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_data_box_management_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -158,20 +163,17 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
-    accept = _headers.pop("Accept", "application/json")
-
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
@@ -180,27 +182,24 @@
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)
 
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -228,15 +227,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -260,18 +259,16 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
@@ -283,26 +280,25 @@
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -325,15 +321,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_04_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2018_01_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -347,21 +343,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -406,24 +402,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs"}
 
@@ -436,21 +430,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -496,24 +490,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs"
@@ -532,29 +524,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2018_01_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -562,25 +554,23 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -599,15 +589,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -626,25 +616,23 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
@@ -671,29 +659,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2018_01_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -723,15 +711,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -742,35 +730,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2018_01_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -821,40 +809,38 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
@@ -880,15 +866,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -939,15 +925,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -967,25 +953,23 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
@@ -1013,15 +997,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2018_01_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1030,15 +1014,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1071,15 +1055,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1095,15 +1079,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2018_01_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1112,21 +1096,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1183,21 +1167,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1218,15 +1202,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1240,36 +1224,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1288,25 +1272,23 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ShipmentPickUpResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -1330,15 +1312,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2018_01_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1387,15 +1369,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2018_01_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1407,15 +1389,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1434,25 +1416,23 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     cancel.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel"
     }
@@ -1469,21 +1449,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1529,24 +1509,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_credentials.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials"
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -23,28 +24,32 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import _convert_request
+from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_04_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_03_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -32,15 +38,15 @@
     :keyword api_version: Api Version. Default value is "2020-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-04-01")
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", "2020-04-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,14 +34,18 @@
     build_region_configuration_by_resource_group_request,
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -144,15 +149,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -209,17 +214,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -304,15 +308,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -330,17 +334,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -443,15 +446,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -470,17 +473,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -566,15 +568,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -592,17 +594,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -695,15 +696,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -721,17 +722,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -841,15 +841,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -868,17 +868,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,25 +39,29 @@
     build_get_request,
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_04_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_11_01.aio.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -71,21 +76,21 @@
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -130,17 +135,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -161,21 +165,21 @@
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -221,17 +225,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -257,29 +260,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -287,17 +290,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -324,15 +326,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -351,17 +353,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -396,29 +397,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
@@ -448,15 +449,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> AsyncLROPoller[_models.JobResource]:
@@ -467,35 +468,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -546,32 +547,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -605,15 +605,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -664,15 +664,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -692,17 +692,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -738,15 +737,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -755,15 +754,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
@@ -796,15 +795,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
@@ -820,15 +819,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -837,21 +836,21 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -908,21 +907,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -943,15 +942,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -965,36 +964,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1013,17 +1012,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1055,15 +1053,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1112,15 +1110,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1132,15 +1130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1159,17 +1157,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1194,21 +1191,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.UnencryptedCredentials]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1254,17 +1251,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,14 +26,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -61,15 +66,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,17 +117,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2020-11-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2021-08-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-11-01")
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop("api_version", "2021-08-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_data_box_management_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -161,15 +166,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -192,15 +197,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -228,15 +233,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -260,15 +265,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -294,15 +299,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -325,15 +330,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_11_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_04_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -347,21 +352,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -406,17 +411,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -436,21 +440,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -496,17 +500,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -532,29 +535,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -562,17 +565,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -599,15 +601,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -626,17 +628,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -671,29 +672,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -723,15 +724,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -742,35 +743,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -821,32 +822,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -880,15 +880,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -939,15 +939,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -967,17 +967,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1013,15 +1012,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1030,15 +1029,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1071,15 +1070,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1095,15 +1094,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1112,21 +1111,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1183,21 +1182,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1218,15 +1217,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1240,36 +1239,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1288,17 +1287,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1330,15 +1328,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1387,15 +1385,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1407,15 +1405,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1434,17 +1432,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1469,21 +1466,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1529,17 +1526,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -82,15 +87,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2020-11-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-11-01")
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", "2022-09-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,14 +34,18 @@
     build_region_configuration_by_resource_group_request,
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -144,15 +149,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -209,17 +214,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -304,15 +308,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -330,17 +334,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -443,15 +446,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -470,17 +473,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -566,15 +568,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -592,17 +594,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -695,15 +696,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -721,17 +722,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -841,15 +841,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -868,17 +868,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,25 +39,29 @@
     build_get_request,
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_11_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_04_01.aio.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -71,21 +76,21 @@
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -130,17 +135,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -161,21 +165,21 @@
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -221,17 +225,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -257,29 +260,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -287,17 +290,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -324,15 +326,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -351,17 +353,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -396,29 +397,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
@@ -448,15 +449,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> AsyncLROPoller[_models.JobResource]:
@@ -467,35 +468,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2020_04_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -546,32 +547,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -605,15 +605,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -664,15 +664,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -692,17 +692,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -738,15 +737,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -755,15 +754,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
@@ -796,15 +795,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
@@ -820,15 +819,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2020_04_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -837,21 +836,21 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2020_04_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -908,21 +907,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -943,15 +942,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -965,36 +964,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_04_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1013,17 +1012,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1055,15 +1053,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1112,15 +1110,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_04_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1132,15 +1130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1159,17 +1157,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1194,21 +1191,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.UnencryptedCredentials]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_04_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1254,17 +1251,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2020_11_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,25 +26,29 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2020_11_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2018_01_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -55,21 +60,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2020_11_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,23 +117,21 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_data_box_management_client.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/aio/_operations_mixin.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/aio/_operations_mixin.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-02-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-05-01")
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", "2022-02-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2021_05_01.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2021_03_01.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2021_05_01.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2021_03_01.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2021_05_01.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2021_03_01.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_data_box_management_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -233,15 +238,15 @@
 
 class ServiceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_05_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
         :attr:`service` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -264,21 +269,21 @@
         location.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2021_05_01.models.AvailableSkuRequest
+        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -298,15 +303,15 @@
         :param available_sku_request: Filters for showing the available skus. Required.
         :type available_sku_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -319,27 +324,27 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Is either a
          AvailableSkuRequest type or a IO type. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2021_05_01.models.AvailableSkuRequest or IO
+        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -430,21 +434,21 @@
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Required.
-        :type validate_address: ~azure.mgmt.databox.v2021_05_01.models.ValidateAddress
+        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_address(
         self, location: str, validate_address: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AddressValidationOutput:
@@ -456,50 +460,50 @@
         :param validate_address: Shipping address of the customer. Required.
         :type validate_address: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_address(
         self, location: str, validate_address: Union[_models.ValidateAddress, IO], **kwargs: Any
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Is either a ValidateAddress type or
          a IO type. Required.
-        :type validate_address: ~azure.mgmt.databox.v2021_05_01.models.ValidateAddress or IO
+        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -557,21 +560,21 @@
         """This method does all necessary pre-job creation validation under resource group.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -590,15 +593,15 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -610,35 +613,35 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -694,21 +696,21 @@
         **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_inputs(
         self, location: str, validation_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.ValidationResponse:
@@ -719,49 +721,49 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_inputs(
         self, location: str, validation_request: Union[_models.ValidationRequest, IO], **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -819,21 +820,21 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region.
          Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def region_configuration(
         self, location: str, region_configuration_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -846,15 +847,15 @@
          Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def region_configuration(
         self, location: str, region_configuration_request: Union[_models.RegionConfigurationRequest, IO], **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -862,35 +863,35 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region. Is
          either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -951,21 +951,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -986,15 +986,15 @@
          resource group level. Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -1008,35 +1008,35 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Is either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -161,15 +166,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -192,15 +197,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -228,15 +233,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -260,15 +265,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -294,15 +299,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -353,15 +358,15 @@
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -406,17 +411,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -442,15 +446,15 @@
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -496,17 +500,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -546,15 +549,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -562,17 +565,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -599,15 +601,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -626,17 +628,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -762,15 +763,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -821,32 +822,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -880,15 +880,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -939,15 +939,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -967,17 +967,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1118,15 +1117,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1261,15 +1260,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1288,17 +1287,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1407,15 +1405,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1434,17 +1432,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1475,15 +1472,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1529,17 +1526,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +64,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_05_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_08_01_preview.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +83,23 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +142,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/aio/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-02-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-05-01")
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", "2022-02-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -145,15 +150,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -305,15 +309,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -444,15 +447,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -567,15 +569,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -696,15 +697,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -842,15 +842,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -39,14 +40,18 @@
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -78,15 +83,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -131,17 +136,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -168,15 +172,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -222,17 +226,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -272,15 +275,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -288,17 +291,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -325,15 +327,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -352,17 +354,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -488,15 +489,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -547,32 +548,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -606,15 +606,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -665,15 +665,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -693,17 +693,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -844,15 +843,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_05_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -987,15 +986,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1014,17 +1013,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1133,15 +1131,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1160,17 +1158,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1201,15 +1198,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1255,17 +1252,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,25 +27,29 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_05_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -56,21 +61,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +118,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2019-09-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2019-09-01")
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", "2021-12-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_data_box_management_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_service_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_available_skus_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/availableSkus"
     )  # pylint: disable=line-too-long
@@ -62,21 +67,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -100,15 +105,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -127,21 +132,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -165,15 +170,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -196,15 +201,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -307,15 +312,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -371,17 +376,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -474,15 +478,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -539,17 +543,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -633,15 +636,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -659,17 +662,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -771,15 +773,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -798,17 +800,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -893,15 +894,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -919,17 +920,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1018,15 +1018,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1044,17 +1044,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
+from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -161,15 +166,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -192,15 +197,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -228,15 +233,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -260,15 +265,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -294,15 +299,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -325,15 +330,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2019_09_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_03_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -347,21 +352,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -406,23 +411,23 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs"}
 
@@ -435,21 +440,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -495,23 +500,23 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs"
@@ -530,29 +535,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2019_09_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2021_03_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -560,24 +565,24 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -596,15 +601,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -623,24 +628,24 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
@@ -667,29 +672,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2019_09_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2021_03_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -719,15 +724,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -738,35 +743,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2019_09_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2021_03_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -817,39 +822,39 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
@@ -875,15 +880,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -934,15 +939,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -962,24 +967,24 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
@@ -1007,15 +1012,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2019_09_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2021_03_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1024,15 +1029,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1065,15 +1070,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1089,15 +1094,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2019_09_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2021_03_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1106,21 +1111,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1177,21 +1182,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1212,15 +1217,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1234,36 +1239,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1282,24 +1287,24 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ShipmentPickUpResponse", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -1323,15 +1328,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2019_09_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_03_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1380,15 +1385,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2019_09_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_03_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1400,15 +1405,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1427,24 +1432,24 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     cancel.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel"
     }
@@ -1461,21 +1466,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1521,23 +1526,23 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_credentials.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials"
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2019_09_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_04_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_04_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2020-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,22 +138,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -32,15 +38,15 @@
     :keyword api_version: Api Version. Default value is "2019-09-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2019-09-01")
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", "2019-09-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,14 +34,18 @@
     build_list_available_skus_request,
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -124,15 +129,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -188,17 +193,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -294,15 +298,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -359,17 +363,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -453,15 +456,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -479,17 +482,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -591,15 +593,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -618,17 +620,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -713,15 +714,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -739,17 +740,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -838,15 +838,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -864,17 +864,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,14 +39,18 @@
     build_get_request,
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -77,15 +82,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -130,17 +135,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -166,15 +170,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -220,17 +224,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -269,15 +272,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -285,17 +288,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -321,15 +323,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -348,17 +350,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -483,15 +484,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -542,32 +543,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -600,15 +600,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -659,15 +659,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -687,17 +687,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -837,15 +836,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -980,15 +979,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1007,17 +1006,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1125,15 +1123,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1152,17 +1150,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1192,15 +1189,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1246,17 +1243,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,26 +25,31 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
+from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2019_09_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_10_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -55,21 +61,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,22 +118,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-10-01")
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", "2021-05-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_data_box_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_models_py3.py`

 * *Files 1% similar despite different names*

```diff
@@ -1760,47 +1760,37 @@
     :vartype percent_complete: int
     :ivar status: The Status of the copy. Known values are: "NotStarted", "InProgress",
      "Completed", "CompletedWithErrors", "Failed", "NotReturned", "HardwareError",
      "DeviceFormatted", "DeviceMetadataModified", "StorageAccountNotAccessible", "UnsupportedData",
      "DriveNotReceived", "UnsupportedDrive", "OtherServiceError", "OtherUserError",
      "DriveNotDetected", "DriveCorrupted", and "MetadataFilesModifiedOrRemoved".
     :vartype status: str or ~azure.mgmt.databox.v2022_10_01.models.CopyStatus
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_10_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_10_01.models.CustomerResolutionCode]
     """
 
     _validation = {
         "serial_number": {"readonly": True},
         "bytes_copied": {"readonly": True},
         "percent_complete": {"readonly": True},
         "status": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
     }
 
     _attribute_map = {
         "serial_number": {"key": "serialNumber", "type": "str"},
         "bytes_copied": {"key": "bytesCopied", "type": "int"},
         "percent_complete": {"key": "percentComplete", "type": "int"},
         "status": {"key": "status", "type": "str"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.serial_number = None
         self.bytes_copied = None
         self.percent_complete = None
         self.status = None
-        self.error = None
-        self.actions = None
 
 
 class GranularCopyLogDetails(_serialization.Model):
     """Granular Details for log generated during copy.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
     DataBoxDiskGranularCopyLogDetails
@@ -1914,18 +1904,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_10_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_10_01.models.CustomerResolutionCode]
     """
 
     _validation = {
         "storage_account_name": {"readonly": True},
         "transfer_type": {"readonly": True},
         "data_account_type": {"readonly": True},
         "account_id": {"readonly": True},
@@ -1936,16 +1922,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
         "data_account_type": {"key": "dataAccountType", "type": "str"},
         "account_id": {"key": "accountId", "type": "str"},
@@ -1956,16 +1940,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.storage_account_name = None
         self.transfer_type = None
@@ -1978,16 +1960,14 @@
         self.invalid_files_processed = None
         self.invalid_file_bytes_uploaded = None
         self.renamed_container_count = None
         self.files_errored_out = None
         self.directories_errored_out = None
         self.invalid_directories_processed = None
         self.is_enumeration_in_progress = None
-        self.error = None
-        self.actions = None
 
 
 class DataBoxDiskGranularCopyProgress(GranularCopyProgress):  # pylint: disable=too-many-instance-attributes
     """DataBox Disk Granular Copy Progress.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -2024,18 +2004,14 @@
     :ivar directories_errored_out: To indicate directories errored out in the job.
     :vartype directories_errored_out: int
     :ivar invalid_directories_processed: To indicate directories renamed.
     :vartype invalid_directories_processed: int
     :ivar is_enumeration_in_progress: To indicate if enumeration of data is in progress.
      Until this is true, the TotalBytesToProcess may not be valid.
     :vartype is_enumeration_in_progress: bool
-    :ivar error: Error, if any, in the stage.
-    :vartype error: ~azure.mgmt.databox.v2022_10_01.models.CloudError
-    :ivar actions: Available actions on the job.
-    :vartype actions: list[str or ~azure.mgmt.databox.v2022_10_01.models.CustomerResolutionCode]
     :ivar serial_number: Disk Serial Number.
     :vartype serial_number: str
     :ivar copy_status: The Status of the copy. Known values are: "NotStarted", "InProgress",
      "Completed", "CompletedWithErrors", "Failed", "NotReturned", "HardwareError",
      "DeviceFormatted", "DeviceMetadataModified", "StorageAccountNotAccessible", "UnsupportedData",
      "DriveNotReceived", "UnsupportedDrive", "OtherServiceError", "OtherUserError",
      "DriveNotDetected", "DriveCorrupted", and "MetadataFilesModifiedOrRemoved".
@@ -2054,16 +2030,14 @@
         "invalid_files_processed": {"readonly": True},
         "invalid_file_bytes_uploaded": {"readonly": True},
         "renamed_container_count": {"readonly": True},
         "files_errored_out": {"readonly": True},
         "directories_errored_out": {"readonly": True},
         "invalid_directories_processed": {"readonly": True},
         "is_enumeration_in_progress": {"readonly": True},
-        "error": {"readonly": True},
-        "actions": {"readonly": True},
         "serial_number": {"readonly": True},
         "copy_status": {"readonly": True},
     }
 
     _attribute_map = {
         "storage_account_name": {"key": "storageAccountName", "type": "str"},
         "transfer_type": {"key": "transferType", "type": "str"},
@@ -2076,16 +2050,14 @@
         "invalid_files_processed": {"key": "invalidFilesProcessed", "type": "int"},
         "invalid_file_bytes_uploaded": {"key": "invalidFileBytesUploaded", "type": "int"},
         "renamed_container_count": {"key": "renamedContainerCount", "type": "int"},
         "files_errored_out": {"key": "filesErroredOut", "type": "int"},
         "directories_errored_out": {"key": "directoriesErroredOut", "type": "int"},
         "invalid_directories_processed": {"key": "invalidDirectoriesProcessed", "type": "int"},
         "is_enumeration_in_progress": {"key": "isEnumerationInProgress", "type": "bool"},
-        "error": {"key": "error", "type": "CloudError"},
-        "actions": {"key": "actions", "type": "[str]"},
         "serial_number": {"key": "serialNumber", "type": "str"},
         "copy_status": {"key": "copyStatus", "type": "str"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_data_box_management_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -82,15 +87,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -139,15 +144,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +105,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +137,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +168,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +200,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +231,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +267,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +299,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +333,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -359,15 +364,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_10_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -381,21 +386,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -440,17 +445,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -477,15 +481,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_10_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -535,15 +539,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_10_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -555,15 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -582,17 +586,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -614,21 +617,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -674,17 +677,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -710,29 +712,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -740,17 +742,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -777,15 +778,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -804,17 +805,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -849,29 +849,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_10_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -901,15 +901,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -920,35 +920,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_10_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -999,32 +999,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1062,15 +1061,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1121,15 +1120,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1149,17 +1148,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1199,15 +1197,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_10_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1216,15 +1214,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1257,15 +1255,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1281,15 +1279,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_10_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1298,21 +1296,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1369,21 +1367,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1404,15 +1402,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1426,36 +1424,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1474,17 +1472,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1516,15 +1513,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_10_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1573,15 +1570,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_10_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1593,15 +1590,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1620,17 +1617,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1655,21 +1651,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1715,17 +1711,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_10_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_05_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-10-01")
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", "2021-03-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2022_10_01.aio.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2021_03_01.aio.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2022_10_01.aio.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2021_03_01.aio.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2022_10_01.aio.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2021_03_01.aio.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -48,15 +53,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -105,15 +110,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,25 +35,29 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_10_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_12_01.aio.DataBoxManagementClient`'s
         :attr:`service` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -75,22 +80,22 @@
         location.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_10_01.models.AvailableSkuRequest
+        :type available_sku_request: ~azure.mgmt.databox.v2021_12_01.models.AvailableSkuRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -111,15 +116,15 @@
         :type available_sku_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -132,28 +137,28 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Is either a
          AvailableSkuRequest type or a IO type. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_10_01.models.AvailableSkuRequest or IO
+        :type available_sku_request: ~azure.mgmt.databox.v2021_12_01.models.AvailableSkuRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -244,21 +248,21 @@
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_10_01.models.ValidateAddress
+        :type validate_address: ~azure.mgmt.databox.v2021_12_01.models.ValidateAddress
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_address(
         self, location: str, validate_address: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AddressValidationOutput:
@@ -270,50 +274,50 @@
         :param validate_address: Shipping address of the customer. Required.
         :type validate_address: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_address(
         self, location: str, validate_address: Union[_models.ValidateAddress, IO], **kwargs: Any
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Is either a ValidateAddress type or
          a IO type. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_10_01.models.ValidateAddress or IO
+        :type validate_address: ~azure.mgmt.databox.v2021_12_01.models.ValidateAddress or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -371,21 +374,21 @@
         """This method does all necessary pre-job creation validation under resource group.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -404,15 +407,15 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -424,35 +427,35 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -508,21 +510,21 @@
         **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs(
         self, location: str, validation_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.ValidationResponse:
@@ -533,49 +535,49 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs(
         self, location: str, validation_request: Union[_models.ValidationRequest, IO], **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,21 +634,21 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region.
          Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration(
         self, location: str, region_configuration_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -660,15 +661,15 @@
          Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration(
         self, location: str, region_configuration_request: Union[_models.RegionConfigurationRequest, IO], **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -676,35 +677,35 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region. Is
          either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -765,21 +765,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -800,15 +800,15 @@
          resource group level. Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -822,35 +822,35 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Is either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,14 +41,18 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -79,15 +84,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +137,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -247,15 +251,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +278,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -313,15 +316,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +370,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -417,15 +419,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +435,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +498,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,15 +633,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -692,32 +692,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -755,15 +754,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -814,15 +813,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -842,17 +841,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -997,15 +995,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1140,15 +1138,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1167,17 +1165,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1286,15 +1283,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1313,17 +1310,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1354,15 +1350,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1408,17 +1404,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_10_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,25 +27,29 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_10_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_12_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -56,21 +61,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +118,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2019-09-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-03-01")
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", "2019-09-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2021_03_01.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2021_12_01.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2021_03_01.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2021_12_01.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2021_03_01.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2021_12_01.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -82,15 +87,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -139,15 +144,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_11_01/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
+from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -161,15 +166,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -192,15 +197,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -228,15 +233,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -260,15 +265,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -294,15 +299,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -325,15 +330,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_03_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2020_11_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -347,21 +352,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -406,17 +411,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -436,21 +440,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -496,17 +500,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -532,29 +535,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_03_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -562,17 +565,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -599,15 +601,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -626,17 +628,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -671,29 +672,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_03_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -723,15 +724,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -742,35 +743,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_03_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2020_11_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -821,32 +822,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -880,15 +880,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -939,15 +939,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -967,17 +967,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1013,15 +1012,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_03_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1030,15 +1029,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1071,15 +1070,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1095,15 +1094,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_03_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2020_11_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1112,21 +1111,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2020_11_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1183,21 +1182,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1218,15 +1217,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1240,36 +1239,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_03_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2020_11_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1288,17 +1287,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1330,15 +1328,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_03_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1387,15 +1385,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_03_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2020_11_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1407,15 +1405,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1434,17 +1432,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1469,21 +1466,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2020_11_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2020-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-11-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1529,17 +1526,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+    api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_03_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_03_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
+from ._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-03-01")
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", "2022-09-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2021_03_01.aio.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2021_12_01.aio.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2021_03_01.aio.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2021_12_01.aio.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2021_03_01.aio.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2021_12_01.aio.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-03-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -48,15 +53,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -105,15 +110,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_12_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -145,15 +150,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_03_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -305,15 +309,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -444,15 +447,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -567,15 +569,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -696,15 +697,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -842,15 +842,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -39,14 +40,18 @@
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -78,15 +83,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -131,17 +136,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -168,15 +172,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -222,17 +226,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -272,15 +275,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -288,17 +291,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -325,15 +327,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -352,17 +354,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -488,15 +489,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -547,32 +548,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -606,15 +606,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -665,15 +665,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -693,17 +693,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -844,15 +843,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_03_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -987,15 +986,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1014,17 +1013,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1133,15 +1131,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1160,17 +1158,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1201,15 +1198,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_03_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1255,17 +1252,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,14 +27,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -62,15 +67,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_03_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +118,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-01-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2018-01-01")
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", "2021-05-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_data_box_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_service_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_available_skus_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/availableSkus"
     )  # pylint: disable=line-too-long
@@ -66,15 +71,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -177,15 +182,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -241,17 +246,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -332,15 +336,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -358,17 +362,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +134,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -158,17 +163,20 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
+    accept = _headers.pop("Accept", "application/json")
+
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
@@ -177,24 +185,27 @@
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -222,15 +233,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -254,16 +265,18 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
@@ -275,25 +288,26 @@
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -316,15 +330,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2018_01_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2019_09_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -338,21 +352,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -397,17 +411,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -426,21 +439,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -486,17 +499,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -521,29 +533,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2018_01_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2019_09_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -551,17 +563,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -587,15 +598,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -614,17 +625,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -658,29 +668,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2018_01_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2019_09_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -710,15 +720,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -729,35 +739,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2018_01_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2019_09_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -808,32 +818,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -866,15 +875,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -925,15 +934,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -953,17 +962,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -998,15 +1006,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2018_01_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2019_09_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1015,15 +1023,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1056,15 +1064,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1080,15 +1088,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2018_01_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2019_09_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1097,21 +1105,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2019_09_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1168,21 +1176,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1203,15 +1211,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1225,36 +1233,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2018_01_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2019_09_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1273,17 +1281,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1314,15 +1321,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2018_01_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2019_09_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1371,15 +1378,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2018_01_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2019_09_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1391,15 +1398,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1418,17 +1425,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1452,21 +1458,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2019_09_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1512,17 +1518,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -23,28 +24,32 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import _convert_request
+from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2018_01_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_10_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,22 +138,22 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-01-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2021-08-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2018-01-01")
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop("api_version", "2021-08-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,15 +50,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2020_04_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,14 +27,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._service_operations import build_list_available_skus_request, build_validate_address_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -117,15 +122,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -181,17 +186,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -272,15 +276,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -298,17 +302,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,14 +39,18 @@
     build_get_request,
     build_list_by_resource_group_request,
     build_list_credentials_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -77,15 +82,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -130,17 +135,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -166,15 +170,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -220,17 +224,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -269,15 +272,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -285,17 +288,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -321,15 +323,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -348,17 +350,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -483,15 +484,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -542,32 +543,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -600,15 +600,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -659,15 +659,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -687,17 +687,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -837,15 +836,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2018_01_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -980,15 +979,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1007,17 +1006,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1125,15 +1123,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1152,17 +1150,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -1192,15 +1189,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1246,17 +1243,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2018_01_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,25 +26,29 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2018_01_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2019_09_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -55,21 +60,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2018_01_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2019_09_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+        api_version: Literal["2019-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-09-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,17 +117,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-12-01")
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", "2022-12-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2021_12_01.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2022_09_01.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2021_12_01.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2022_09_01.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2021_12_01.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2022_09_01.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from ._models_py3 import AvailableSkuRequest
 from ._models_py3 import AvailableSkusResult
 from ._models_py3 import AzureFileFilterDetails
 from ._models_py3 import BlobFilterDetails
 from ._models_py3 import CancellationReason
 from ._models_py3 import CloudError
 from ._models_py3 import ContactDetails
+from ._models_py3 import ContactInfo
 from ._models_py3 import CopyLogDetails
 from ._models_py3 import CopyProgress
 from ._models_py3 import CreateJobValidations
 from ._models_py3 import CreateOrderLimitForSubscriptionValidationRequest
 from ._models_py3 import CreateOrderLimitForSubscriptionValidationResponseProperties
 from ._models_py3 import CustomerDiskJobSecrets
 from ._models_py3 import DataAccountDetails
@@ -52,14 +53,15 @@
 from ._models_py3 import DataboxJobSecrets
 from ._models_py3 import DatacenterAddressInstructionResponse
 from ._models_py3 import DatacenterAddressLocationResponse
 from ._models_py3 import DatacenterAddressRequest
 from ._models_py3 import DatacenterAddressResponse
 from ._models_py3 import DcAccessSecurityCode
 from ._models_py3 import Details
+from ._models_py3 import DeviceErasureDetails
 from ._models_py3 import DiskScheduleAvailabilityRequest
 from ._models_py3 import DiskSecret
 from ._models_py3 import EncryptionPreferences
 from ._models_py3 import ErrorDetail
 from ._models_py3 import ExportDiskDetails
 from ._models_py3 import FilterFileDetails
 from ._models_py3 import GranularCopyLogDetails
@@ -89,14 +91,15 @@
 from ._models_py3 import Preferences
 from ._models_py3 import PreferencesValidationRequest
 from ._models_py3 import PreferencesValidationResponseProperties
 from ._models_py3 import RegionConfigurationRequest
 from ._models_py3 import RegionConfigurationResponse
 from ._models_py3 import Resource
 from ._models_py3 import ResourceIdentity
+from ._models_py3 import ReverseShippingDetails
 from ._models_py3 import ScheduleAvailabilityRequest
 from ._models_py3 import ScheduleAvailabilityResponse
 from ._models_py3 import ShareCredentialDetails
 from ._models_py3 import ShipmentPickUpRequest
 from ._models_py3 import ShipmentPickUpResponse
 from ._models_py3 import ShippingAddress
 from ._models_py3 import Sku
@@ -141,14 +144,16 @@
 from ._data_box_management_client_enums import DoubleEncryption
 from ._data_box_management_client_enums import FilterFileType
 from ._data_box_management_client_enums import JobDeliveryType
 from ._data_box_management_client_enums import KekType
 from ._data_box_management_client_enums import LogCollectionLevel
 from ._data_box_management_client_enums import NotificationStageName
 from ._data_box_management_client_enums import OverallValidationStatus
+from ._data_box_management_client_enums import ReverseShippingDetailsEditStatus
+from ._data_box_management_client_enums import ReverseTransportPreferenceEditStatus
 from ._data_box_management_client_enums import ShareDestinationFormatType
 from ._data_box_management_client_enums import SkuDisabledReason
 from ._data_box_management_client_enums import SkuName
 from ._data_box_management_client_enums import StageName
 from ._data_box_management_client_enums import StageStatus
 from ._data_box_management_client_enums import TransferConfigurationType
 from ._data_box_management_client_enums import TransferType
@@ -170,14 +175,15 @@
     "AvailableSkuRequest",
     "AvailableSkusResult",
     "AzureFileFilterDetails",
     "BlobFilterDetails",
     "CancellationReason",
     "CloudError",
     "ContactDetails",
+    "ContactInfo",
     "CopyLogDetails",
     "CopyProgress",
     "CreateJobValidations",
     "CreateOrderLimitForSubscriptionValidationRequest",
     "CreateOrderLimitForSubscriptionValidationResponseProperties",
     "CustomerDiskJobSecrets",
     "DataAccountDetails",
@@ -206,14 +212,15 @@
     "DataboxJobSecrets",
     "DatacenterAddressInstructionResponse",
     "DatacenterAddressLocationResponse",
     "DatacenterAddressRequest",
     "DatacenterAddressResponse",
     "DcAccessSecurityCode",
     "Details",
+    "DeviceErasureDetails",
     "DiskScheduleAvailabilityRequest",
     "DiskSecret",
     "EncryptionPreferences",
     "ErrorDetail",
     "ExportDiskDetails",
     "FilterFileDetails",
     "GranularCopyLogDetails",
@@ -243,14 +250,15 @@
     "Preferences",
     "PreferencesValidationRequest",
     "PreferencesValidationResponseProperties",
     "RegionConfigurationRequest",
     "RegionConfigurationResponse",
     "Resource",
     "ResourceIdentity",
+    "ReverseShippingDetails",
     "ScheduleAvailabilityRequest",
     "ScheduleAvailabilityResponse",
     "ShareCredentialDetails",
     "ShipmentPickUpRequest",
     "ShipmentPickUpResponse",
     "ShippingAddress",
     "Sku",
@@ -294,14 +302,16 @@
     "DoubleEncryption",
     "FilterFileType",
     "JobDeliveryType",
     "KekType",
     "LogCollectionLevel",
     "NotificationStageName",
     "OverallValidationStatus",
+    "ReverseShippingDetailsEditStatus",
+    "ReverseTransportPreferenceEditStatus",
     "ShareDestinationFormatType",
     "SkuDisabledReason",
     "SkuName",
     "StageName",
     "StageStatus",
     "TransferConfigurationType",
     "TransferType",
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -82,15 +87,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -139,15 +144,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -331,15 +336,15 @@
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -491,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -630,15 +633,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -753,15 +755,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -882,15 +883,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1028,15 +1028,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +73,17 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +109,17 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +143,17 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +176,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +210,17 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +243,17 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +281,17 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +315,17 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +351,17 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -359,15 +384,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_12_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_08_01_preview.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -381,21 +406,24 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -440,17 +468,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -477,15 +504,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2021_12_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2021_08_01_preview.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -535,15 +562,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2021_12_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2021_08_01_preview.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -555,15 +582,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -582,17 +611,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -614,21 +642,24 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -674,17 +705,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -710,29 +740,31 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -740,17 +772,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -777,15 +808,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -804,17 +837,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -849,29 +881,30 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_12_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -901,15 +934,16 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -920,35 +954,38 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_12_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -999,32 +1036,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1058,15 +1096,17 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1117,15 +1157,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1145,17 +1187,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1191,15 +1232,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_12_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2021_08_01_preview.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1208,15 +1249,16 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1249,15 +1291,16 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1273,15 +1316,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_12_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2021_08_01_preview.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1290,21 +1333,24 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1361,21 +1407,22 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request:
+         ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1396,15 +1443,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1418,36 +1465,38 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpRequest or
-         IO
+        :type shipment_pick_up_request:
+         ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1466,17 +1515,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1508,15 +1556,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_12_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_08_01_preview.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1565,15 +1613,16 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_12_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2021_08_01_preview.models.CancellationReason or
+         IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1585,15 +1634,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1612,17 +1663,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1647,21 +1697,23 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1707,17 +1759,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_02_01/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+    api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_12_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_02_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_02_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-02-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-02-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -32,15 +38,15 @@
     :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-12-01")
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", "2021-12-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_data_box_management_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2021_12_01.aio.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2022_10_01.aio.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2021_12_01.aio.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2022_10_01.aio.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2021_12_01.aio.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2022_10_01.aio.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-12-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -48,15 +53,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -105,15 +110,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2021_12_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,25 +35,29 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_12_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
         :attr:`service` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -75,22 +80,22 @@
         location.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2021_12_01.models.AvailableSkuRequest
+        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -111,15 +116,15 @@
         :type available_sku_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -132,28 +137,28 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Is either a
          AvailableSkuRequest type or a IO type. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2021_12_01.models.AvailableSkuRequest or IO
+        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -244,21 +248,21 @@
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Required.
-        :type validate_address: ~azure.mgmt.databox.v2021_12_01.models.ValidateAddress
+        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_address(
         self, location: str, validate_address: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AddressValidationOutput:
@@ -270,50 +274,50 @@
         :param validate_address: Shipping address of the customer. Required.
         :type validate_address: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_address(
         self, location: str, validate_address: Union[_models.ValidateAddress, IO], **kwargs: Any
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Is either a ValidateAddress type or
          a IO type. Required.
-        :type validate_address: ~azure.mgmt.databox.v2021_12_01.models.ValidateAddress or IO
+        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -371,21 +374,21 @@
         """This method does all necessary pre-job creation validation under resource group.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -404,15 +407,15 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -424,35 +427,35 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -508,21 +510,21 @@
         **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs(
         self, location: str, validation_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.ValidationResponse:
@@ -533,49 +535,49 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs(
         self, location: str, validation_request: Union[_models.ValidationRequest, IO], **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2021_12_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,21 +634,21 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region.
          Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration(
         self, location: str, region_configuration_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -660,15 +661,15 @@
          Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration(
         self, location: str, region_configuration_request: Union[_models.RegionConfigurationRequest, IO], **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -676,35 +677,35 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region. Is
          either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -765,21 +765,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -800,15 +800,15 @@
          resource group level. Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -822,35 +822,35 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Is either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_12_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2022-09-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/aio/operations/_jobs_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,14 +41,18 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -79,15 +84,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +137,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -247,15 +251,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +278,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -313,15 +316,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +370,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -417,15 +419,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +435,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +498,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,15 +633,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -692,32 +692,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -751,15 +750,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -810,15 +809,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -838,17 +837,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -989,15 +987,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1132,15 +1130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1159,17 +1157,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1278,15 +1275,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1305,17 +1302,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1346,15 +1342,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1400,17 +1396,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_12_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/aio/operations/_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,25 +27,29 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_12_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_05_01.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -56,21 +61,21 @@
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_12_01.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_05_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -113,17 +118,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-08-01-preview". Note that overriding
-     this default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
+     default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-08-01-preview")
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", "2022-10-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/_data_box_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -160,15 +167,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -187,17 +196,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/operations/_service_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,34 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +77,17 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +106,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +146,17 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +179,17 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +208,23 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2021-08-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -335,15 +352,17 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -400,17 +419,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -495,15 +513,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -521,17 +541,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -635,15 +654,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -662,17 +683,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -759,15 +779,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -785,17 +807,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -888,15 +909,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -914,17 +937,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1034,15 +1056,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1061,17 +1085,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_jobs_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +105,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +137,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +168,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +200,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +231,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +267,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +299,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +333,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -359,15 +364,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_08_01_preview.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_12_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -381,22 +386,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -441,17 +445,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -478,15 +481,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -536,15 +539,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -556,15 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -583,17 +586,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -615,22 +617,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -676,17 +677,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -712,29 +712,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -742,17 +742,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -779,15 +778,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -806,17 +805,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -851,30 +849,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -904,16 +901,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -924,36 +920,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2021_08_01_preview.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -1004,43 +999,46 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
 
     @distributed_trace
     def begin_delete(self, resource_group_name: str, job_name: str, **kwargs: Any) -> LROPoller[None]:
@@ -1063,15 +1061,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1122,15 +1120,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1150,32 +1148,35 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("JobResource", pipeline_response)
 
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}"
     }
 
@@ -1196,15 +1197,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1213,16 +1214,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1255,16 +1255,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1280,15 +1279,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1297,22 +1296,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1369,22 +1367,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1405,15 +1402,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1427,36 +1424,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request:
-         ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpRequest or IO
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest or
+         IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2021_08_01_preview.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1475,17 +1472,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1517,15 +1513,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_08_01_preview.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1574,16 +1570,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2021_08_01_preview.models.CancellationReason or
-         IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1595,15 +1590,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1622,17 +1617,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1657,21 +1651,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1717,17 +1711,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,95 +2,82 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import sys
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import DataBoxManagementClientMixinABC, _convert_request
-
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._operations import build_list_request
+from .._vendor import DataBoxManagementClientMixinABC
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_request(**kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_08_01_preview.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_08_01_preview.aio.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.Operation]
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -123,33 +110,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
+from ._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-08-01-preview". Note that overriding
-     this default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2018-01-01". Note that overriding this
+     default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2021-08-01-preview")
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", "2018-01-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/_data_box_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2019_09_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_data_box_management_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -126,15 +131,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -153,17 +160,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_service_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
@@ -146,15 +151,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -211,17 +218,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -306,15 +312,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -332,17 +340,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -446,15 +453,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -473,17 +482,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -570,15 +578,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -596,17 +606,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -699,15 +708,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -725,17 +736,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -845,15 +855,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -872,17 +884,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,14 +41,18 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
@@ -79,15 +84,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +139,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -247,15 +253,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +282,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -313,15 +320,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +376,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -417,15 +425,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +443,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +479,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +508,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -636,15 +646,17 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -695,32 +707,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -754,15 +767,17 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -813,15 +828,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -841,17 +858,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -995,15 +1011,17 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2021_08_01_preview.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1139,15 +1157,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1166,17 +1186,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1286,15 +1305,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1313,17 +1334,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1354,15 +1374,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2021-08-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", "2021-08-01-preview")
+        )
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1408,17 +1430,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2021_08_01_preview/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2018_01_01/operations/_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,75 +2,100 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import sys
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._operations import build_list_request
-from .._vendor import DataBoxManagementClientMixinABC
-
+from .. import models as _models
+from ..._serialization import Serializer
+from .._vendor import _convert_request
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(**kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2021_08_01_preview.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2018_01_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2021_08_01_preview.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2018_01_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-01-preview"))
+        api_version: Literal["2018-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -103,33 +128,31 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-10-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-09-01")
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", "2022-10-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/_data_box_management_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -24,26 +24,26 @@
 
 class DataBoxManagementClient(
     DataBoxManagementClientOperationsMixin
 ):  # pylint: disable=client-accepts-api-version-keyword
     """The DataBox Client.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.databox.v2022_09_01.operations.Operations
+    :vartype operations: azure.mgmt.databox.v2021_05_01.operations.Operations
     :ivar jobs: JobsOperations operations
-    :vartype jobs: azure.mgmt.databox.v2022_09_01.operations.JobsOperations
+    :vartype jobs: azure.mgmt.databox.v2021_05_01.operations.JobsOperations
     :ivar service: ServiceOperations operations
-    :vartype service: azure.mgmt.databox.v2022_09_01.operations.ServiceOperations
+    :vartype service: azure.mgmt.databox.v2021_05_01.operations.ServiceOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2021-05-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_data_box_management_client_enums.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/models/_data_box_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/models/_models_py3.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_data_box_management_client_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_mitigate_request(job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/mitigate",
@@ -82,15 +87,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -139,15 +144,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2022_10_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -159,15 +164,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -186,17 +191,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_05_01/operations/_service_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_available_skus_by_resource_group_request(  # pylint: disable=name-too-long
+def build_list_available_skus_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/availableSkus",
@@ -70,15 +75,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_address_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateAddress",
@@ -97,21 +102,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_inputs_by_resource_group_request(  # pylint: disable=name-too-long
+def build_validate_inputs_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -135,15 +140,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_inputs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/validateInputs",
@@ -166,15 +171,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_region_configuration_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -193,21 +198,21 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_region_configuration_by_resource_group_request(  # pylint: disable=name-too-long
+def build_region_configuration_by_resource_group_request(
     resource_group_name: str, location: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/locations/{location}/regionConfiguration",
@@ -233,15 +238,15 @@
 
 class ServiceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_05_01.DataBoxManagementClient`'s
         :attr:`service` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -264,21 +269,21 @@
         location.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest
+        :type available_sku_request: ~azure.mgmt.databox.v2021_05_01.models.AvailableSkuRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -298,15 +303,15 @@
         :param available_sku_request: Filters for showing the available skus. Required.
         :type available_sku_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -319,27 +324,27 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Is either a
          AvailableSkuRequest type or a IO type. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest or IO
+        :type available_sku_request: ~azure.mgmt.databox.v2021_05_01.models.AvailableSkuRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_05_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -396,17 +401,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -430,21 +434,21 @@
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress
+        :type validate_address: ~azure.mgmt.databox.v2021_05_01.models.ValidateAddress
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_address(
         self, location: str, validate_address: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AddressValidationOutput:
@@ -456,50 +460,50 @@
         :param validate_address: Shipping address of the customer. Required.
         :type validate_address: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_address(
         self, location: str, validate_address: Union[_models.ValidateAddress, IO], **kwargs: Any
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Is either a ValidateAddress type or
          a IO type. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress or IO
+        :type validate_address: ~azure.mgmt.databox.v2021_05_01.models.ValidateAddress or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -517,17 +521,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -557,21 +560,21 @@
         """This method does all necessary pre-job creation validation under resource group.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -590,15 +593,15 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -610,35 +613,35 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -657,17 +660,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -694,21 +696,21 @@
         **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate_inputs(
         self, location: str, validation_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.ValidationResponse:
@@ -719,49 +721,49 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate_inputs(
         self, location: str, validation_request: Union[_models.ValidationRequest, IO], **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2021_05_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -779,17 +781,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -819,21 +820,21 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region.
          Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def region_configuration(
         self, location: str, region_configuration_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -846,15 +847,15 @@
          Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def region_configuration(
         self, location: str, region_configuration_request: Union[_models.RegionConfigurationRequest, IO], **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -862,35 +863,35 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region. Is
          either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -908,17 +909,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -951,21 +951,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -986,15 +986,15 @@
          resource group level. Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -1008,35 +1008,35 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Is either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2021_05_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -1055,17 +1055,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/operations/_jobs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DataBox/jobs")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -66,15 +71,15 @@
 
 def build_mark_devices_shipped_request(
     job_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/markDevicesShipped",
@@ -100,15 +105,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, skip_token: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs",
     )  # pylint: disable=line-too-long
@@ -132,15 +137,15 @@
 
 def build_get_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -163,15 +168,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -195,15 +200,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
     )  # pylint: disable=line-too-long
@@ -226,15 +231,15 @@
 
 def build_update_request(
     resource_group_name: str, job_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}",
@@ -262,15 +267,15 @@
 
 def build_book_shipment_pick_up_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/bookShipmentPickUp",
@@ -294,15 +299,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/cancel",
@@ -328,15 +333,15 @@
 
 def build_list_credentials_request(
     resource_group_name: str, job_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBox/jobs/{jobName}/listCredentials",
     )  # pylint: disable=line-too-long
@@ -359,15 +364,15 @@
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_10_01.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -381,21 +386,21 @@
         """Lists all the jobs available under the subscription.
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -440,17 +445,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -477,15 +481,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2022_10_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -535,15 +539,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2022_10_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -555,15 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -582,17 +586,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -614,21 +617,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -674,17 +677,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -710,29 +712,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -740,17 +742,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -777,15 +778,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -804,17 +805,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -849,29 +849,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2022_10_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
@@ -901,15 +901,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> LROPoller[_models.JobResource]:
@@ -920,35 +920,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2022_10_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -999,32 +999,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1062,15 +1061,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1121,15 +1120,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -1149,17 +1148,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1199,15 +1197,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2022_10_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1216,15 +1214,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
@@ -1257,15 +1255,15 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
@@ -1281,15 +1279,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2022_10_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1298,21 +1296,21 @@
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.databox.v2022_10_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1369,21 +1367,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1404,15 +1402,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1426,36 +1424,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1474,17 +1472,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1516,15 +1513,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_10_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1573,15 +1570,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_10_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1593,15 +1590,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1620,17 +1617,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1655,21 +1651,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.UnencryptedCredentials]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_10_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1715,17 +1711,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_12_01/operations/_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import DataBoxManagementClientMixinABC, _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+    api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -57,15 +62,15 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2021_12_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -76,21 +81,21 @@
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_09_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2021_12_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -133,17 +138,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_vendor.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_configuration.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/_configuration.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class DataBoxManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DataBoxManagementClient.
@@ -25,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The Subscription Id. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-09-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2022-12-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(DataBoxManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-09-01")
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", "2022-12-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_09_01/aio/_data_box_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DataBoxManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.jobs = JobsOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_patch.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_data_box_management_client_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2021_03_01/aio/operations/_data_box_management_client_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._data_box_management_client_operations import build_mitigate_request
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataBoxManagementClientOperationsMixin(DataBoxManagementClientMixinABC):
     @overload
     async def mitigate(  # pylint: disable=inconsistent-return-statements
@@ -48,15 +53,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -105,15 +110,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mitigate_job_request: Mitigation Request. Is either a MitigateJobRequest type or a IO
          type. Required.
-        :type mitigate_job_request: ~azure.mgmt.databox.v2022_09_01.models.MitigateJobRequest or IO
+        :type mitigate_job_request: ~azure.mgmt.databox.v2021_03_01.models.MitigateJobRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -125,15 +130,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2021-03-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mitigate_job_request, (IO, bytes)):
@@ -152,17 +157,16 @@
             template_url=self.mitigate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/__init__.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_service_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_10_01/aio/operations/_service_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,25 +35,29 @@
     build_region_configuration_request,
     build_validate_address_request,
     build_validate_inputs_by_resource_group_request,
     build_validate_inputs_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ServiceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_10_01.aio.DataBoxManagementClient`'s
         :attr:`service` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -75,22 +80,22 @@
         location.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest
+        :type available_sku_request: ~azure.mgmt.databox.v2022_10_01.models.AvailableSkuRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -111,15 +116,15 @@
         :type available_sku_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def list_available_skus_by_resource_group(
         self,
         resource_group_name: str,
@@ -132,28 +137,28 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param available_sku_request: Filters for showing the available skus. Is either a
          AvailableSkuRequest type or a IO type. Required.
-        :type available_sku_request: ~azure.mgmt.databox.v2022_09_01.models.AvailableSkuRequest or IO
+        :type available_sku_request: ~azure.mgmt.databox.v2022_10_01.models.AvailableSkuRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuInformation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.SkuInformation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_10_01.models.SkuInformation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AvailableSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -210,17 +215,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -244,21 +248,21 @@
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress
+        :type validate_address: ~azure.mgmt.databox.v2022_10_01.models.ValidateAddress
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_address(
         self, location: str, validate_address: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AddressValidationOutput:
@@ -270,50 +274,50 @@
         :param validate_address: Shipping address of the customer. Required.
         :type validate_address: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_address(
         self, location: str, validate_address: Union[_models.ValidateAddress, IO], **kwargs: Any
     ) -> _models.AddressValidationOutput:
         """[DEPRECATED NOTICE: This operation will soon be removed]. This method validates the customer
         shipping address and provide alternate addresses if any.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validate_address: Shipping address of the customer. Is either a ValidateAddress type or
          a IO type. Required.
-        :type validate_address: ~azure.mgmt.databox.v2022_09_01.models.ValidateAddress or IO
+        :type validate_address: ~azure.mgmt.databox.v2022_10_01.models.ValidateAddress or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AddressValidationOutput or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.AddressValidationOutput
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.AddressValidationOutput
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AddressValidationOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validate_address, (IO, bytes)):
@@ -331,17 +335,16 @@
             template_url=self.validate_address.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -371,21 +374,21 @@
         """This method does all necessary pre-job creation validation under resource group.
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -404,15 +407,15 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs_by_resource_group(
         self,
         resource_group_name: str,
@@ -424,35 +427,35 @@
 
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -471,17 +474,16 @@
             template_url=self.validate_inputs_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -508,21 +510,21 @@
         **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest
+        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate_inputs(
         self, location: str, validation_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.ValidationResponse:
@@ -533,49 +535,49 @@
         :param validation_request: Inputs of the customer. Required.
         :type validation_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate_inputs(
         self, location: str, validation_request: Union[_models.ValidationRequest, IO], **kwargs: Any
     ) -> _models.ValidationResponse:
         """This method does all necessary pre-job creation validation under subscription.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param validation_request: Inputs of the customer. Is either a ValidationRequest type or a IO
          type. Required.
-        :type validation_request: ~azure.mgmt.databox.v2022_09_01.models.ValidationRequest or IO
+        :type validation_request: ~azure.mgmt.databox.v2022_10_01.models.ValidationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ValidationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.ValidationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(validation_request, (IO, bytes)):
@@ -593,17 +595,16 @@
             template_url=self.validate_inputs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -633,21 +634,21 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region.
          Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration(
         self, location: str, region_configuration_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -660,15 +661,15 @@
          Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration(
         self, location: str, region_configuration_request: Union[_models.RegionConfigurationRequest, IO], **kwargs: Any
     ) -> _models.RegionConfigurationResponse:
@@ -676,35 +677,35 @@
         level.
 
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region. Is
          either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -722,17 +723,16 @@
             template_url=self.region_configuration.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -765,21 +765,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest
+         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -800,15 +800,15 @@
          resource group level. Required.
         :type region_configuration_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def region_configuration_by_resource_group(
         self,
         resource_group_name: str,
@@ -822,35 +822,35 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param location: The location of the resource. Required.
         :type location: str
         :param region_configuration_request: Request body to get the configuration for the region at
          resource group level. Is either a RegionConfigurationRequest type or a IO type. Required.
         :type region_configuration_request:
-         ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationRequest or IO
+         ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RegionConfigurationResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.RegionConfigurationResponse
+        :rtype: ~azure.mgmt.databox.v2022_10_01.models.RegionConfigurationResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RegionConfigurationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(region_configuration_request, (IO, bytes)):
@@ -869,17 +869,16 @@
             template_url=self.region_configuration_by_resource_group.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_jobs_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/aio/operations/_jobs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,25 +41,29 @@
     build_list_credentials_request,
     build_list_request,
     build_mark_devices_shipped_request,
     build_update_request,
 )
 from .._vendor import DataBoxManagementClientMixinABC
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_12_01.aio.DataBoxManagementClient`'s
         :attr:`jobs` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -73,21 +78,21 @@
 
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,17 +137,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -169,15 +173,15 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest
+         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -227,15 +231,15 @@
          Required.
         :type job_name: str
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param mark_devices_shipped_request: Mark Devices Shipped Request. Is either a
          MarkDevicesShippedRequest type or a IO type. Required.
         :type mark_devices_shipped_request:
-         ~azure.mgmt.databox.v2022_09_01.models.MarkDevicesShippedRequest or IO
+         ~azure.mgmt.databox.v2022_12_01.models.MarkDevicesShippedRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -247,15 +251,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(mark_devices_shipped_request, (IO, bytes)):
@@ -274,17 +278,16 @@
             template_url=self.mark_devices_shipped.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -307,21 +310,21 @@
         :type resource_group_name: str
         :param skip_token: $skipToken is supported on Get list of jobs, which provides the next page in
          the list of jobs. Default value is None.
         :type skip_token: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either JobResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResourceList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -367,17 +370,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -403,29 +405,29 @@
          Required.
         :type job_name: str
         :param expand: $expand is supported on details parameter for job, which provides details on the
          job stages. Default value is None.
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: JobResource or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.JobResource
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.JobResource
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             expand=expand,
@@ -433,17 +435,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -470,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource, (IO, bytes)):
@@ -497,17 +498,16 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -542,29 +542,29 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource
+        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
@@ -594,15 +594,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self, resource_group_name: str, job_name: str, job_resource: Union[_models.JobResource, IO], **kwargs: Any
     ) -> AsyncLROPoller[_models.JobResource]:
@@ -613,35 +613,35 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource: Job details from request body. Is either a JobResource type or a IO type.
          Required.
-        :type job_resource: ~azure.mgmt.databox.v2022_09_01.models.JobResource or IO
+        :type job_resource: ~azure.mgmt.databox.v2022_12_01.models.JobResource or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -692,32 +692,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             job_name=job_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -755,15 +754,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -814,15 +813,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.JobResource]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(job_resource_update_parameter, (IO, bytes)):
@@ -842,17 +841,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -892,15 +890,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter
+         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -909,15 +907,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
@@ -950,15 +948,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
@@ -974,15 +972,15 @@
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param job_resource_update_parameter: Job update parameters from request body. Is either a
          JobResourceUpdateParameter type or a IO type. Required.
         :type job_resource_update_parameter:
-         ~azure.mgmt.databox.v2022_09_01.models.JobResourceUpdateParameter or IO
+         ~azure.mgmt.databox.v2022_12_01.models.JobResourceUpdateParameter or IO
         :param if_match: Defines the If-Match condition. The patch will be performed only if the ETag
          of the job on the server matches this value. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -991,21 +989,21 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either JobResource or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_09_01.models.JobResource]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.databox.v2022_12_01.models.JobResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1062,21 +1060,21 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1097,15 +1095,15 @@
         :param shipment_pick_up_request: Details of shipment pick up request. Required.
         :type shipment_pick_up_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def book_shipment_pick_up(
         self,
         resource_group_name: str,
@@ -1119,36 +1117,36 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param shipment_pick_up_request: Details of shipment pick up request. Is either a
          ShipmentPickUpRequest type or a IO type. Required.
-        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpRequest or
+        :type shipment_pick_up_request: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ShipmentPickUpResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.databox.v2022_09_01.models.ShipmentPickUpResponse
+        :rtype: ~azure.mgmt.databox.v2022_12_01.models.ShipmentPickUpResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ShipmentPickUpResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(shipment_pick_up_request, (IO, bytes)):
@@ -1167,17 +1165,16 @@
             template_url=self.book_shipment_pick_up.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1209,15 +1206,15 @@
         :param resource_group_name: The Resource Group Name. Required.
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1266,15 +1263,15 @@
         :type resource_group_name: str
         :param job_name: The name of the job Resource within the specified resource group. job names
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :param cancellation_reason: Reason for cancellation. Is either a CancellationReason type or a
          IO type. Required.
-        :type cancellation_reason: ~azure.mgmt.databox.v2022_09_01.models.CancellationReason or IO
+        :type cancellation_reason: ~azure.mgmt.databox.v2022_12_01.models.CancellationReason or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1286,15 +1283,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(cancellation_reason, (IO, bytes)):
@@ -1313,17 +1310,16 @@
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
@@ -1348,21 +1344,21 @@
          must be between 3 and 24 characters in length and use any alphanumeric and underscore only.
          Required.
         :type job_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either UnencryptedCredentials or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.UnencryptedCredentials]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_12_01.models.UnencryptedCredentials]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.UnencryptedCredentialsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1408,17 +1404,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-databox-2.0.0/azure/mgmt/databox/v2022_09_01/aio/operations/_operations.py` & `azure-mgmt-databox-2.0.0b1/azure/mgmt/databox/v2022_12_01/operations/_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,75 +2,100 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import sys
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._operations import build_list_request
-from .._vendor import DataBoxManagementClientMixinABC
-
+from .. import models as _models
+from ..._serialization import Serializer
+from .._vendor import DataBoxManagementClientMixinABC, _convert_request
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(**kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop("template_url", "/providers/Microsoft.DataBox/operations")
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.databox.v2022_09_01.aio.DataBoxManagementClient`'s
+        :class:`~azure.mgmt.databox.v2022_12_01.DataBoxManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """This method gets all the operations.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.databox.v2022_09_01.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.databox.v2022_12_01.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-09-01"))
+        api_version: Literal["2022-12-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-12-01"))
         cls: ClsType[_models.OperationList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -103,33 +128,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ApiError, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.DataBox/operations"}
```

## Comparing `azure-mgmt-databox-2.0.0/tests/disable_test_cli_mgmt_databox.py` & `azure-mgmt-databox-2.0.0b1/tests/disable_test_cli_mgmt_databox.py`

 * *Files identical despite different names*

